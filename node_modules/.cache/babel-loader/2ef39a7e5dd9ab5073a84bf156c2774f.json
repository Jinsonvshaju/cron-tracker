{"ast":null,"code":"import { UNITS, SUPPORTED_SHORTCUTS } from './constants';\nimport { range, sort, dedup, setError } from './utils';\nexport function setValuesFromCronString(cronString, setInternalError, onError, allowEmpty, internalValueRef, firstRender, locale, shortcuts, setMinutes, setHours, setMonthDays, setMonths, setWeekDays, setPeriod) {\n  onError && onError(undefined);\n  setInternalError(false);\n  let error = false;\n\n  if (!cronString) {\n    if (allowEmpty === 'always' || firstRender && allowEmpty === 'for-default-value') {\n      return;\n    }\n\n    error = true;\n  }\n\n  if (!error) {\n    if (shortcuts && (shortcuts === true || shortcuts.includes(cronString))) {\n      if (cronString === '@reboot') {\n        setPeriod('reboot');\n        return;\n      }\n\n      const shortcutObject = SUPPORTED_SHORTCUTS.find(supportedShortcut => supportedShortcut.name === cronString);\n\n      if (shortcutObject) {\n        cronString = shortcutObject.value;\n      }\n    }\n\n    try {\n      const cronParts = parseCronString(cronString);\n      const period = getPeriodFromCronparts(cronParts);\n      setPeriod(period);\n      setMinutes(cronParts[0]);\n      setHours(cronParts[1]);\n      setMonthDays(cronParts[2]);\n      setMonths(cronParts[3]);\n      setWeekDays(cronParts[4]);\n    } catch (err) {\n      error = true;\n    }\n  }\n\n  if (error) {\n    internalValueRef.current = cronString;\n    setInternalError(true);\n    setError(onError, locale);\n  }\n}\nexport function getCronStringFromValues(period, months, monthDays, weekDays, hours, minutes, humanizeValue) {\n  if (period === 'reboot') {\n    return '@reboot';\n  }\n\n  const newMonths = period === 'year' && months ? months : [];\n  const newMonthDays = (period === 'year' || period === 'month') && monthDays ? monthDays : [];\n  const newWeekDays = (period === 'year' || period === 'month' || period === 'week') && weekDays ? weekDays : [];\n  const newHours = period !== 'minute' && period !== 'hour' && hours ? hours : [];\n  const newMinutes = period !== 'minute' && minutes ? minutes : [];\n  const parsedArray = parseCronArray([newMinutes, newHours, newMonthDays, newMonths, newWeekDays], humanizeValue);\n  return cronToString(parsedArray);\n}\nexport function partToString(cronPart, unit, humanize, leadingZero, clockFormat) {\n  let retval = '';\n\n  if (isFull(cronPart, unit) || cronPart.length === 0) {\n    retval = '*';\n  } else {\n    const step = getStep(cronPart);\n\n    if (step && isInterval(cronPart, step)) {\n      if (isFullInterval(cronPart, unit, step)) {\n        retval = `*/${step}`;\n      } else {\n        retval = `${formatValue(getMin(cronPart), unit, humanize, leadingZero, clockFormat)}-${formatValue(getMax(cronPart), unit, humanize, leadingZero, clockFormat)}/${step}`;\n      }\n    } else {\n      retval = toRanges(cronPart).map(range => {\n        if (Array.isArray(range)) {\n          return `${formatValue(range[0], unit, humanize, leadingZero, clockFormat)}-${formatValue(range[1], unit, humanize, leadingZero, clockFormat)}`;\n        }\n\n        return formatValue(range, unit, humanize, leadingZero, clockFormat);\n      }).join(',');\n    }\n  }\n\n  return retval;\n}\nexport function formatValue(value, unit, humanize, leadingZero, clockFormat) {\n  let cronPartString = value.toString();\n  const {\n    type,\n    alt,\n    min\n  } = unit;\n  const needLeadingZero = leadingZero && (leadingZero === true || leadingZero.includes(type));\n  const need24HourClock = clockFormat === '24-hour-clock' && (type === 'hours' || type === 'minutes');\n\n  if (humanize && type === 'week-days' || humanize && type === 'months') {\n    cronPartString = alt[value - min];\n  } else if (value < 10 && (needLeadingZero || need24HourClock)) {\n    cronPartString = cronPartString.padStart(2, '0');\n  }\n\n  if (type === 'hours' && clockFormat === '12-hour-clock') {\n    const suffix = value >= 12 ? 'PM' : 'AM';\n    let hour = value % 12 || 12;\n\n    if (hour < 10 && needLeadingZero) {\n      hour = hour.toString().padStart(2, '0');\n    }\n\n    cronPartString = `${hour}${suffix}`;\n  }\n\n  return cronPartString;\n}\n\nfunction parseCronArray(cronArr, humanizeValue) {\n  if (cronArr.length === 5) {\n    return cronArr.map((partArr, idx) => {\n      const unit = UNITS[idx];\n      const parsedArray = parsePartArray(partArr, unit);\n      return partToString(parsedArray, unit, humanizeValue);\n    });\n  }\n\n  throw new Error('Invalid cron array');\n}\n\nfunction cronToString(parts) {\n  return parts.join(' ');\n}\n\nfunction getPeriodFromCronparts(cronParts) {\n  if (cronParts[3].length > 0) {\n    return 'year';\n  } else if (cronParts[2].length > 0) {\n    return 'month';\n  } else if (cronParts[4].length > 0) {\n    return 'week';\n  } else if (cronParts[1].length > 0) {\n    return 'day';\n  } else if (cronParts[0].length > 0) {\n    return 'hour';\n  }\n\n  return 'minute';\n}\n\nfunction parseCronString(str) {\n  if (typeof str !== 'string') {\n    throw new Error('Invalid cron string');\n  }\n\n  const parts = str.replace(/\\s+/g, ' ').trim().split(' ');\n\n  if (parts.length === 5) {\n    return parts.map((partStr, idx) => {\n      return parsePartString(partStr, UNITS[idx]);\n    });\n  }\n\n  throw new Error('Invalid cron string format');\n}\n\nfunction parsePartString(str, unit) {\n  if (str === '*' || str === '*/1') {\n    return [];\n  }\n\n  const stringParts = str.split('/');\n\n  if (stringParts.length > 2) {\n    throw new Error(`Invalid value \"${unit.type}\"`);\n  }\n\n  const rangeString = replaceAlternatives(stringParts[0], unit.min, unit.alt);\n  let parsedValues;\n\n  if (rangeString === '*') {\n    parsedValues = range(unit.min, unit.max);\n  } else {\n    parsedValues = sort(dedup(fixSunday(rangeString.split(',').map(range => {\n      return parseRange(range, str, unit);\n    }).flat(), unit)));\n    const value = outOfRange(parsedValues, unit);\n\n    if (typeof value !== 'undefined') {\n      throw new Error(`Value \"${value}\" out of range for ${unit.type}`);\n    }\n  }\n\n  const step = parseStep(stringParts[1], unit);\n  const intervalValues = applyInterval(parsedValues, step);\n\n  if (intervalValues.length === unit.total) {\n    return [];\n  } else if (intervalValues.length === 0) {\n    throw new Error(`Empty interval value \"${str}\" for ${unit.type}`);\n  }\n\n  return intervalValues;\n}\n\nfunction replaceAlternatives(str, min, alt) {\n  if (alt) {\n    str = str.toUpperCase();\n\n    for (let i = 0; i < alt.length; i++) {\n      str = str.replace(alt[i], `${i + min}`);\n    }\n  }\n\n  return str;\n}\n\nfunction fixSunday(values, unit) {\n  if (unit.type === 'week-days') {\n    values = values.map(function (value) {\n      if (value === 7) {\n        return 0;\n      }\n\n      return value;\n    });\n  }\n\n  return values;\n}\n\nfunction parseRange(rangeStr, context, unit) {\n  const subparts = rangeStr.split('-');\n\n  if (subparts.length === 1) {\n    const value = parseInt(subparts[0], 10);\n\n    if (isNaN(value)) {\n      throw new Error(`Invalid value \"${context}\" for ${unit.type}`);\n    }\n\n    return [value];\n  } else if (subparts.length === 2) {\n    const minValue = parseInt(subparts[0], 10);\n    const maxValue = parseInt(subparts[1], 10);\n\n    if (maxValue < minValue) {\n      throw new Error(`Max range is less than min range in \"${rangeStr}\" for ${unit.type}`);\n    }\n\n    return range(minValue, maxValue);\n  } else {\n    throw new Error(`Invalid value \"${rangeStr}\" for ${unit.type}`);\n  }\n}\n\nfunction outOfRange(values, unit) {\n  const first = values[0];\n  const last = values[values.length - 1];\n\n  if (first < unit.min) {\n    return first;\n  } else if (last > unit.max) {\n    return last;\n  }\n\n  return;\n}\n\nfunction parseStep(step, unit) {\n  if (typeof step !== 'undefined') {\n    const parsedStep = parseInt(step, 10);\n\n    if (isNaN(parsedStep) || parsedStep < 1) {\n      throw new Error(`Invalid interval step value \"${step}\" for ${unit.type}`);\n    }\n\n    return parsedStep;\n  }\n}\n\nfunction applyInterval(values, step) {\n  if (step) {\n    const minVal = values[0];\n    values = values.filter(value => {\n      return value % step === minVal % step || value === minVal;\n    });\n  }\n\n  return values;\n}\n\nexport function parsePartArray(arr, unit) {\n  const values = sort(dedup(fixSunday(arr, unit)));\n\n  if (values.length === 0) {\n    return values;\n  }\n\n  const value = outOfRange(values, unit);\n\n  if (typeof value !== 'undefined') {\n    throw new Error(`Value \"${value}\" out of range for ${unit.type}`);\n  }\n\n  return values;\n}\n\nfunction isFull(values, unit) {\n  return values.length === unit.max - unit.min + 1;\n}\n\nfunction getStep(values) {\n  if (values.length > 2) {\n    const step = values[1] - values[0];\n\n    if (step > 1) {\n      return step;\n    }\n  }\n}\n\nfunction isInterval(values, step) {\n  for (let i = 1; i < values.length; i++) {\n    const prev = values[i - 1];\n    const value = values[i];\n\n    if (value - prev !== step) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isFullInterval(values, unit, step) {\n  const min = getMin(values);\n  const max = getMax(values);\n  const haveAllValues = values.length === (max - min) / step + 1;\n\n  if (min === unit.min && max + step > unit.max && haveAllValues) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getMin(values) {\n  return values[0];\n}\n\nfunction getMax(values) {\n  return values[values.length - 1];\n}\n\nfunction toRanges(values) {\n  const retval = [];\n  let startPart = null;\n  values.forEach((value, index, self) => {\n    if (value !== self[index + 1] - 1) {\n      if (startPart !== null) {\n        retval.push([startPart, value]);\n        startPart = null;\n      } else {\n        retval.push(value);\n      }\n    } else if (startPart === null) {\n      startPart = value;\n    }\n  });\n  return retval;\n}","map":{"version":3,"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/react-js-cron/dist/esm/converter.js"],"names":["UNITS","SUPPORTED_SHORTCUTS","range","sort","dedup","setError","setValuesFromCronString","cronString","setInternalError","onError","allowEmpty","internalValueRef","firstRender","locale","shortcuts","setMinutes","setHours","setMonthDays","setMonths","setWeekDays","setPeriod","undefined","error","includes","shortcutObject","find","supportedShortcut","name","value","cronParts","parseCronString","period","getPeriodFromCronparts","err","current","getCronStringFromValues","months","monthDays","weekDays","hours","minutes","humanizeValue","newMonths","newMonthDays","newWeekDays","newHours","newMinutes","parsedArray","parseCronArray","cronToString","partToString","cronPart","unit","humanize","leadingZero","clockFormat","retval","isFull","length","step","getStep","isInterval","isFullInterval","formatValue","getMin","getMax","toRanges","map","Array","isArray","join","cronPartString","toString","type","alt","min","needLeadingZero","need24HourClock","padStart","suffix","hour","cronArr","partArr","idx","parsePartArray","Error","parts","str","replace","trim","split","partStr","parsePartString","stringParts","rangeString","replaceAlternatives","parsedValues","max","fixSunday","parseRange","flat","outOfRange","parseStep","intervalValues","applyInterval","total","toUpperCase","i","values","rangeStr","context","subparts","parseInt","isNaN","minValue","maxValue","first","last","parsedStep","minVal","filter","arr","prev","haveAllValues","startPart","forEach","index","self","push"],"mappings":"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","sourcesContent":["import { UNITS, SUPPORTED_SHORTCUTS } from './constants';\nimport { range, sort, dedup, setError } from './utils';\nexport function setValuesFromCronString(cronString, setInternalError, onError, allowEmpty, internalValueRef, firstRender, locale, shortcuts, setMinutes, setHours, setMonthDays, setMonths, setWeekDays, setPeriod) {\n  onError && onError(undefined);\n  setInternalError(false);\n  let error = false;\n\n  if (!cronString) {\n    if (allowEmpty === 'always' || firstRender && allowEmpty === 'for-default-value') {\n      return;\n    }\n\n    error = true;\n  }\n\n  if (!error) {\n    if (shortcuts && (shortcuts === true || shortcuts.includes(cronString))) {\n      if (cronString === '@reboot') {\n        setPeriod('reboot');\n        return;\n      }\n\n      const shortcutObject = SUPPORTED_SHORTCUTS.find(supportedShortcut => supportedShortcut.name === cronString);\n\n      if (shortcutObject) {\n        cronString = shortcutObject.value;\n      }\n    }\n\n    try {\n      const cronParts = parseCronString(cronString);\n      const period = getPeriodFromCronparts(cronParts);\n      setPeriod(period);\n      setMinutes(cronParts[0]);\n      setHours(cronParts[1]);\n      setMonthDays(cronParts[2]);\n      setMonths(cronParts[3]);\n      setWeekDays(cronParts[4]);\n    } catch (err) {\n      error = true;\n    }\n  }\n\n  if (error) {\n    internalValueRef.current = cronString;\n    setInternalError(true);\n    setError(onError, locale);\n  }\n}\nexport function getCronStringFromValues(period, months, monthDays, weekDays, hours, minutes, humanizeValue) {\n  if (period === 'reboot') {\n    return '@reboot';\n  }\n\n  const newMonths = period === 'year' && months ? months : [];\n  const newMonthDays = (period === 'year' || period === 'month') && monthDays ? monthDays : [];\n  const newWeekDays = (period === 'year' || period === 'month' || period === 'week') && weekDays ? weekDays : [];\n  const newHours = period !== 'minute' && period !== 'hour' && hours ? hours : [];\n  const newMinutes = period !== 'minute' && minutes ? minutes : [];\n  const parsedArray = parseCronArray([newMinutes, newHours, newMonthDays, newMonths, newWeekDays], humanizeValue);\n  return cronToString(parsedArray);\n}\nexport function partToString(cronPart, unit, humanize, leadingZero, clockFormat) {\n  let retval = '';\n\n  if (isFull(cronPart, unit) || cronPart.length === 0) {\n    retval = '*';\n  } else {\n    const step = getStep(cronPart);\n\n    if (step && isInterval(cronPart, step)) {\n      if (isFullInterval(cronPart, unit, step)) {\n        retval = `*/${step}`;\n      } else {\n        retval = `${formatValue(getMin(cronPart), unit, humanize, leadingZero, clockFormat)}-${formatValue(getMax(cronPart), unit, humanize, leadingZero, clockFormat)}/${step}`;\n      }\n    } else {\n      retval = toRanges(cronPart).map(range => {\n        if (Array.isArray(range)) {\n          return `${formatValue(range[0], unit, humanize, leadingZero, clockFormat)}-${formatValue(range[1], unit, humanize, leadingZero, clockFormat)}`;\n        }\n\n        return formatValue(range, unit, humanize, leadingZero, clockFormat);\n      }).join(',');\n    }\n  }\n\n  return retval;\n}\nexport function formatValue(value, unit, humanize, leadingZero, clockFormat) {\n  let cronPartString = value.toString();\n  const {\n    type,\n    alt,\n    min\n  } = unit;\n  const needLeadingZero = leadingZero && (leadingZero === true || leadingZero.includes(type));\n  const need24HourClock = clockFormat === '24-hour-clock' && (type === 'hours' || type === 'minutes');\n\n  if (humanize && type === 'week-days' || humanize && type === 'months') {\n    cronPartString = alt[value - min];\n  } else if (value < 10 && (needLeadingZero || need24HourClock)) {\n    cronPartString = cronPartString.padStart(2, '0');\n  }\n\n  if (type === 'hours' && clockFormat === '12-hour-clock') {\n    const suffix = value >= 12 ? 'PM' : 'AM';\n    let hour = value % 12 || 12;\n\n    if (hour < 10 && needLeadingZero) {\n      hour = hour.toString().padStart(2, '0');\n    }\n\n    cronPartString = `${hour}${suffix}`;\n  }\n\n  return cronPartString;\n}\n\nfunction parseCronArray(cronArr, humanizeValue) {\n  if (cronArr.length === 5) {\n    return cronArr.map((partArr, idx) => {\n      const unit = UNITS[idx];\n      const parsedArray = parsePartArray(partArr, unit);\n      return partToString(parsedArray, unit, humanizeValue);\n    });\n  }\n\n  throw new Error('Invalid cron array');\n}\n\nfunction cronToString(parts) {\n  return parts.join(' ');\n}\n\nfunction getPeriodFromCronparts(cronParts) {\n  if (cronParts[3].length > 0) {\n    return 'year';\n  } else if (cronParts[2].length > 0) {\n    return 'month';\n  } else if (cronParts[4].length > 0) {\n    return 'week';\n  } else if (cronParts[1].length > 0) {\n    return 'day';\n  } else if (cronParts[0].length > 0) {\n    return 'hour';\n  }\n\n  return 'minute';\n}\n\nfunction parseCronString(str) {\n  if (typeof str !== 'string') {\n    throw new Error('Invalid cron string');\n  }\n\n  const parts = str.replace(/\\s+/g, ' ').trim().split(' ');\n\n  if (parts.length === 5) {\n    return parts.map((partStr, idx) => {\n      return parsePartString(partStr, UNITS[idx]);\n    });\n  }\n\n  throw new Error('Invalid cron string format');\n}\n\nfunction parsePartString(str, unit) {\n  if (str === '*' || str === '*/1') {\n    return [];\n  }\n\n  const stringParts = str.split('/');\n\n  if (stringParts.length > 2) {\n    throw new Error(`Invalid value \"${unit.type}\"`);\n  }\n\n  const rangeString = replaceAlternatives(stringParts[0], unit.min, unit.alt);\n  let parsedValues;\n\n  if (rangeString === '*') {\n    parsedValues = range(unit.min, unit.max);\n  } else {\n    parsedValues = sort(dedup(fixSunday(rangeString.split(',').map(range => {\n      return parseRange(range, str, unit);\n    }).flat(), unit)));\n    const value = outOfRange(parsedValues, unit);\n\n    if (typeof value !== 'undefined') {\n      throw new Error(`Value \"${value}\" out of range for ${unit.type}`);\n    }\n  }\n\n  const step = parseStep(stringParts[1], unit);\n  const intervalValues = applyInterval(parsedValues, step);\n\n  if (intervalValues.length === unit.total) {\n    return [];\n  } else if (intervalValues.length === 0) {\n    throw new Error(`Empty interval value \"${str}\" for ${unit.type}`);\n  }\n\n  return intervalValues;\n}\n\nfunction replaceAlternatives(str, min, alt) {\n  if (alt) {\n    str = str.toUpperCase();\n\n    for (let i = 0; i < alt.length; i++) {\n      str = str.replace(alt[i], `${i + min}`);\n    }\n  }\n\n  return str;\n}\n\nfunction fixSunday(values, unit) {\n  if (unit.type === 'week-days') {\n    values = values.map(function (value) {\n      if (value === 7) {\n        return 0;\n      }\n\n      return value;\n    });\n  }\n\n  return values;\n}\n\nfunction parseRange(rangeStr, context, unit) {\n  const subparts = rangeStr.split('-');\n\n  if (subparts.length === 1) {\n    const value = parseInt(subparts[0], 10);\n\n    if (isNaN(value)) {\n      throw new Error(`Invalid value \"${context}\" for ${unit.type}`);\n    }\n\n    return [value];\n  } else if (subparts.length === 2) {\n    const minValue = parseInt(subparts[0], 10);\n    const maxValue = parseInt(subparts[1], 10);\n\n    if (maxValue < minValue) {\n      throw new Error(`Max range is less than min range in \"${rangeStr}\" for ${unit.type}`);\n    }\n\n    return range(minValue, maxValue);\n  } else {\n    throw new Error(`Invalid value \"${rangeStr}\" for ${unit.type}`);\n  }\n}\n\nfunction outOfRange(values, unit) {\n  const first = values[0];\n  const last = values[values.length - 1];\n\n  if (first < unit.min) {\n    return first;\n  } else if (last > unit.max) {\n    return last;\n  }\n\n  return;\n}\n\nfunction parseStep(step, unit) {\n  if (typeof step !== 'undefined') {\n    const parsedStep = parseInt(step, 10);\n\n    if (isNaN(parsedStep) || parsedStep < 1) {\n      throw new Error(`Invalid interval step value \"${step}\" for ${unit.type}`);\n    }\n\n    return parsedStep;\n  }\n}\n\nfunction applyInterval(values, step) {\n  if (step) {\n    const minVal = values[0];\n    values = values.filter(value => {\n      return value % step === minVal % step || value === minVal;\n    });\n  }\n\n  return values;\n}\n\nexport function parsePartArray(arr, unit) {\n  const values = sort(dedup(fixSunday(arr, unit)));\n\n  if (values.length === 0) {\n    return values;\n  }\n\n  const value = outOfRange(values, unit);\n\n  if (typeof value !== 'undefined') {\n    throw new Error(`Value \"${value}\" out of range for ${unit.type}`);\n  }\n\n  return values;\n}\n\nfunction isFull(values, unit) {\n  return values.length === unit.max - unit.min + 1;\n}\n\nfunction getStep(values) {\n  if (values.length > 2) {\n    const step = values[1] - values[0];\n\n    if (step > 1) {\n      return step;\n    }\n  }\n}\n\nfunction isInterval(values, step) {\n  for (let i = 1; i < values.length; i++) {\n    const prev = values[i - 1];\n    const value = values[i];\n\n    if (value - prev !== step) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isFullInterval(values, unit, step) {\n  const min = getMin(values);\n  const max = getMax(values);\n  const haveAllValues = values.length === (max - min) / step + 1;\n\n  if (min === unit.min && max + step > unit.max && haveAllValues) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getMin(values) {\n  return values[0];\n}\n\nfunction getMax(values) {\n  return values[values.length - 1];\n}\n\nfunction toRanges(values) {\n  const retval = [];\n  let startPart = null;\n  values.forEach((value, index, self) => {\n    if (value !== self[index + 1] - 1) {\n      if (startPart !== null) {\n        retval.push([startPart, value]);\n        startPart = null;\n      } else {\n        retval.push(value);\n      }\n    } else if (startPart === null) {\n      startPart = value;\n    }\n  });\n  return retval;\n}"]},"metadata":{},"sourceType":"module"}