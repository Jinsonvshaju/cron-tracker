{"ast":null,"code":"/*\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport function isRefObject(value) {\n  return value != null && typeof value !== \"function\";\n}\nexport function isRefCallback(value) {\n  return typeof value === \"function\";\n}\n/**\n * Assign the given ref to a target, either a React ref object or a callback which takes the ref as its first argument.\n */\n\nexport function setRef(refTarget, ref) {\n  if (isRefObject(refTarget)) {\n    refTarget.current = ref;\n  } else if (isRefCallback(refTarget)) {\n    refTarget(ref);\n  }\n}\n/** @deprecated use mergeRefs() instead */\n\nexport function combineRefs(ref1, ref2) {\n  return mergeRefs(ref1, ref2);\n}\n/**\n * Utility for merging refs into one singular callback ref.\n * If using in a functional component, would recomend using `useMemo` to preserve function identity.\n */\n\nexport function mergeRefs() {\n  var refs = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    refs[_i] = arguments[_i];\n  }\n\n  return function (value) {\n    refs.forEach(function (ref) {\n      setRef(ref, value);\n    });\n  };\n}\nexport function getRef(ref) {\n  var _a;\n\n  if (ref === null) {\n    return null;\n  }\n\n  return (_a = ref.current) !== null && _a !== void 0 ? _a : ref;\n}\n/**\n * Creates a ref handler which assigns the ref returned by React for a mounted component to a field on the target object.\n * The target object is usually a component class.\n *\n * If provided, it will also update the given `refProp` with the value of the ref.\n */\n\nexport function refHandler(refTargetParent, refTargetKey, refProp) {\n  return function (ref) {\n    refTargetParent[refTargetKey] = ref;\n    setRef(refProp, ref);\n  };\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;AAuBA,OAAM,SAAUA,WAAV,CAA6CC,KAA7C,EAA8E;AAChF,SAAOA,KAAK,IAAI,IAAT,IAAiB,OAAOA,KAAP,KAAiB,UAAzC;AACH;AAID,OAAM,SAAUC,aAAV,CAA+CD,KAA/C,EAAgF;AAClF,SAAO,OAAOA,KAAP,KAAiB,UAAxB;AACH;AAED;;;;AAGA,OAAM,SAAUE,MAAV,CAAwCC,SAAxC,EAA+EC,GAA/E,EAA4F;AAC9F,MAAIL,WAAW,CAAII,SAAJ,CAAf,EAA+B;AAC3BA,aAAS,CAACE,OAAV,GAAoBD,GAApB;AACH,GAFD,MAEO,IAAIH,aAAa,CAACE,SAAD,CAAjB,EAA8B;AACjCA,aAAS,CAACC,GAAD,CAAT;AACH;AACJ;AAED;;AACA,OAAM,SAAUE,WAAV,CAA6CC,IAA7C,EAAoEC,IAApE,EAAyF;AAC3F,SAAOC,SAAS,CAACF,IAAD,EAAOC,IAAP,CAAhB;AACH;AAED;;;;;AAIA,OAAM,SAAUC,SAAV,GAAmB;AAAwB;;OAAA,yCAA8B;AAA9BC;;;AAC7C,SAAO,iBAAK;AACRA,QAAI,CAACC,OAAL,CAAa,eAAG;AACZT,YAAM,CAACE,GAAD,EAAMJ,KAAN,CAAN;AACH,KAFD;AAGH,GAJD;AAKH;AAED,OAAM,SAAUY,MAAV,CAAwCR,GAAxC,EAAqE;;;AACvE,MAAIA,GAAG,KAAK,IAAZ,EAAkB;AACd,WAAO,IAAP;AACH;;AAED,SAAO,MAACA,GAAqB,CAACC,OAAvB,MAA8B,IAA9B,IAA8BQ,aAA9B,GAA8BA,EAA9B,GAAmCT,GAA1C;AACH;AAED;;;;;;;AAMA,OAAM,SAAUU,UAAV,CACFC,eADE,EAEFC,YAFE,EAGFC,OAHE,EAGkC;AAEpC,SAAO,UAACb,GAAD,EAAc;AACjBW,mBAAe,CAACC,YAAD,CAAf,GAAgCZ,GAAhC;AACAF,UAAM,CAACe,OAAD,EAAUb,GAAV,CAAN;AACH,GAHD;AAIH","names":["isRefObject","value","isRefCallback","setRef","refTarget","ref","current","combineRefs","ref1","ref2","mergeRefs","refs","forEach","getRef","_a","refHandler","refTargetParent","refTargetKey","refProp"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/core/src/common/refs.ts"],"sourcesContent":["/*\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type IRef<T extends HTMLElement = HTMLElement> = IRefObject<T> | IRefCallback<T>;\n\n// compatible with React.Ref type in @types/react@^16\nexport interface IRefObject<T extends HTMLElement = HTMLElement> {\n    current: T | null;\n}\n\nexport function isRefObject<T extends HTMLElement>(value: IRef<T> | undefined | null): value is IRefObject<T> {\n    return value != null && typeof value !== \"function\";\n}\n\nexport type IRefCallback<T extends HTMLElement = HTMLElement> = (ref: T | null) => any;\n\nexport function isRefCallback<T extends HTMLElement>(value: IRef<T> | undefined | null): value is IRefCallback<T> {\n    return typeof value === \"function\";\n}\n\n/**\n * Assign the given ref to a target, either a React ref object or a callback which takes the ref as its first argument.\n */\nexport function setRef<T extends HTMLElement>(refTarget: IRef<T> | undefined | null, ref: T | null): void {\n    if (isRefObject<T>(refTarget)) {\n        refTarget.current = ref;\n    } else if (isRefCallback(refTarget)) {\n        refTarget(ref);\n    }\n}\n\n/** @deprecated use mergeRefs() instead */\nexport function combineRefs<T extends HTMLElement>(ref1: IRefCallback<T>, ref2: IRefCallback<T>) {\n    return mergeRefs(ref1, ref2);\n}\n\n/**\n * Utility for merging refs into one singular callback ref.\n * If using in a functional component, would recomend using `useMemo` to preserve function identity.\n */\nexport function mergeRefs<T extends HTMLElement>(...refs: Array<IRef<T> | null>): IRefCallback<T> {\n    return value => {\n        refs.forEach(ref => {\n            setRef(ref, value);\n        });\n    };\n}\n\nexport function getRef<T extends HTMLElement>(ref: T | IRefObject<T> | null): T | null {\n    if (ref === null) {\n        return null;\n    }\n\n    return (ref as IRefObject<T>).current ?? (ref as T);\n}\n\n/**\n * Creates a ref handler which assigns the ref returned by React for a mounted component to a field on the target object.\n * The target object is usually a component class.\n *\n * If provided, it will also update the given `refProp` with the value of the ref.\n */\nexport function refHandler<T extends HTMLElement, K extends string>(\n    refTargetParent: { [k in K]: T | null },\n    refTargetKey: K,\n    refProp?: IRef<T> | undefined | null,\n): IRefCallback<T> {\n    return (ref: T | null) => {\n        refTargetParent[refTargetKey] = ref;\n        setRef(refProp, ref);\n    };\n}\n"]},"metadata":{},"sourceType":"module"}