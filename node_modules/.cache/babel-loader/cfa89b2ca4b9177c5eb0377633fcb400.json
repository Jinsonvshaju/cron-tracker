{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __spreadArray } from \"tslib\";\nimport * as React from \"react\";\nimport { HOTKEYS_PROVIDER_NOT_FOUND } from \"../../common/errors\";\nimport { comboMatches, getKeyCombo, parseKeyCombo } from \"../../components/hotkeys/hotkeyParser\";\nimport { HotkeysContext } from \"../../context\";\n/**\n * React hook to register global and local hotkeys for a component.\n *\n * @param keys list of hotkeys to configure\n * @param options hook options\n */\n\nexport function useHotkeys(keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.document,\n      document = _a === void 0 ? getDefaultDocument() : _a,\n      _b = options.showDialogKeyCombo,\n      showDialogKeyCombo = _b === void 0 ? \"?\" : _b;\n  var localKeys = React.useMemo(function () {\n    return keys.filter(function (k) {\n      return !k.global;\n    }).map(function (k) {\n      return {\n        combo: parseKeyCombo(k.combo),\n        config: k\n      };\n    });\n  }, [keys]);\n  var globalKeys = React.useMemo(function () {\n    return keys.filter(function (k) {\n      return k.global;\n    }).map(function (k) {\n      return {\n        combo: parseKeyCombo(k.combo),\n        config: k\n      };\n    });\n  }, [keys]); // register keys with global context\n\n  var _c = React.useContext(HotkeysContext),\n      state = _c[0],\n      dispatch = _c[1];\n\n  if (!state.hasProvider) {\n    React.useEffect(function () {\n      return console.warn(HOTKEYS_PROVIDER_NOT_FOUND);\n    }, []);\n  } // we can still bind the hotkeys if there is no HotkeysProvider, they just won't show up in the dialog\n\n\n  React.useEffect(function () {\n    var payload = __spreadArray(__spreadArray([], globalKeys.map(function (k) {\n      return k.config;\n    }), true), localKeys.map(function (k) {\n      return k.config;\n    }), true);\n\n    dispatch({\n      type: \"ADD_HOTKEYS\",\n      payload: payload\n    });\n    return function () {\n      return dispatch({\n        type: \"REMOVE_HOTKEYS\",\n        payload: payload\n      });\n    };\n  }, [keys]);\n\n  var invokeNamedCallbackIfComboRecognized = function (global, combo, callbackName, e) {\n    var _a, _b;\n\n    var isTextInput = isTargetATextInput(e);\n\n    for (var _i = 0, _c = global ? globalKeys : localKeys; _i < _c.length; _i++) {\n      var key = _c[_i];\n      var _d = key.config,\n          _e = _d.allowInInput,\n          allowInInput = _e === void 0 ? false : _e,\n          _f = _d.disabled,\n          disabled = _f === void 0 ? false : _f,\n          _g = _d.preventDefault,\n          preventDefault = _g === void 0 ? false : _g,\n          _h = _d.stopPropagation,\n          stopPropagation = _h === void 0 ? false : _h;\n      var shouldIgnore = isTextInput && !allowInInput || disabled;\n\n      if (!shouldIgnore && comboMatches(key.combo, combo)) {\n        if (preventDefault) {\n          e.preventDefault();\n        }\n\n        if (stopPropagation) {\n          // set a flag just for unit testing. not meant to be referenced in feature work.\n          e.isPropagationStopped = true;\n          e.stopPropagation();\n        }\n\n        (_b = (_a = key.config)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n      }\n    }\n  };\n\n  var handleGlobalKeyDown = React.useCallback(function (e) {\n    // special case for global keydown: if '?' is pressed, open the hotkeys dialog\n    var combo = getKeyCombo(e);\n    var isTextInput = isTargetATextInput(e);\n\n    if (!isTextInput && comboMatches(parseKeyCombo(showDialogKeyCombo), combo)) {\n      dispatch({\n        type: \"OPEN_DIALOG\"\n      });\n    } else {\n      invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyDown\", e);\n    }\n  }, [globalKeys]);\n  var handleGlobalKeyUp = React.useCallback(function (e) {\n    return invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyUp\", e);\n  }, [globalKeys]);\n  var handleLocalKeyDown = React.useCallback(function (e) {\n    return invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyDown\", e.nativeEvent);\n  }, [localKeys]);\n  var handleLocalKeyUp = React.useCallback(function (e) {\n    return invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyUp\", e.nativeEvent);\n  }, [localKeys]);\n  React.useEffect(function () {\n    // document is guaranteed to be defined inside effects\n    document.addEventListener(\"keydown\", handleGlobalKeyDown);\n    document.addEventListener(\"keyup\", handleGlobalKeyUp);\n    return function () {\n      document.removeEventListener(\"keydown\", handleGlobalKeyDown);\n      document.removeEventListener(\"keyup\", handleGlobalKeyUp);\n    };\n  }, [handleGlobalKeyDown, handleGlobalKeyUp]);\n  return {\n    handleKeyDown: handleLocalKeyDown,\n    handleKeyUp: handleLocalKeyUp\n  };\n}\n/**\n * @returns true if the event target is a text input which should take priority over hotkey bindings\n */\n\nfunction isTargetATextInput(e) {\n  var elem = e.target; // we check these cases for unit testing, but this should not happen\n  // during normal operation\n\n  if (elem == null || elem.closest == null) {\n    return false;\n  }\n\n  var editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n  if (editable == null) {\n    return false;\n  } // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n\n\n  if (editable.tagName.toLowerCase() === \"input\") {\n    var inputType = editable.type;\n\n    if (inputType === \"checkbox\" || inputType === \"radio\") {\n      return false;\n    }\n  } // don't let read-only fields prevent hotkey behavior\n\n\n  if (editable.readOnly) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getDefaultDocument() {\n  if (typeof window === \"undefined\") {\n    return undefined;\n  }\n\n  return window.document;\n}","map":{"version":3,"mappings":"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","names":["React","HOTKEYS_PROVIDER_NOT_FOUND","comboMatches","getKeyCombo","parseKeyCombo","HotkeysContext","useHotkeys","keys","options","getDefaultDocument","_a","_b","showDialogKeyCombo","localKeys","useMemo","filter","k","global","map","combo","config","globalKeys","useContext","state","dispatch","hasProvider","useEffect","warn","payload","type","invokeNamedCallbackIfComboRecognized","callbackName","e","isTextInput","isTargetATextInput","_i","key","_e","allowInInput","_f","disabled","_g","preventDefault","_h","stopPropagation","shouldIgnore","isPropagationStopped","handleGlobalKeyDown","useCallback","handleGlobalKeyUp","handleLocalKeyDown","nativeEvent","handleLocalKeyUp","document","addEventListener","removeEventListener","handleKeyDown","handleKeyUp","elem","target","closest","editable","tagName","toLowerCase","inputType","readOnly","window","undefined"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/core/src/hooks/hotkeys/useHotkeys.ts"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as React from \"react\";\n\nimport { HOTKEYS_PROVIDER_NOT_FOUND } from \"../../common/errors\";\nimport { comboMatches, getKeyCombo, IKeyCombo, parseKeyCombo } from \"../../components/hotkeys/hotkeyParser\";\nimport { HotkeysContext } from \"../../context\";\nimport { HotkeyConfig } from \"./hotkeyConfig\";\n\nexport interface UseHotkeysOptions {\n    /**\n     * A custom document to reference when binding global event handlers.\n     * This can be useful when using iframes in an application.\n     *\n     * @default window.document\n     */\n    document?: Document;\n\n    /**\n     * The key combo which will trigger the hotkeys dialog to open.\n     *\n     * @default \"?\"\n     */\n    showDialogKeyCombo?: string;\n}\n\nexport interface UseHotkeysReturnValue {\n    handleKeyDown: React.KeyboardEventHandler<HTMLElement>;\n    handleKeyUp: React.KeyboardEventHandler<HTMLElement>;\n}\n\n/**\n * React hook to register global and local hotkeys for a component.\n *\n * @param keys list of hotkeys to configure\n * @param options hook options\n */\nexport function useHotkeys(keys: readonly HotkeyConfig[], options: UseHotkeysOptions = {}): UseHotkeysReturnValue {\n    const { document = getDefaultDocument(), showDialogKeyCombo = \"?\" } = options;\n    const localKeys = React.useMemo(\n        () =>\n            keys\n                .filter(k => !k.global)\n                .map(k => ({\n                    combo: parseKeyCombo(k.combo),\n                    config: k,\n                })),\n        [keys],\n    );\n    const globalKeys = React.useMemo(\n        () =>\n            keys\n                .filter(k => k.global)\n                .map(k => ({\n                    combo: parseKeyCombo(k.combo),\n                    config: k,\n                })),\n        [keys],\n    );\n\n    // register keys with global context\n    const [state, dispatch] = React.useContext(HotkeysContext);\n\n    if (!state.hasProvider) {\n        React.useEffect(() => console.warn(HOTKEYS_PROVIDER_NOT_FOUND), []);\n    }\n\n    // we can still bind the hotkeys if there is no HotkeysProvider, they just won't show up in the dialog\n    React.useEffect(() => {\n        const payload = [...globalKeys.map(k => k.config), ...localKeys.map(k => k.config)];\n        dispatch({ type: \"ADD_HOTKEYS\", payload });\n        return () => dispatch({ type: \"REMOVE_HOTKEYS\", payload });\n    }, [keys]);\n\n    const invokeNamedCallbackIfComboRecognized = (\n        global: boolean,\n        combo: IKeyCombo,\n        callbackName: \"onKeyDown\" | \"onKeyUp\",\n        e: KeyboardEvent,\n    ) => {\n        const isTextInput = isTargetATextInput(e);\n        for (const key of global ? globalKeys : localKeys) {\n            const {\n                allowInInput = false,\n                disabled = false,\n                preventDefault = false,\n                stopPropagation = false,\n            } = key.config;\n            const shouldIgnore = (isTextInput && !allowInInput) || disabled;\n            if (!shouldIgnore && comboMatches(key.combo, combo)) {\n                if (preventDefault) {\n                    e.preventDefault();\n                }\n                if (stopPropagation) {\n                    // set a flag just for unit testing. not meant to be referenced in feature work.\n                    (e as any).isPropagationStopped = true;\n                    e.stopPropagation();\n                }\n                key.config[callbackName]?.(e);\n            }\n        }\n    };\n\n    const handleGlobalKeyDown = React.useCallback(\n        (e: KeyboardEvent) => {\n            // special case for global keydown: if '?' is pressed, open the hotkeys dialog\n            const combo = getKeyCombo(e);\n            const isTextInput = isTargetATextInput(e);\n            if (!isTextInput && comboMatches(parseKeyCombo(showDialogKeyCombo), combo)) {\n                dispatch({ type: \"OPEN_DIALOG\" });\n            } else {\n                invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyDown\", e);\n            }\n        },\n        [globalKeys],\n    );\n    const handleGlobalKeyUp = React.useCallback(\n        (e: KeyboardEvent) => invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyUp\", e),\n        [globalKeys],\n    );\n\n    const handleLocalKeyDown = React.useCallback(\n        (e: React.KeyboardEvent<HTMLElement>) =>\n            invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyDown\", e.nativeEvent),\n        [localKeys],\n    );\n    const handleLocalKeyUp = React.useCallback(\n        (e: React.KeyboardEvent<HTMLElement>) =>\n            invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyUp\", e.nativeEvent),\n        [localKeys],\n    );\n\n    React.useEffect(() => {\n        // document is guaranteed to be defined inside effects\n        document!.addEventListener(\"keydown\", handleGlobalKeyDown);\n        document!.addEventListener(\"keyup\", handleGlobalKeyUp);\n        return () => {\n            document!.removeEventListener(\"keydown\", handleGlobalKeyDown);\n            document!.removeEventListener(\"keyup\", handleGlobalKeyUp);\n        };\n    }, [handleGlobalKeyDown, handleGlobalKeyUp]);\n\n    return { handleKeyDown: handleLocalKeyDown, handleKeyUp: handleLocalKeyUp };\n}\n\n/**\n * @returns true if the event target is a text input which should take priority over hotkey bindings\n */\nfunction isTargetATextInput(e: KeyboardEvent) {\n    const elem = e.target as HTMLElement;\n    // we check these cases for unit testing, but this should not happen\n    // during normal operation\n    if (elem == null || elem.closest == null) {\n        return false;\n    }\n\n    const editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n    if (editable == null) {\n        return false;\n    }\n\n    // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n    if (editable.tagName.toLowerCase() === \"input\") {\n        const inputType = (editable as HTMLInputElement).type;\n        if (inputType === \"checkbox\" || inputType === \"radio\") {\n            return false;\n        }\n    }\n\n    // don't let read-only fields prevent hotkey behavior\n    if ((editable as HTMLInputElement).readOnly) {\n        return false;\n    }\n\n    return true;\n}\n\nfunction getDefaultDocument(): Document | undefined {\n    if (typeof window === \"undefined\") {\n        return undefined;\n    }\n    return window.document;\n}\n"]},"metadata":{},"sourceType":"module"}