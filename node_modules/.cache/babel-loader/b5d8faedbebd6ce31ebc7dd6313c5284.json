{"ast":null,"code":"/*\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CLAMP_MIN_MAX } from \"../errors\";\n/** Returns whether `process.env.NODE_ENV` exists and equals `env`. */\n\nexport function isNodeEnv(env) {\n  return typeof process !== \"undefined\" && process.env && process.env.NODE_ENV === env;\n}\n/**\n * Returns the difference in length between two arrays. A `null` argument is\n * considered an empty list. The return value will be positive if `a` is longer\n * than `b`, negative if the opposite is true, and zero if their lengths are\n * equal.\n */\n\nexport function arrayLengthCompare(a, b) {\n  if (a === void 0) {\n    a = [];\n  }\n\n  if (b === void 0) {\n    b = [];\n  }\n\n  return a.length - b.length;\n}\n/**\n * Returns true if the two numbers are within the given tolerance of each other.\n * This is useful to correct for floating point precision issues, less useful\n * for integers.\n */\n\nexport function approxEqual(a, b, tolerance) {\n  if (tolerance === void 0) {\n    tolerance = 0.00001;\n  }\n\n  return Math.abs(a - b) <= tolerance;\n}\n/**\n * Clamps the given number between min and max values. Returns value if within\n * range, or closest bound.\n */\n\nexport function clamp(val, min, max) {\n  if (val == null) {\n    return val;\n  }\n\n  if (max < min) {\n    throw new Error(CLAMP_MIN_MAX);\n  }\n\n  return Math.min(Math.max(val, min), max);\n}\n/** Returns the number of decimal places in the given number. */\n\nexport function countDecimalPlaces(num) {\n  if (!isFinite(num)) {\n    return 0;\n  }\n\n  var e = 1;\n  var p = 0;\n\n  while (Math.round(num * e) / e !== num) {\n    e *= 10;\n    p++;\n  }\n\n  return p;\n}\nvar uniqueCountForNamespace = new Map();\n/** Generate a unique ID within a given namespace, using a simple counter-based implementation to avoid collisions. */\n\nexport function uniqueId(namespace) {\n  var _a;\n\n  var curCount = (_a = uniqueCountForNamespace.get(namespace)) !== null && _a !== void 0 ? _a : 0;\n  uniqueCountForNamespace.set(namespace, curCount + 1);\n  return \"\".concat(namespace, \"-\").concat(curCount);\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAASA,aAAT,QAA8B,WAA9B;AAKA;;AACA,OAAM,SAAUC,SAAV,CAAoBC,GAApB,EAA+B;AACjC,SAAO,OAAOC,OAAP,KAAmB,WAAnB,IAAkCA,OAAO,CAACD,GAA1C,IAAiDC,OAAO,CAACD,GAAR,CAAYE,QAAZ,KAAyBF,GAAjF;AACH;AAED;;;;;;;AAMA,OAAM,SAAUG,kBAAV,CAA6BC,CAA7B,EAA4CC,CAA5C,EAAyD;AAA5B;AAAAD;AAAa;;AAAE;AAAAC;AAAa;;AAC3D,SAAOD,CAAC,CAACE,MAAF,GAAWD,CAAC,CAACC,MAApB;AACH;AAED;;;;;;AAKA,OAAM,SAAUC,WAAV,CAAsBH,CAAtB,EAAiCC,CAAjC,EAA4CG,SAA5C,EAA+D;AAAnB;AAAAA;AAAmB;;AACjE,SAAOC,IAAI,CAACC,GAAL,CAASN,CAAC,GAAGC,CAAb,KAAmBG,SAA1B;AACH;AAED;;;;;AAIA,OAAM,SAAUG,KAAV,CAAgBC,GAAhB,EAA6BC,GAA7B,EAA0CC,GAA1C,EAAqD;AACvD,MAAIF,GAAG,IAAI,IAAX,EAAiB;AACb,WAAOA,GAAP;AACH;;AACD,MAAIE,GAAG,GAAGD,GAAV,EAAe;AACX,UAAM,IAAIE,KAAJ,CAAUjB,aAAV,CAAN;AACH;;AACD,SAAOW,IAAI,CAACI,GAAL,CAASJ,IAAI,CAACK,GAAL,CAASF,GAAT,EAAcC,GAAd,CAAT,EAA6BC,GAA7B,CAAP;AACH;AAED;;AACA,OAAM,SAAUE,kBAAV,CAA6BC,GAA7B,EAAwC;AAC1C,MAAI,CAACC,QAAQ,CAACD,GAAD,CAAb,EAAoB;AAChB,WAAO,CAAP;AACH;;AACD,MAAIE,CAAC,GAAG,CAAR;AACA,MAAIC,CAAC,GAAG,CAAR;;AACA,SAAOX,IAAI,CAACY,KAAL,CAAWJ,GAAG,GAAGE,CAAjB,IAAsBA,CAAtB,KAA4BF,GAAnC,EAAwC;AACpCE,KAAC,IAAI,EAAL;AACAC,KAAC;AACJ;;AACD,SAAOA,CAAP;AACH;AAED,IAAME,uBAAuB,GAAG,IAAIC,GAAJ,EAAhC;AACA;;AACA,OAAM,SAAUC,QAAV,CAAmBC,SAAnB,EAAoC;;;AACtC,MAAMC,QAAQ,GAAG,6BAAuB,CAACC,GAAxB,CAA4BF,SAA5B,OAAsC,IAAtC,IAAsCG,aAAtC,GAAsCA,EAAtC,GAA0C,CAA3D;AACAN,yBAAuB,CAACO,GAAxB,CAA4BJ,SAA5B,EAAuCC,QAAQ,GAAG,CAAlD;AACA,SAAO,UAAGD,SAAH,EAAY,GAAZ,EAAYK,MAAZ,CAAgBJ,QAAhB,CAAP;AACH","names":["CLAMP_MIN_MAX","isNodeEnv","env","process","NODE_ENV","arrayLengthCompare","a","b","length","approxEqual","tolerance","Math","abs","clamp","val","min","max","Error","countDecimalPlaces","num","isFinite","e","p","round","uniqueCountForNamespace","Map","uniqueId","namespace","curCount","get","_a","set","concat"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/core/src/common/utils/jsUtils.ts"],"sourcesContent":["/*\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CLAMP_MIN_MAX } from \"../errors\";\n\n// only accessible within this file, so use `Utils.isNodeEnv(env)` from the outside.\ndeclare let process: { env: any };\n\n/** Returns whether `process.env.NODE_ENV` exists and equals `env`. */\nexport function isNodeEnv(env: string) {\n    return typeof process !== \"undefined\" && process.env && process.env.NODE_ENV === env;\n}\n\n/**\n * Returns the difference in length between two arrays. A `null` argument is\n * considered an empty list. The return value will be positive if `a` is longer\n * than `b`, negative if the opposite is true, and zero if their lengths are\n * equal.\n */\nexport function arrayLengthCompare(a: any[] = [], b: any[] = []) {\n    return a.length - b.length;\n}\n\n/**\n * Returns true if the two numbers are within the given tolerance of each other.\n * This is useful to correct for floating point precision issues, less useful\n * for integers.\n */\nexport function approxEqual(a: number, b: number, tolerance = 0.00001) {\n    return Math.abs(a - b) <= tolerance;\n}\n\n/**\n * Clamps the given number between min and max values. Returns value if within\n * range, or closest bound.\n */\nexport function clamp(val: number, min: number, max: number) {\n    if (val == null) {\n        return val;\n    }\n    if (max < min) {\n        throw new Error(CLAMP_MIN_MAX);\n    }\n    return Math.min(Math.max(val, min), max);\n}\n\n/** Returns the number of decimal places in the given number. */\nexport function countDecimalPlaces(num: number) {\n    if (!isFinite(num)) {\n        return 0;\n    }\n    let e = 1;\n    let p = 0;\n    while (Math.round(num * e) / e !== num) {\n        e *= 10;\n        p++;\n    }\n    return p;\n}\n\nconst uniqueCountForNamespace = new Map<string, number>();\n/** Generate a unique ID within a given namespace, using a simple counter-based implementation to avoid collisions. */\nexport function uniqueId(namespace: string) {\n    const curCount = uniqueCountForNamespace.get(namespace) ?? 0;\n    uniqueCountForNamespace.set(namespace, curCount + 1);\n    return `${namespace}-${curCount}`;\n}\n"]},"metadata":{},"sourceType":"module"}