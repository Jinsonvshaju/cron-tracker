{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends, __rest } from \"tslib\";\nimport * as React from \"react\";\nimport { AbstractComponent2, DISPLAYNAME_PREFIX, Keys, Menu, Utils } from \"@blueprintjs/core\";\nimport { executeItemsEqual, getActiveItem, getCreateNewItem, isCreateNewItem, renderFilteredItems } from \"../../common\";\n\nvar QueryList =\n/** @class */\nfunction (_super) {\n  __extends(QueryList, _super);\n\n  function QueryList(props, context) {\n    var _this = this;\n\n    var _a, _b;\n\n    _this = _super.call(this, props, context) || this;\n    _this.refHandlers = {\n      itemsParent: function (ref) {\n        return _this.itemsParentRef = ref;\n      }\n    };\n    /**\n     * Flag indicating that we should check whether selected item is in viewport\n     * after rendering, typically because of keyboard change. Set to `true` when\n     * manipulating state in a way that may cause active item to scroll away.\n     */\n\n    _this.shouldCheckActiveItemInViewport = false;\n    /**\n     * The item that we expect to be the next selected active item (based on click\n     * or key interactions). When scrollToActiveItem = false, used to detect if\n     * an unexpected external change to the active item has been made.\n     */\n\n    _this.expectedNextActiveItem = null;\n    /**\n     * Flag which is set to true while in between an ENTER \"keydown\" event and its\n     * corresponding \"keyup\" event.\n     *\n     * When entering text via an IME (https://en.wikipedia.org/wiki/Input_method),\n     * the ENTER key is pressed to confirm the character(s) to be input from a list\n     * of options. The operating system intercepts the ENTER \"keydown\" event and\n     * prevents it from propagating to the application, but \"keyup\" is still\n     * fired, triggering a spurious event which this component does not expect.\n     *\n     * To work around this quirk, we keep track of \"real\" key presses by setting\n     * this flag in handleKeyDown.\n     */\n\n    _this.isEnterKeyPressed = false;\n    /** default `itemListRenderer` implementation */\n\n    _this.renderItemList = function (listProps) {\n      var _a = _this.props,\n          initialContent = _a.initialContent,\n          noResults = _a.noResults; // omit noResults if createNewItemFromQuery and createNewItemRenderer are both supplied, and query is not empty\n\n      var createItemView = listProps.renderCreateItem();\n      var maybeNoResults = createItemView != null ? null : noResults;\n      var menuContent = renderFilteredItems(listProps, maybeNoResults, initialContent);\n\n      if (menuContent == null && createItemView == null) {\n        return null;\n      }\n\n      var createFirst = _this.isCreateItemFirst();\n\n      return React.createElement(Menu, {\n        ulRef: listProps.itemsParentRef\n      }, createFirst && createItemView, menuContent, !createFirst && createItemView);\n    };\n    /** wrapper around `itemRenderer` to inject props */\n\n\n    _this.renderItem = function (item, index) {\n      if (_this.props.disabled !== true) {\n        var _a = _this.state,\n            activeItem = _a.activeItem,\n            query = _a.query;\n        var matchesPredicate = _this.state.filteredItems.indexOf(item) >= 0;\n        var modifiers = {\n          active: executeItemsEqual(_this.props.itemsEqual, getActiveItem(activeItem), item),\n          disabled: isItemDisabled(item, index, _this.props.itemDisabled),\n          matchesPredicate: matchesPredicate\n        };\n        return _this.props.itemRenderer(item, {\n          handleClick: function (e) {\n            return _this.handleItemSelect(item, e);\n          },\n          handleFocus: function () {\n            return _this.setActiveItem(item);\n          },\n          index: index,\n          modifiers: modifiers,\n          query: query\n        });\n      }\n\n      return null;\n    };\n\n    _this.renderCreateItemMenuItem = function () {\n      if (_this.isCreateItemRendered()) {\n        var _a = _this.state,\n            activeItem = _a.activeItem,\n            query = _a.query;\n        var trimmedQuery_1 = query.trim();\n\n        var handleClick = function (evt) {\n          _this.handleItemCreate(trimmedQuery_1, evt);\n        };\n\n        var isActive = isCreateNewItem(activeItem);\n        return _this.props.createNewItemRenderer(trimmedQuery_1, isActive, handleClick);\n      }\n\n      return null;\n    };\n\n    _this.handleItemCreate = function (query, evt) {\n      var _a, _b, _c, _d; // we keep a cached createNewItem in state, but might as well recompute\n      // the result just to be sure it's perfectly in sync with the query.\n\n\n      var item = (_b = (_a = _this.props).createNewItemFromQuery) === null || _b === void 0 ? void 0 : _b.call(_a, query);\n\n      if (item != null) {\n        (_d = (_c = _this.props).onItemSelect) === null || _d === void 0 ? void 0 : _d.call(_c, item, evt);\n\n        _this.maybeResetQuery();\n      }\n    };\n\n    _this.handleItemSelect = function (item, event) {\n      var _a, _b;\n\n      _this.setActiveItem(item);\n\n      (_b = (_a = _this.props).onItemSelect) === null || _b === void 0 ? void 0 : _b.call(_a, item, event);\n\n      _this.maybeResetQuery();\n    };\n\n    _this.handlePaste = function (queries) {\n      var _a = _this.props,\n          createNewItemFromQuery = _a.createNewItemFromQuery,\n          onItemsPaste = _a.onItemsPaste;\n      var nextActiveItem;\n      var nextQueries = []; // Find an exising itemÂ that exactly matches each pasted value, or\n      // create a new item if possible. Ignore unmatched values if creating\n      // items is disabled.\n\n      var pastedItemsToEmit = [];\n\n      for (var _i = 0, queries_1 = queries; _i < queries_1.length; _i++) {\n        var query = queries_1[_i];\n        var equalItem = getMatchingItem(query, _this.props);\n\n        if (equalItem !== undefined) {\n          nextActiveItem = equalItem;\n          pastedItemsToEmit.push(equalItem);\n        } else if (_this.canCreateItems()) {\n          var newItem = createNewItemFromQuery === null || createNewItemFromQuery === void 0 ? void 0 : createNewItemFromQuery(query);\n\n          if (newItem !== undefined) {\n            pastedItemsToEmit.push(newItem);\n          }\n        } else {\n          nextQueries.push(query);\n        }\n      } // UX nicety: combine all unmatched queries into a single\n      // comma-separated query in the input, so we don't lose any information.\n      // And don't reset the active item; we'll do that ourselves below.\n\n\n      _this.setQuery(nextQueries.join(\", \"), false); // UX nicety: update the active item if we matched with at least one\n      // existing item.\n\n\n      if (nextActiveItem !== undefined) {\n        _this.setActiveItem(nextActiveItem);\n      }\n\n      onItemsPaste === null || onItemsPaste === void 0 ? void 0 : onItemsPaste(pastedItemsToEmit);\n    };\n\n    _this.handleKeyDown = function (event) {\n      var _a, _b; // eslint-disable-next-line deprecation/deprecation\n\n\n      var keyCode = event.keyCode;\n\n      if (keyCode === Keys.ARROW_UP || keyCode === Keys.ARROW_DOWN) {\n        event.preventDefault();\n\n        var nextActiveItem = _this.getNextActiveItem(keyCode === Keys.ARROW_UP ? -1 : 1);\n\n        if (nextActiveItem != null) {\n          _this.setActiveItem(nextActiveItem);\n        }\n      } else if (keyCode === Keys.ENTER) {\n        _this.isEnterKeyPressed = true;\n      }\n\n      (_b = (_a = _this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n    };\n\n    _this.handleKeyUp = function (event) {\n      var onKeyUp = _this.props.onKeyUp;\n      var activeItem = _this.state.activeItem; // eslint-disable-next-line deprecation/deprecation\n\n      if (event.keyCode === Keys.ENTER && _this.isEnterKeyPressed) {\n        // We handle ENTER in keyup here to play nice with the Button component's keyboard\n        // clicking. Button is commonly used as the only child of Select. If we were to\n        // instead process ENTER on keydown, then Button would click itself on keyup and\n        // the Select popover would re-open.\n        event.preventDefault();\n\n        if (activeItem == null || isCreateNewItem(activeItem)) {\n          _this.handleItemCreate(_this.state.query, event);\n        } else {\n          _this.handleItemSelect(activeItem, event);\n        }\n\n        _this.isEnterKeyPressed = false;\n      }\n\n      onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(event);\n    };\n\n    _this.handleInputQueryChange = function (event) {\n      var _a, _b;\n\n      var query = event == null ? \"\" : event.target.value;\n\n      _this.setQuery(query);\n\n      (_b = (_a = _this.props).onQueryChange) === null || _b === void 0 ? void 0 : _b.call(_a, query, event);\n    };\n\n    var _c = props.query,\n        query = _c === void 0 ? \"\" : _c;\n    var createNewItem = (_a = props.createNewItemFromQuery) === null || _a === void 0 ? void 0 : _a.call(props, query);\n    var filteredItems = getFilteredItems(query, props);\n    _this.state = {\n      activeItem: props.activeItem !== undefined ? props.activeItem : (_b = props.initialActiveItem) !== null && _b !== void 0 ? _b : getFirstEnabledItem(filteredItems, props.itemDisabled),\n      createNewItem: createNewItem,\n      filteredItems: filteredItems,\n      query: query\n    };\n    return _this;\n  }\n\n  QueryList.ofType = function () {\n    return QueryList;\n  };\n\n  QueryList.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        items = _a.items,\n        renderer = _a.renderer,\n        _b = _a.itemListRenderer,\n        itemListRenderer = _b === void 0 ? this.renderItemList : _b;\n\n    var _c = this.state,\n        createNewItem = _c.createNewItem,\n        spreadableState = __rest(_c, [\"createNewItem\"]);\n\n    return renderer(__assign(__assign({}, spreadableState), {\n      className: className,\n      handleItemSelect: this.handleItemSelect,\n      handleKeyDown: this.handleKeyDown,\n      handleKeyUp: this.handleKeyUp,\n      handlePaste: this.handlePaste,\n      handleQueryChange: this.handleInputQueryChange,\n      itemList: itemListRenderer(__assign(__assign({}, spreadableState), {\n        items: items,\n        itemsParentRef: this.refHandlers.itemsParent,\n        renderCreateItem: this.renderCreateItemMenuItem,\n        renderItem: this.renderItem\n      }))\n    }));\n  };\n\n  QueryList.prototype.componentDidUpdate = function (prevProps) {\n    var _this = this;\n\n    if (this.props.activeItem !== undefined && this.props.activeItem !== this.state.activeItem) {\n      this.shouldCheckActiveItemInViewport = true;\n      this.setState({\n        activeItem: this.props.activeItem\n      });\n    }\n\n    if (this.props.query != null && this.props.query !== prevProps.query) {\n      // new query\n      this.setQuery(this.props.query, this.props.resetOnQuery, this.props);\n    } else if ( // same query (or uncontrolled query), but items in the list changed\n    !Utils.shallowCompareKeys(this.props, prevProps, {\n      include: [\"items\", \"itemListPredicate\", \"itemPredicate\"]\n    })) {\n      this.setQuery(this.state.query);\n    }\n\n    if (this.shouldCheckActiveItemInViewport) {\n      // update scroll position immediately before repaint so DOM is accurate\n      // (latest filteredItems) and to avoid flicker.\n      this.requestAnimationFrame(function () {\n        return _this.scrollActiveItemIntoView();\n      }); // reset the flag\n\n      this.shouldCheckActiveItemInViewport = false;\n    }\n  };\n\n  QueryList.prototype.scrollActiveItemIntoView = function () {\n    var scrollToActiveItem = this.props.scrollToActiveItem !== false;\n    var externalChangeToActiveItem = !executeItemsEqual(this.props.itemsEqual, getActiveItem(this.expectedNextActiveItem), getActiveItem(this.props.activeItem));\n    this.expectedNextActiveItem = null;\n\n    if (!scrollToActiveItem && externalChangeToActiveItem) {\n      return;\n    }\n\n    var activeElement = this.getActiveElement();\n\n    if (this.itemsParentRef != null && activeElement != null) {\n      var activeTop = activeElement.offsetTop,\n          activeHeight = activeElement.offsetHeight;\n      var _a = this.itemsParentRef,\n          parentOffsetTop = _a.offsetTop,\n          parentScrollTop = _a.scrollTop,\n          parentHeight = _a.clientHeight; // compute padding on parent element to ensure we always leave space\n\n      var _b = this.getItemsParentPadding(),\n          paddingTop = _b.paddingTop,\n          paddingBottom = _b.paddingBottom; // compute the two edges of the active item for comparison, including parent padding\n\n\n      var activeBottomEdge = activeTop + activeHeight + paddingBottom - parentOffsetTop;\n      var activeTopEdge = activeTop - paddingTop - parentOffsetTop;\n\n      if (activeBottomEdge >= parentScrollTop + parentHeight) {\n        // offscreen bottom: align bottom of item with bottom of viewport\n        this.itemsParentRef.scrollTop = activeBottomEdge + activeHeight - parentHeight;\n      } else if (activeTopEdge <= parentScrollTop) {\n        // offscreen top: align top of item with top of viewport\n        this.itemsParentRef.scrollTop = activeTopEdge - activeHeight;\n      }\n    }\n  };\n\n  QueryList.prototype.setQuery = function (query, resetActiveItem, props) {\n    var _a;\n\n    if (resetActiveItem === void 0) {\n      resetActiveItem = this.props.resetOnQuery;\n    }\n\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var createNewItemFromQuery = props.createNewItemFromQuery;\n    this.shouldCheckActiveItemInViewport = true;\n    var hasQueryChanged = query !== this.state.query;\n\n    if (hasQueryChanged) {\n      (_a = props.onQueryChange) === null || _a === void 0 ? void 0 : _a.call(props, query);\n    } // Leading and trailing whitespace can be confusing to display, so we remove it when passing it\n    // to functions dealing with data, like createNewItemFromQuery. But we need the unaltered user-typed\n    // query to remain in state to be able to render controlled text inputs properly.\n\n\n    var trimmedQuery = query.trim();\n    var filteredItems = getFilteredItems(trimmedQuery, props);\n    var createNewItem = createNewItemFromQuery != null && trimmedQuery !== \"\" ? createNewItemFromQuery(trimmedQuery) : undefined;\n    this.setState({\n      createNewItem: createNewItem,\n      filteredItems: filteredItems,\n      query: query\n    }); // always reset active item if it's now filtered or disabled\n\n    var activeIndex = this.getActiveIndex(filteredItems);\n    var shouldUpdateActiveItem = resetActiveItem || activeIndex < 0 || isItemDisabled(getActiveItem(this.state.activeItem), activeIndex, props.itemDisabled);\n\n    if (shouldUpdateActiveItem) {\n      // if the `createNewItem` is first, that should be the first active item.\n      if (this.isCreateItemRendered() && this.isCreateItemFirst()) {\n        this.setActiveItem(getCreateNewItem());\n      } else {\n        this.setActiveItem(getFirstEnabledItem(filteredItems, props.itemDisabled));\n      }\n    }\n  };\n\n  QueryList.prototype.setActiveItem = function (activeItem) {\n    var _a, _b, _c, _d;\n\n    this.expectedNextActiveItem = activeItem;\n\n    if (this.props.activeItem === undefined) {\n      // indicate that the active item may need to be scrolled into view after update.\n      this.shouldCheckActiveItemInViewport = true;\n      this.setState({\n        activeItem: activeItem\n      });\n    }\n\n    if (isCreateNewItem(activeItem)) {\n      (_b = (_a = this.props).onActiveItemChange) === null || _b === void 0 ? void 0 : _b.call(_a, null, true);\n    } else {\n      (_d = (_c = this.props).onActiveItemChange) === null || _d === void 0 ? void 0 : _d.call(_c, activeItem, false);\n    }\n  };\n\n  QueryList.prototype.getActiveElement = function () {\n    var activeItem = this.state.activeItem;\n\n    if (this.itemsParentRef != null) {\n      if (isCreateNewItem(activeItem)) {\n        var index = this.isCreateItemFirst() ? 0 : this.state.filteredItems.length;\n        return this.itemsParentRef.children.item(index);\n      } else {\n        var activeIndex = this.getActiveIndex();\n        return this.itemsParentRef.children.item(activeIndex);\n      }\n    }\n\n    return undefined;\n  };\n\n  QueryList.prototype.getActiveIndex = function (items) {\n    if (items === void 0) {\n      items = this.state.filteredItems;\n    }\n\n    var activeItem = this.state.activeItem;\n\n    if (activeItem == null || isCreateNewItem(activeItem)) {\n      return -1;\n    } // NOTE: this operation is O(n) so it should be avoided in render(). safe for events though.\n\n\n    for (var i = 0; i < items.length; ++i) {\n      if (executeItemsEqual(this.props.itemsEqual, items[i], activeItem)) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  QueryList.prototype.getItemsParentPadding = function () {\n    // assert ref exists because it was checked before calling\n    var _a = getComputedStyle(this.itemsParentRef),\n        paddingTop = _a.paddingTop,\n        paddingBottom = _a.paddingBottom;\n\n    return {\n      paddingBottom: pxToNumber(paddingBottom),\n      paddingTop: pxToNumber(paddingTop)\n    };\n  };\n  /**\n   * Get the next enabled item, moving in the given direction from the start\n   * index. A `null` return value means no suitable item was found.\n   *\n   * @param direction amount to move in each iteration, typically +/-1\n   * @param startIndex item to start iteration\n   */\n\n\n  QueryList.prototype.getNextActiveItem = function (direction, startIndex) {\n    if (startIndex === void 0) {\n      startIndex = this.getActiveIndex();\n    }\n\n    if (this.isCreateItemRendered()) {\n      var reachedCreate = startIndex === 0 && direction === -1 || startIndex === this.state.filteredItems.length - 1 && direction === 1;\n\n      if (reachedCreate) {\n        return getCreateNewItem();\n      }\n    }\n\n    return getFirstEnabledItem(this.state.filteredItems, this.props.itemDisabled, direction, startIndex);\n  };\n\n  QueryList.prototype.isCreateItemRendered = function () {\n    return this.canCreateItems() && this.state.query !== \"\" && // this check is unfortunately O(N) on the number of items, but\n    // alas, hiding the \"Create Item\" option when it exactly matches an\n    // existing item is much clearer.\n    !this.wouldCreatedItemMatchSomeExistingItem();\n  };\n\n  QueryList.prototype.isCreateItemFirst = function () {\n    return this.props.createNewItemPosition === \"first\";\n  };\n\n  QueryList.prototype.canCreateItems = function () {\n    return this.props.createNewItemFromQuery != null && this.props.createNewItemRenderer != null;\n  };\n\n  QueryList.prototype.wouldCreatedItemMatchSomeExistingItem = function () {\n    var _this = this; // search only the filtered items, not the full items list, because we\n    // only need to check items that match the current query.\n\n\n    return this.state.filteredItems.some(function (item) {\n      return executeItemsEqual(_this.props.itemsEqual, item, _this.state.createNewItem);\n    });\n  };\n\n  QueryList.prototype.maybeResetQuery = function () {\n    if (this.props.resetOnSelect) {\n      this.setQuery(\"\", true);\n    }\n  };\n\n  QueryList.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".QueryList\");\n  QueryList.defaultProps = {\n    disabled: false,\n    resetOnQuery: true\n  };\n  return QueryList;\n}(AbstractComponent2);\n\nexport { QueryList };\n\nfunction pxToNumber(value) {\n  return value == null ? 0 : parseInt(value.slice(0, -2), 10);\n}\n\nfunction getMatchingItem(query, _a) {\n  var items = _a.items,\n      itemPredicate = _a.itemPredicate;\n\n  if (Utils.isFunction(itemPredicate)) {\n    // .find() doesn't exist in ES5. Alternative: use a for loop instead of\n    // .filter() so that we can return as soon as we find the first match.\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (itemPredicate(query, item, i, true)) {\n        return item;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction getFilteredItems(query, _a) {\n  var items = _a.items,\n      itemPredicate = _a.itemPredicate,\n      itemListPredicate = _a.itemListPredicate;\n\n  if (Utils.isFunction(itemListPredicate)) {\n    // note that implementations can reorder the items here\n    return itemListPredicate(query, items);\n  } else if (Utils.isFunction(itemPredicate)) {\n    return items.filter(function (item, index) {\n      return itemPredicate(query, item, index);\n    });\n  }\n\n  return items;\n}\n/** Wrap number around min/max values: if it exceeds one bound, return the other. */\n\n\nfunction wrapNumber(value, min, max) {\n  if (value < min) {\n    return max;\n  } else if (value > max) {\n    return min;\n  }\n\n  return value;\n}\n\nfunction isItemDisabled(item, index, itemDisabled) {\n  if (itemDisabled == null || item == null) {\n    return false;\n  } else if (Utils.isFunction(itemDisabled)) {\n    return itemDisabled(item, index);\n  }\n\n  return !!item[itemDisabled];\n}\n/**\n * Get the next enabled item, moving in the given direction from the start\n * index. A `null` return value means no suitable item was found.\n *\n * @param items the list of items\n * @param itemDisabled callback to determine if a given item is disabled\n * @param direction amount to move in each iteration, typically +/-1\n * @param startIndex which index to begin moving from\n */\n\n\nexport function getFirstEnabledItem(items, itemDisabled, direction, startIndex) {\n  if (direction === void 0) {\n    direction = 1;\n  }\n\n  if (startIndex === void 0) {\n    startIndex = items.length - 1;\n  }\n\n  if (items.length === 0) {\n    return null;\n  } // remember where we started to prevent an infinite loop\n\n\n  var index = startIndex;\n  var maxIndex = items.length - 1;\n\n  do {\n    // find first non-disabled item\n    index = wrapNumber(index + direction, 0, maxIndex);\n\n    if (!isItemDisabled(items[index], index, itemDisabled)) {\n      return items[index];\n    }\n  } while (index !== startIndex && startIndex !== -1);\n\n  return null;\n}","map":{"version":3,"mappings":"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","names":["React","AbstractComponent2","DISPLAYNAME_PREFIX","Keys","Menu","Utils","executeItemsEqual","getActiveItem","getCreateNewItem","isCreateNewItem","renderFilteredItems","__extends","props","context","_super","_this","itemsParent","ref","itemsParentRef","listProps","initialContent","noResults","createItemView","renderCreateItem","maybeNoResults","menuContent","createFirst","isCreateItemFirst","ulRef","item","index","disabled","state","activeItem","query","matchesPredicate","filteredItems","indexOf","modifiers","active","itemsEqual","isItemDisabled","itemDisabled","itemRenderer","handleClick","handleItemSelect","e","handleFocus","setActiveItem","isCreateItemRendered","trimmedQuery_1","trim","handleItemCreate","evt","isActive","createNewItemRenderer","createNewItemFromQuery","_b","onItemSelect","_d","maybeResetQuery","event","queries","onItemsPaste","nextActiveItem","nextQueries","pastedItemsToEmit","_i","equalItem","getMatchingItem","undefined","push","canCreateItems","newItem","setQuery","join","keyCode","ARROW_UP","ARROW_DOWN","preventDefault","getNextActiveItem","ENTER","isEnterKeyPressed","onKeyDown","onKeyUp","target","value","onQueryChange","_c","createNewItem","_a","getFilteredItems","initialActiveItem","getFirstEnabledItem","QueryList","className","items","renderer","itemListRenderer","renderItemList","spreadableState","handleKeyDown","handleKeyUp","handlePaste","handleQueryChange","handleInputQueryChange","itemList","refHandlers","renderCreateItemMenuItem","renderItem","prevProps","shouldCheckActiveItemInViewport","setState","resetOnQuery","shallowCompareKeys","include","requestAnimationFrame","scrollActiveItemIntoView","scrollToActiveItem","externalChangeToActiveItem","expectedNextActiveItem","activeElement","getActiveElement","activeTop","activeHeight","parentOffsetTop","parentScrollTop","parentHeight","getItemsParentPadding","paddingTop","paddingBottom","activeBottomEdge","activeTopEdge","scrollTop","resetActiveItem","hasQueryChanged","trimmedQuery","activeIndex","getActiveIndex","shouldUpdateActiveItem","onActiveItemChange","length","children","i","getComputedStyle","pxToNumber","direction","startIndex","reachedCreate","wouldCreatedItemMatchSomeExistingItem","createNewItemPosition","some","resetOnSelect","parseInt","slice","itemPredicate","isFunction","itemListPredicate","filter","wrapNumber","min","max","maxIndex"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/select/src/components/query-list/queryList.tsx"],"sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as React from \"react\";\n\nimport { AbstractComponent2, DISPLAYNAME_PREFIX, Props, Keys, Menu, Utils } from \"@blueprintjs/core\";\n\nimport {\n    executeItemsEqual,\n    getActiveItem,\n    getCreateNewItem,\n    ICreateNewItem,\n    IItemListRendererProps,\n    IItemModifiers,\n    IListItemsProps,\n    isCreateNewItem,\n    renderFilteredItems,\n} from \"../../common\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type QueryListProps<T> = IQueryListProps<T>;\n/** @deprecated use QueryListProps */\nexport interface IQueryListProps<T> extends IListItemsProps<T> {\n    /**\n     * Initial active item, useful if the parent component is controlling its selectedItem but\n     * not activeItem.\n     */\n    initialActiveItem?: T;\n\n    /**\n     * Callback invoked when user presses a key, after processing `QueryList`'s own key events\n     * (up/down to navigate active item). This callback is passed to `renderer` and (along with\n     * `onKeyUp`) can be attached to arbitrary content elements to support keyboard selection.\n     */\n    onKeyDown?: React.KeyboardEventHandler<HTMLElement>;\n\n    /**\n     * Callback invoked when user releases a key, after processing `QueryList`'s own key events\n     * (enter to select active item). This callback is passed to `renderer` and (along with\n     * `onKeyDown`) can be attached to arbitrary content elements to support keyboard selection.\n     */\n    onKeyUp?: React.KeyboardEventHandler<HTMLElement>;\n\n    /**\n     * Customize rendering of the component.\n     * Receives an object with props that should be applied to elements as necessary.\n     */\n    renderer: (listProps: IQueryListRendererProps<T>) => JSX.Element;\n\n    /**\n     * Whether the list is disabled.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n}\n\n/**\n * An object describing how to render a `QueryList`.\n * A `QueryList` `renderer` receives this object as its sole argument.\n */\nexport interface IQueryListRendererProps<T> // Omit `createNewItem`, because it's used strictly for internal tracking.\n    extends Pick<IQueryListState<T>, \"activeItem\" | \"filteredItems\" | \"query\">,\n        Props {\n    /**\n     * Selection handler that should be invoked when a new item has been chosen,\n     * perhaps because the user clicked it.\n     */\n    handleItemSelect: (item: T, event?: React.SyntheticEvent<HTMLElement>) => void;\n\n    /**\n     * Handler that should be invoked when the user pastes one or more values.\n     *\n     * This callback will use `itemPredicate` with `exactMatch=true` to find a\n     * subset of `items` exactly matching the pasted `values` provided, then it\n     * will invoke `onItemsPaste` with those found items. Each pasted value that\n     * does not exactly match an item will be ignored.\n     *\n     * If creating items is enabled (by providing both `createNewItemFromQuery`\n     * and `createNewItemRenderer`), then pasted values that do not exactly\n     * match an existing item will emit a new item as created via\n     * `createNewItemFromQuery`.\n     *\n     * If `itemPredicate` returns multiple matching items for a particular query\n     * in `queries`, then only the first matching item will be emitted.\n     */\n    handlePaste: (queries: string[]) => void;\n\n    /**\n     * Keyboard handler for up/down arrow keys to shift the active item.\n     * Attach this handler to any element that should support this interaction.\n     */\n    handleKeyDown: React.KeyboardEventHandler<HTMLElement>;\n\n    /**\n     * Keyboard handler for enter key to select the active item.\n     * Attach this handler to any element that should support this interaction.\n     */\n    handleKeyUp: React.KeyboardEventHandler<HTMLElement>;\n\n    /**\n     * Change handler for query string. Attach this to an input element to allow\n     * `QueryList` to control the query.\n     */\n    handleQueryChange: React.ChangeEventHandler<HTMLInputElement>;\n\n    /** Rendered elements returned from `itemListRenderer` prop. */\n    itemList: React.ReactNode;\n}\n\nexport interface IQueryListState<T> {\n    /** The currently focused item (for keyboard interactions). */\n    activeItem: T | ICreateNewItem | null;\n\n    /**\n     * The item returned from `createNewItemFromQuery(this.state.query)`, cached\n     * to avoid continuous reinstantions within `isCreateItemRendered`, where\n     * this element will be used to hide the \"Create Item\" option if its value\n     * matches the current `query`.\n     */\n    createNewItem: T | undefined;\n\n    /** The original `items` array filtered by `itemListPredicate` or `itemPredicate`. */\n    filteredItems: T[];\n\n    /** The current query string. */\n    query: string;\n}\n\nexport class QueryList<T> extends AbstractComponent2<QueryListProps<T>, IQueryListState<T>> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.QueryList`;\n\n    public static defaultProps = {\n        disabled: false,\n        resetOnQuery: true,\n    };\n\n    public static ofType<U>() {\n        return QueryList as new (props: QueryListProps<U>) => QueryList<U>;\n    }\n\n    private itemsParentRef?: HTMLElement | null;\n\n    private refHandlers = {\n        itemsParent: (ref: HTMLElement | null) => (this.itemsParentRef = ref),\n    };\n\n    /**\n     * Flag indicating that we should check whether selected item is in viewport\n     * after rendering, typically because of keyboard change. Set to `true` when\n     * manipulating state in a way that may cause active item to scroll away.\n     */\n    private shouldCheckActiveItemInViewport = false;\n\n    /**\n     * The item that we expect to be the next selected active item (based on click\n     * or key interactions). When scrollToActiveItem = false, used to detect if\n     * an unexpected external change to the active item has been made.\n     */\n    private expectedNextActiveItem: T | ICreateNewItem | null = null;\n\n    /**\n     * Flag which is set to true while in between an ENTER \"keydown\" event and its\n     * corresponding \"keyup\" event.\n     *\n     * When entering text via an IME (https://en.wikipedia.org/wiki/Input_method),\n     * the ENTER key is pressed to confirm the character(s) to be input from a list\n     * of options. The operating system intercepts the ENTER \"keydown\" event and\n     * prevents it from propagating to the application, but \"keyup\" is still\n     * fired, triggering a spurious event which this component does not expect.\n     *\n     * To work around this quirk, we keep track of \"real\" key presses by setting\n     * this flag in handleKeyDown.\n     */\n    private isEnterKeyPressed = false;\n\n    public constructor(props: QueryListProps<T>, context?: any) {\n        super(props, context);\n\n        const { query = \"\" } = props;\n        const createNewItem = props.createNewItemFromQuery?.(query);\n        const filteredItems = getFilteredItems(query, props);\n\n        this.state = {\n            activeItem:\n                props.activeItem !== undefined\n                    ? props.activeItem\n                    : props.initialActiveItem ?? getFirstEnabledItem(filteredItems, props.itemDisabled),\n            createNewItem,\n            filteredItems,\n            query,\n        };\n    }\n\n    public render() {\n        const { className, items, renderer, itemListRenderer = this.renderItemList } = this.props;\n        const { createNewItem, ...spreadableState } = this.state;\n        return renderer({\n            ...spreadableState,\n            className,\n            handleItemSelect: this.handleItemSelect,\n            handleKeyDown: this.handleKeyDown,\n            handleKeyUp: this.handleKeyUp,\n            handlePaste: this.handlePaste,\n            handleQueryChange: this.handleInputQueryChange,\n            itemList: itemListRenderer({\n                ...spreadableState,\n                items,\n                itemsParentRef: this.refHandlers.itemsParent,\n                renderCreateItem: this.renderCreateItemMenuItem,\n                renderItem: this.renderItem,\n            }),\n        });\n    }\n\n    public componentDidUpdate(prevProps: QueryListProps<T>) {\n        if (this.props.activeItem !== undefined && this.props.activeItem !== this.state.activeItem) {\n            this.shouldCheckActiveItemInViewport = true;\n            this.setState({ activeItem: this.props.activeItem });\n        }\n\n        if (this.props.query != null && this.props.query !== prevProps.query) {\n            // new query\n            this.setQuery(this.props.query, this.props.resetOnQuery, this.props);\n        } else if (\n            // same query (or uncontrolled query), but items in the list changed\n            !Utils.shallowCompareKeys(this.props, prevProps, {\n                include: [\"items\", \"itemListPredicate\", \"itemPredicate\"],\n            })\n        ) {\n            this.setQuery(this.state.query);\n        }\n\n        if (this.shouldCheckActiveItemInViewport) {\n            // update scroll position immediately before repaint so DOM is accurate\n            // (latest filteredItems) and to avoid flicker.\n            this.requestAnimationFrame(() => this.scrollActiveItemIntoView());\n            // reset the flag\n            this.shouldCheckActiveItemInViewport = false;\n        }\n    }\n\n    public scrollActiveItemIntoView() {\n        const scrollToActiveItem = this.props.scrollToActiveItem !== false;\n        const externalChangeToActiveItem = !executeItemsEqual(\n            this.props.itemsEqual,\n            getActiveItem(this.expectedNextActiveItem),\n            getActiveItem(this.props.activeItem),\n        );\n        this.expectedNextActiveItem = null;\n\n        if (!scrollToActiveItem && externalChangeToActiveItem) {\n            return;\n        }\n\n        const activeElement = this.getActiveElement();\n        if (this.itemsParentRef != null && activeElement != null) {\n            const { offsetTop: activeTop, offsetHeight: activeHeight } = activeElement;\n            const {\n                offsetTop: parentOffsetTop,\n                scrollTop: parentScrollTop,\n                clientHeight: parentHeight,\n            } = this.itemsParentRef;\n            // compute padding on parent element to ensure we always leave space\n            const { paddingTop, paddingBottom } = this.getItemsParentPadding();\n\n            // compute the two edges of the active item for comparison, including parent padding\n            const activeBottomEdge = activeTop + activeHeight + paddingBottom - parentOffsetTop;\n            const activeTopEdge = activeTop - paddingTop - parentOffsetTop;\n\n            if (activeBottomEdge >= parentScrollTop + parentHeight) {\n                // offscreen bottom: align bottom of item with bottom of viewport\n                this.itemsParentRef.scrollTop = activeBottomEdge + activeHeight - parentHeight;\n            } else if (activeTopEdge <= parentScrollTop) {\n                // offscreen top: align top of item with top of viewport\n                this.itemsParentRef.scrollTop = activeTopEdge - activeHeight;\n            }\n        }\n    }\n\n    public setQuery(query: string, resetActiveItem = this.props.resetOnQuery, props = this.props) {\n        const { createNewItemFromQuery } = props;\n\n        this.shouldCheckActiveItemInViewport = true;\n        const hasQueryChanged = query !== this.state.query;\n        if (hasQueryChanged) {\n            props.onQueryChange?.(query);\n        }\n\n        // Leading and trailing whitespace can be confusing to display, so we remove it when passing it\n        // to functions dealing with data, like createNewItemFromQuery. But we need the unaltered user-typed\n        // query to remain in state to be able to render controlled text inputs properly.\n        const trimmedQuery = query.trim();\n        const filteredItems = getFilteredItems(trimmedQuery, props);\n        const createNewItem =\n            createNewItemFromQuery != null && trimmedQuery !== \"\" ? createNewItemFromQuery(trimmedQuery) : undefined;\n        this.setState({ createNewItem, filteredItems, query });\n\n        // always reset active item if it's now filtered or disabled\n        const activeIndex = this.getActiveIndex(filteredItems);\n        const shouldUpdateActiveItem =\n            resetActiveItem ||\n            activeIndex < 0 ||\n            isItemDisabled(getActiveItem(this.state.activeItem), activeIndex, props.itemDisabled);\n\n        if (shouldUpdateActiveItem) {\n            // if the `createNewItem` is first, that should be the first active item.\n            if (this.isCreateItemRendered() && this.isCreateItemFirst()) {\n                this.setActiveItem(getCreateNewItem());\n            } else {\n                this.setActiveItem(getFirstEnabledItem(filteredItems, props.itemDisabled));\n            }\n        }\n    }\n\n    public setActiveItem(activeItem: T | ICreateNewItem | null) {\n        this.expectedNextActiveItem = activeItem;\n        if (this.props.activeItem === undefined) {\n            // indicate that the active item may need to be scrolled into view after update.\n            this.shouldCheckActiveItemInViewport = true;\n            this.setState({ activeItem });\n        }\n\n        if (isCreateNewItem(activeItem)) {\n            this.props.onActiveItemChange?.(null, true);\n        } else {\n            this.props.onActiveItemChange?.(activeItem, false);\n        }\n    }\n\n    /** default `itemListRenderer` implementation */\n    private renderItemList = (listProps: IItemListRendererProps<T>) => {\n        const { initialContent, noResults } = this.props;\n\n        // omit noResults if createNewItemFromQuery and createNewItemRenderer are both supplied, and query is not empty\n        const createItemView = listProps.renderCreateItem();\n        const maybeNoResults = createItemView != null ? null : noResults;\n        const menuContent = renderFilteredItems(listProps, maybeNoResults, initialContent);\n        if (menuContent == null && createItemView == null) {\n            return null;\n        }\n        const createFirst = this.isCreateItemFirst();\n        return (\n            <Menu ulRef={listProps.itemsParentRef}>\n                {createFirst && createItemView}\n                {menuContent}\n                {!createFirst && createItemView}\n            </Menu>\n        );\n    };\n\n    /** wrapper around `itemRenderer` to inject props */\n    private renderItem = (item: T, index: number) => {\n        if (this.props.disabled !== true) {\n            const { activeItem, query } = this.state;\n            const matchesPredicate = this.state.filteredItems.indexOf(item) >= 0;\n            const modifiers: IItemModifiers = {\n                active: executeItemsEqual(this.props.itemsEqual, getActiveItem(activeItem), item),\n                disabled: isItemDisabled(item, index, this.props.itemDisabled),\n                matchesPredicate,\n            };\n            return this.props.itemRenderer(item, {\n                handleClick: e => this.handleItemSelect(item, e),\n                handleFocus: () => this.setActiveItem(item),\n                index,\n                modifiers,\n                query,\n            });\n        }\n\n        return null;\n    };\n\n    private renderCreateItemMenuItem = () => {\n        if (this.isCreateItemRendered()) {\n            const { activeItem, query } = this.state;\n            const trimmedQuery = query.trim();\n            const handleClick: React.MouseEventHandler<HTMLElement> = evt => {\n                this.handleItemCreate(trimmedQuery, evt);\n            };\n            const isActive = isCreateNewItem(activeItem);\n            return this.props.createNewItemRenderer!(trimmedQuery, isActive, handleClick);\n        }\n\n        return null;\n    };\n\n    private getActiveElement() {\n        const { activeItem } = this.state;\n        if (this.itemsParentRef != null) {\n            if (isCreateNewItem(activeItem)) {\n                const index = this.isCreateItemFirst() ? 0 : this.state.filteredItems.length;\n                return this.itemsParentRef.children.item(index) as HTMLElement;\n            } else {\n                const activeIndex = this.getActiveIndex();\n                return this.itemsParentRef.children.item(activeIndex) as HTMLElement;\n            }\n        }\n        return undefined;\n    }\n\n    private getActiveIndex(items = this.state.filteredItems) {\n        const { activeItem } = this.state;\n        if (activeItem == null || isCreateNewItem(activeItem)) {\n            return -1;\n        }\n        // NOTE: this operation is O(n) so it should be avoided in render(). safe for events though.\n        for (let i = 0; i < items.length; ++i) {\n            if (executeItemsEqual(this.props.itemsEqual, items[i], activeItem)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private getItemsParentPadding() {\n        // assert ref exists because it was checked before calling\n        const { paddingTop, paddingBottom } = getComputedStyle(this.itemsParentRef!);\n        return {\n            paddingBottom: pxToNumber(paddingBottom),\n            paddingTop: pxToNumber(paddingTop),\n        };\n    }\n\n    private handleItemCreate = (query: string, evt?: React.SyntheticEvent<HTMLElement>) => {\n        // we keep a cached createNewItem in state, but might as well recompute\n        // the result just to be sure it's perfectly in sync with the query.\n        const item = this.props.createNewItemFromQuery?.(query);\n        if (item != null) {\n            this.props.onItemSelect?.(item, evt);\n            this.maybeResetQuery();\n        }\n    };\n\n    private handleItemSelect = (item: T, event?: React.SyntheticEvent<HTMLElement>) => {\n        this.setActiveItem(item);\n        this.props.onItemSelect?.(item, event);\n        this.maybeResetQuery();\n    };\n\n    private handlePaste = (queries: string[]) => {\n        const { createNewItemFromQuery, onItemsPaste } = this.props;\n\n        let nextActiveItem: T | undefined;\n        const nextQueries = [];\n\n        // Find an exising itemÂ that exactly matches each pasted value, or\n        // create a new item if possible. Ignore unmatched values if creating\n        // items is disabled.\n        const pastedItemsToEmit = [];\n\n        for (const query of queries) {\n            const equalItem = getMatchingItem(query, this.props);\n\n            if (equalItem !== undefined) {\n                nextActiveItem = equalItem;\n                pastedItemsToEmit.push(equalItem);\n            } else if (this.canCreateItems()) {\n                const newItem = createNewItemFromQuery?.(query);\n                if (newItem !== undefined) {\n                    pastedItemsToEmit.push(newItem);\n                }\n            } else {\n                nextQueries.push(query);\n            }\n        }\n\n        // UX nicety: combine all unmatched queries into a single\n        // comma-separated query in the input, so we don't lose any information.\n        // And don't reset the active item; we'll do that ourselves below.\n        this.setQuery(nextQueries.join(\", \"), false);\n\n        // UX nicety: update the active item if we matched with at least one\n        // existing item.\n        if (nextActiveItem !== undefined) {\n            this.setActiveItem(nextActiveItem);\n        }\n\n        onItemsPaste?.(pastedItemsToEmit);\n    };\n\n    private handleKeyDown = (event: React.KeyboardEvent<HTMLElement>) => {\n        // eslint-disable-next-line deprecation/deprecation\n        const { keyCode } = event;\n        if (keyCode === Keys.ARROW_UP || keyCode === Keys.ARROW_DOWN) {\n            event.preventDefault();\n            const nextActiveItem = this.getNextActiveItem(keyCode === Keys.ARROW_UP ? -1 : 1);\n            if (nextActiveItem != null) {\n                this.setActiveItem(nextActiveItem);\n            }\n        } else if (keyCode === Keys.ENTER) {\n            this.isEnterKeyPressed = true;\n        }\n\n        this.props.onKeyDown?.(event);\n    };\n\n    private handleKeyUp = (event: React.KeyboardEvent<HTMLElement>) => {\n        const { onKeyUp } = this.props;\n        const { activeItem } = this.state;\n\n        // eslint-disable-next-line deprecation/deprecation\n        if (event.keyCode === Keys.ENTER && this.isEnterKeyPressed) {\n            // We handle ENTER in keyup here to play nice with the Button component's keyboard\n            // clicking. Button is commonly used as the only child of Select. If we were to\n            // instead process ENTER on keydown, then Button would click itself on keyup and\n            // the Select popover would re-open.\n            event.preventDefault();\n            if (activeItem == null || isCreateNewItem(activeItem)) {\n                this.handleItemCreate(this.state.query, event);\n            } else {\n                this.handleItemSelect(activeItem, event);\n            }\n            this.isEnterKeyPressed = false;\n        }\n\n        onKeyUp?.(event);\n    };\n\n    private handleInputQueryChange = (event?: React.ChangeEvent<HTMLInputElement>) => {\n        const query = event == null ? \"\" : event.target.value;\n        this.setQuery(query);\n        this.props.onQueryChange?.(query, event);\n    };\n\n    /**\n     * Get the next enabled item, moving in the given direction from the start\n     * index. A `null` return value means no suitable item was found.\n     *\n     * @param direction amount to move in each iteration, typically +/-1\n     * @param startIndex item to start iteration\n     */\n    private getNextActiveItem(direction: number, startIndex = this.getActiveIndex()): T | ICreateNewItem | null {\n        if (this.isCreateItemRendered()) {\n            const reachedCreate =\n                (startIndex === 0 && direction === -1) ||\n                (startIndex === this.state.filteredItems.length - 1 && direction === 1);\n            if (reachedCreate) {\n                return getCreateNewItem();\n            }\n        }\n        return getFirstEnabledItem(this.state.filteredItems, this.props.itemDisabled, direction, startIndex);\n    }\n\n    private isCreateItemRendered(): boolean {\n        return (\n            this.canCreateItems() &&\n            this.state.query !== \"\" &&\n            // this check is unfortunately O(N) on the number of items, but\n            // alas, hiding the \"Create Item\" option when it exactly matches an\n            // existing item is much clearer.\n            !this.wouldCreatedItemMatchSomeExistingItem()\n        );\n    }\n\n    private isCreateItemFirst(): boolean {\n        return this.props.createNewItemPosition === \"first\";\n    }\n\n    private canCreateItems(): boolean {\n        return this.props.createNewItemFromQuery != null && this.props.createNewItemRenderer != null;\n    }\n\n    private wouldCreatedItemMatchSomeExistingItem() {\n        // search only the filtered items, not the full items list, because we\n        // only need to check items that match the current query.\n        return this.state.filteredItems.some(item =>\n            executeItemsEqual(this.props.itemsEqual, item, this.state.createNewItem),\n        );\n    }\n\n    private maybeResetQuery() {\n        if (this.props.resetOnSelect) {\n            this.setQuery(\"\", true);\n        }\n    }\n}\n\nfunction pxToNumber(value: string | null) {\n    return value == null ? 0 : parseInt(value.slice(0, -2), 10);\n}\n\nfunction getMatchingItem<T>(query: string, { items, itemPredicate }: QueryListProps<T>): T | undefined {\n    if (Utils.isFunction(itemPredicate)) {\n        // .find() doesn't exist in ES5. Alternative: use a for loop instead of\n        // .filter() so that we can return as soon as we find the first match.\n        for (let i = 0; i < items.length; i++) {\n            const item = items[i];\n            if (itemPredicate(query, item, i, true)) {\n                return item;\n            }\n        }\n    }\n    return undefined;\n}\n\nfunction getFilteredItems<T>(query: string, { items, itemPredicate, itemListPredicate }: QueryListProps<T>) {\n    if (Utils.isFunction(itemListPredicate)) {\n        // note that implementations can reorder the items here\n        return itemListPredicate(query, items);\n    } else if (Utils.isFunction(itemPredicate)) {\n        return items.filter((item, index) => itemPredicate(query, item, index));\n    }\n    return items;\n}\n\n/** Wrap number around min/max values: if it exceeds one bound, return the other. */\nfunction wrapNumber(value: number, min: number, max: number) {\n    if (value < min) {\n        return max;\n    } else if (value > max) {\n        return min;\n    }\n    return value;\n}\n\nfunction isItemDisabled<T>(item: T | null, index: number, itemDisabled?: IListItemsProps<T>[\"itemDisabled\"]) {\n    if (itemDisabled == null || item == null) {\n        return false;\n    } else if (Utils.isFunction(itemDisabled)) {\n        return itemDisabled(item, index);\n    }\n    return !!item[itemDisabled];\n}\n\n/**\n * Get the next enabled item, moving in the given direction from the start\n * index. A `null` return value means no suitable item was found.\n *\n * @param items the list of items\n * @param itemDisabled callback to determine if a given item is disabled\n * @param direction amount to move in each iteration, typically +/-1\n * @param startIndex which index to begin moving from\n */\nexport function getFirstEnabledItem<T>(\n    items: T[],\n    itemDisabled?: keyof T | ((item: T, index: number) => boolean),\n    direction = 1,\n    startIndex = items.length - 1,\n): T | ICreateNewItem | null {\n    if (items.length === 0) {\n        return null;\n    }\n    // remember where we started to prevent an infinite loop\n    let index = startIndex;\n    const maxIndex = items.length - 1;\n    do {\n        // find first non-disabled item\n        index = wrapNumber(index + direction, 0, maxIndex);\n        if (!isItemDisabled(items[index], index, itemDisabled)) {\n            return items[index];\n        }\n    } while (index !== startIndex && startIndex !== -1);\n    return null;\n}\n"]},"metadata":{},"sourceType":"module"}