{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent2, Classes, refHandler, setRef } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Overlay } from \"../overlay/overlay\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\"; // eslint-disable-next-line import/no-cycle\n\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverMigrationUtils\";\nimport { arrowOffsetModifier, getTransformOrigin } from \"./popperUtils\";\nexport var PopoverInteractionKind = {\n  CLICK: \"click\",\n  CLICK_TARGET_ONLY: \"click-target\",\n  HOVER: \"hover\",\n  HOVER_TARGET_ONLY: \"hover-target\"\n};\n/** @deprecated use { Popover2 } from \"@blueprintjs/popover2\" */\n\nvar Popover =\n/** @class */\nfunction (_super) {\n  __extends(Popover, _super);\n\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this; // eslint-disable-next-line deprecation/deprecation\n\n\n    _this.popoverRef = React.createRef();\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     */\n\n    _this.popoverElement = null;\n    /** DOM element that contains the target. */\n\n    _this.targetElement = null;\n    _this.state = {\n      hasDarkParent: false,\n      isOpen: _this.getIsOpen(_this.props),\n      transformOrigin: \"\"\n    }; // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n\n    _this.isMouseInTargetOrPopover = false; // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n\n    _this.lostFocusOnSamePage = true;\n    _this.handlePopoverRef = refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n\n    _this.handleTargetRef = function (ref) {\n      return _this.targetElement = ref;\n    };\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n\n\n    _this.reposition = function () {\n      var _a;\n\n      return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this);\n    };\n\n    _this.renderPopover = function (popperProps) {\n      var _a;\n\n      var _b = _this.props,\n          interactionKind = _b.interactionKind,\n          usePortal = _b.usePortal;\n      var transformOrigin = _this.state.transformOrigin; // Need to update our reference to this on every render as it will change.\n\n      _this.popperScheduleUpdate = popperProps.scheduleUpdate;\n      var popoverHandlers = {\n        // always check popover clicks for dismiss class\n        onClick: _this.handlePopoverClick\n      };\n\n      if (interactionKind === PopoverInteractionKind.HOVER || !usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY) {\n        popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n        popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n      }\n\n      var popoverClasses = classNames(Classes.POPOVER, (_a = {}, _a[Classes.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent, _a[Classes.MINIMAL] = _this.props.minimal, _a[Classes.POPOVER_CAPTURING_DISMISS] = _this.props.captureDismiss, _a[Classes.POPOVER_OUT_OF_BOUNDARIES] = popperProps.outOfBoundaries === true, _a), _this.props.popoverClassName);\n      return React.createElement(\"div\", {\n        className: Classes.TRANSITION_CONTAINER,\n        ref: popperProps.ref,\n        style: popperProps.style\n      }, React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, React.createElement(\"div\", __assign({\n        className: popoverClasses,\n        style: {\n          transformOrigin: transformOrigin\n        },\n        ref: _this.popoverRef\n      }, popoverHandlers), _this.isArrowEnabled() && React.createElement(PopoverArrow, {\n        arrowProps: popperProps.arrowProps,\n        placement: popperProps.placement\n      }), React.createElement(\"div\", {\n        className: Classes.POPOVER_CONTENT\n      }, _this.understandChildren().content))));\n    };\n\n    _this.renderTarget = function (referenceProps) {\n      var _a, _b;\n\n      var _c = _this.props,\n          fill = _c.fill,\n          openOnTargetFocus = _c.openOnTargetFocus,\n          targetClassName = _c.targetClassName,\n          _d = _c.targetProps,\n          targetProps = _d === void 0 ? {} : _d;\n      var isOpen = _this.state.isOpen;\n\n      var isControlled = _this.isControlled();\n\n      var isHoverInteractionKind = _this.isHoverInteractionKind();\n\n      var targetTagName = _this.props.targetTagName;\n\n      if (fill) {\n        targetTagName = \"div\";\n      }\n\n      var finalTargetProps = isHoverInteractionKind ? {\n        // HOVER handlers\n        onBlur: _this.handleTargetBlur,\n        onFocus: _this.handleTargetFocus,\n        onMouseEnter: _this.handleMouseEnter,\n        onMouseLeave: _this.handleMouseLeave\n      } : {\n        // CLICK needs only one handler\n        onClick: _this.handleTargetClick\n      };\n      finalTargetProps[\"aria-haspopup\"] = \"true\";\n      finalTargetProps.className = classNames(Classes.POPOVER_TARGET, (_a = {}, _a[Classes.POPOVER_OPEN] = isOpen, _a), targetProps.className, targetClassName);\n      finalTargetProps.ref = referenceProps.ref;\n      var rawTarget = Utils.ensureElement(_this.understandChildren().target);\n\n      if (rawTarget === undefined) {\n        return null;\n      }\n\n      var rawTabIndex = rawTarget.props.tabIndex; // ensure target is focusable if relevant prop enabled\n\n      var tabIndex = rawTabIndex == null && openOnTargetFocus && isHoverInteractionKind ? 0 : rawTabIndex;\n      var clonedTarget = React.cloneElement(rawTarget, {\n        className: classNames(rawTarget.props.className, (_b = {}, // this class is mainly useful for button targets; we should only apply it for uncontrolled popovers\n        // when they are opened by a user interaction\n        _b[Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind, _b)),\n        // force disable single Tooltip child when popover is open (BLUEPRINT-552)\n\n        /* eslint-disable-next-line deprecation/deprecation */\n        disabled: isOpen && Utils.isElementOfType(rawTarget, Tooltip) ? true : rawTarget.props.disabled,\n        tabIndex: tabIndex\n      });\n      var target = React.createElement(targetTagName, __assign(__assign({}, targetProps), finalTargetProps), clonedTarget);\n      return React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, target);\n    };\n\n    _this.isControlled = function () {\n      return _this.props.isOpen !== undefined;\n    };\n\n    _this.handleTargetFocus = function (e) {\n      var _a, _b;\n\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n          // ignore this focus event -- the target was already focused but the page itself\n          // lost focus (e.g. due to switching tabs).\n          return;\n        }\n\n        _this.handleMouseEnter(e);\n      }\n\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleTargetBlur = function (e) {\n      var _a, _b;\n\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        // if the next element to receive focus is within the popover, we'll want to leave the\n        // popover open. e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n        // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n        // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n        // close the popover if necessary.\n        if (e.relatedTarget != null && !_this.isElementInPopover(e.relatedTarget)) {\n          _this.handleMouseLeave(e);\n        }\n      }\n\n      _this.lostFocusOnSamePage = e.relatedTarget != null;\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleMouseEnter = function (e) {\n      var _a, _b;\n\n      _this.isMouseInTargetOrPopover = true; // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n      // trigger the mouse leave event, as hovering over the popover shouldn't count.\n\n      if (!_this.props.usePortal && _this.isElementInPopover(e.target) && _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY && !_this.props.openOnTargetFocus) {\n        _this.handleMouseLeave(e);\n      } else if (!_this.props.disabled) {\n        // only begin opening popover when it is enabled\n        _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n      }\n\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseEnter) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleMouseLeave = function (e) {\n      var _a, _b;\n\n      _this.isMouseInTargetOrPopover = false; // wait until the event queue is flushed, because we want to leave the\n      // popover open if the mouse entered the popover immediately after\n      // leaving the target (or vice versa).\n\n      _this.setTimeout(function () {\n        if (_this.isMouseInTargetOrPopover) {\n          return;\n        } // user-configurable closing delay is helpful when moving mouse from target to popover\n\n\n        _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n      });\n\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handlePopoverClick = function (e) {\n      var eventTarget = e.target;\n      var eventPopover = eventTarget.closest(\".\".concat(Classes.POPOVER));\n      var isEventFromSelf = eventPopover === _this.popoverRef.current;\n      var isEventPopoverCapturing = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER_CAPTURING_DISMISS); // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n\n      var dismissElement = eventTarget.closest(\".\".concat(Classes.POPOVER_DISMISS, \", .\").concat(Classes.POPOVER_DISMISS_OVERRIDE));\n      var shouldDismiss = dismissElement != null && dismissElement.classList.contains(Classes.POPOVER_DISMISS);\n      var isDisabled = eventTarget.closest(\":disabled, .\".concat(Classes.DISABLED)) != null;\n\n      if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleOverlayClose = function (e) {\n      if (_this.targetElement === null || e === undefined) {\n        return;\n      }\n\n      var eventTarget = e.target; // if click was in target, target event listener will handle things, so don't close\n\n      if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleTargetClick = function (e) {\n      var _a, _b; // ensure click did not originate from within inline popover before closing\n\n\n      if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n        if (_this.props.isOpen == null) {\n          _this.setState(function (prevState) {\n            return {\n              isOpen: !prevState.isOpen\n            };\n          });\n        } else {\n          _this.setOpenState(!_this.props.isOpen, e);\n        }\n      }\n\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    /** Popper modifier that updates React state (for style properties) based on latest data. */\n\n\n    _this.updatePopoverState = function (data) {\n      // always set string; let shouldComponentUpdate determine if update is necessary\n      _this.setState({\n        transformOrigin: getTransformOrigin(data)\n      });\n\n      return data;\n    };\n\n    return _this;\n  }\n\n  Popover.prototype.render = function () {\n    var _a;\n\n    var _b; // rename wrapper tag to begin with uppercase letter so it's recognized\n    // as JSX component instead of intrinsic element. but because of its\n    // type, tsc actually recognizes that it is _any_ intrinsic element, so\n    // it can typecheck the HTML props!!\n\n\n    var _c = this.props,\n        className = _c.className,\n        disabled = _c.disabled,\n        fill = _c.fill,\n        placement = _c.placement,\n        _d = _c.position,\n        position = _d === void 0 ? \"auto\" : _d,\n        shouldReturnFocusOnClose = _c.shouldReturnFocusOnClose;\n    var isOpen = this.state.isOpen;\n    var wrapperTagName = this.props.wrapperTagName;\n\n    if (fill) {\n      wrapperTagName = \"div\";\n    }\n\n    var isContentEmpty = Utils.ensureElement(this.understandChildren().content) == null; // need to do this check in render(), because `isOpen` is derived from\n    // state, and state can't necessarily be accessed in validateProps.\n\n    if (isContentEmpty && !disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n      console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n    }\n\n    var wrapperClasses = classNames(Classes.POPOVER_WRAPPER, className, (_a = {}, _a[Classes.FILL] = fill, _a));\n    var defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;\n    var wrapper = React.createElement(wrapperTagName, {\n      className: wrapperClasses\n    }, React.createElement(Reference, {\n      innerRef: this.handleTargetRef\n    }, this.renderTarget), React.createElement(Overlay, {\n      autoFocus: (_b = this.props.autoFocus) !== null && _b !== void 0 ? _b : defaultAutoFocus,\n      backdropClassName: Classes.POPOVER_BACKDROP,\n      backdropProps: this.props.backdropProps,\n      canEscapeKeyClose: this.props.canEscapeKeyClose,\n      canOutsideClickClose: this.props.interactionKind === PopoverInteractionKind.CLICK,\n      className: this.props.portalClassName,\n      enforceFocus: this.props.enforceFocus,\n      hasBackdrop: this.props.hasBackdrop,\n      isOpen: isOpen && !isContentEmpty,\n      onClose: this.handleOverlayClose,\n      onClosed: this.props.onClosed,\n      onClosing: this.props.onClosing,\n      onOpened: this.props.onOpened,\n      onOpening: this.props.onOpening,\n      transitionDuration: this.props.transitionDuration,\n      transitionName: Classes.POPOVER,\n      usePortal: this.props.usePortal,\n      portalContainer: this.props.portalContainer,\n      // if hover interaciton, it doesn't make sense to take over focus control\n      shouldReturnFocusOnClose: this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose\n    }, React.createElement(Popper, {\n      innerRef: this.handlePopoverRef,\n      placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(position),\n      modifiers: this.getPopperModifiers()\n    }, this.renderPopover)));\n    return React.createElement(Manager, null, wrapper);\n  };\n\n  Popover.prototype.componentDidMount = function () {\n    this.updateDarkParent();\n  };\n\n  Popover.prototype.componentDidUpdate = function (prevProps, prevState) {\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n\n    if (prevProps.popoverRef !== this.props.popoverRef) {\n      setRef(prevProps.popoverRef, null);\n      this.handlePopoverRef = refHandler(this, \"popoverElement\", this.props.popoverRef);\n      setRef(this.props.popoverRef, this.popoverElement);\n    }\n\n    this.updateDarkParent();\n    var nextIsOpen = this.getIsOpen(this.props);\n\n    if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n      this.setOpenState(nextIsOpen); // tricky: setOpenState calls setState only if this.props.isOpen is\n      // not controlled, so we need to invoke setState manually here.\n\n      this.setState({\n        isOpen: nextIsOpen\n      });\n    } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n      // special case: close an uncontrolled popover when disabled is set to true\n      this.setOpenState(false);\n    }\n  };\n\n  Popover.prototype.validateProps = function (props) {\n    if (props.isOpen == null && props.onInteraction != null) {\n      console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n    }\n\n    if (props.hasBackdrop && !props.usePortal) {\n      console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n    }\n\n    if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n      console.error(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n    }\n\n    if (props.placement !== undefined && props.position !== undefined) {\n      console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n    }\n\n    var childrenCount = React.Children.count(props.children);\n    var hasContentProp = props.content !== undefined;\n    var hasTargetProp = props.target !== undefined;\n\n    if (childrenCount === 0 && !hasTargetProp) {\n      console.error(Errors.POPOVER_REQUIRES_TARGET);\n    }\n\n    if (childrenCount > 2) {\n      console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n    }\n\n    if (childrenCount > 0 && hasTargetProp) {\n      console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n    }\n\n    if (childrenCount === 2 && hasContentProp) {\n      console.warn(Errors.POPOVER_WARN_DOUBLE_CONTENT);\n    }\n  };\n\n  Popover.prototype.updateDarkParent = function () {\n    if (this.props.usePortal && this.state.isOpen) {\n      var hasDarkParent = this.targetElement != null && this.targetElement.closest(\".\".concat(Classes.DARK)) != null;\n      this.setState({\n        hasDarkParent: hasDarkParent\n      });\n    }\n  }; // content and target can be specified as props or as children. this method\n  // normalizes the two approaches, preferring child over prop.\n\n\n  Popover.prototype.understandChildren = function () {\n    var _a = this.props,\n        children = _a.children,\n        contentProp = _a.content,\n        targetProp = _a.target; // #validateProps asserts that 1 <= children.length <= 2 so content is optional\n\n    var _b = React.Children.toArray(children),\n        targetChild = _b[0],\n        contentChild = _b[1];\n\n    return {\n      content: contentChild == null ? contentProp : contentChild,\n      target: targetChild == null ? targetProp : targetChild\n    };\n  };\n\n  Popover.prototype.getIsOpen = function (props) {\n    // disabled popovers should never be allowed to open.\n    if (props.disabled) {\n      return false;\n    } else if (props.isOpen != null) {\n      return props.isOpen;\n    } else {\n      return props.defaultIsOpen;\n    }\n  };\n\n  Popover.prototype.getPopperModifiers = function () {\n    var _a = this.props,\n        boundary = _a.boundary,\n        modifiers = _a.modifiers;\n    var _b = modifiers,\n        _c = _b.flip,\n        flip = _c === void 0 ? {} : _c,\n        _d = _b.preventOverflow,\n        preventOverflow = _d === void 0 ? {} : _d;\n    return __assign(__assign({}, modifiers), {\n      arrowOffset: {\n        enabled: this.isArrowEnabled(),\n        fn: arrowOffsetModifier,\n        order: 510\n      },\n      flip: __assign({\n        boundariesElement: boundary\n      }, flip),\n      preventOverflow: __assign({\n        boundariesElement: boundary\n      }, preventOverflow),\n      updatePopoverState: {\n        enabled: true,\n        fn: this.updatePopoverState,\n        order: 900\n      }\n    });\n  }; // a wrapper around setState({isOpen}) that will call props.onInteraction instead when in controlled mode.\n  // starts a timeout to delay changing the state if a non-zero duration is provided.\n\n\n  Popover.prototype.setOpenState = function (isOpen, e, timeout) {\n    var _this = this;\n\n    var _a, _b, _c, _d, _e; // cancel any existing timeout because we have new state\n\n\n    (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (timeout !== undefined && timeout > 0) {\n      this.cancelOpenTimeout = this.setTimeout(function () {\n        return _this.setOpenState(isOpen, e);\n      }, timeout);\n    } else {\n      if (this.props.isOpen == null) {\n        this.setState({\n          isOpen: isOpen\n        });\n      } else {\n        (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n      }\n\n      if (!isOpen) {\n        // non-null assertion because the only time `e` is undefined is when in controlled mode\n        // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n        (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n      }\n    }\n  };\n\n  Popover.prototype.isArrowEnabled = function () {\n    var _a = this.props,\n        minimal = _a.minimal,\n        modifiers = _a.modifiers; // omitting `arrow` from `modifiers` uses Popper default, which does show an arrow.\n\n    return !minimal && ((modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow) == null || modifiers.arrow.enabled);\n  };\n\n  Popover.prototype.isElementInPopover = function (element) {\n    var _a;\n\n    return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.contains(element);\n  };\n\n  Popover.prototype.isHoverInteractionKind = function () {\n    return this.props.interactionKind === PopoverInteractionKind.HOVER || this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY;\n  };\n\n  Popover.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Popover\");\n  Popover.defaultProps = {\n    boundary: \"scrollParent\",\n    captureDismiss: false,\n    defaultIsOpen: false,\n    disabled: false,\n    fill: false,\n    hasBackdrop: false,\n    hoverCloseDelay: 300,\n    hoverOpenDelay: 150,\n    inheritDarkTheme: true,\n    interactionKind: PopoverInteractionKind.CLICK,\n    minimal: false,\n    modifiers: {},\n    openOnTargetFocus: true,\n    shouldReturnFocusOnClose: false,\n    // N.B. we don't set a default for `placement` or `position` here because that would trigger\n    // a warning in validateProps if the other prop is specified by a user of this component\n    targetTagName: \"span\",\n    transitionDuration: 300,\n    usePortal: true,\n    wrapperTagName: \"span\"\n  };\n  return Popover;\n}(AbstractPureComponent2);\n\nexport { Popover };","map":{"version":3,"mappings":"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","names":["classNames","React","Manager","Popper","Reference","AbstractPureComponent2","Classes","refHandler","setRef","Errors","DISPLAYNAME_PREFIX","Utils","Overlay","ResizeSensor","Tooltip","PopoverArrow","positionToPlacement","arrowOffsetModifier","getTransformOrigin","PopoverInteractionKind","CLICK","CLICK_TARGET_ONLY","HOVER","HOVER_TARGET_ONLY","__extends","_this","createRef","hasDarkParent","isOpen","getIsOpen","props","transformOrigin","popoverRef","ref","targetElement","popperScheduleUpdate","_a","popperProps","interactionKind","usePortal","state","scheduleUpdate","popoverHandlers","onClick","handlePopoverClick","onMouseEnter","handleMouseEnter","onMouseLeave","handleMouseLeave","popoverClasses","POPOVER","DARK","inheritDarkTheme","MINIMAL","minimal","POPOVER_CAPTURING_DISMISS","captureDismiss","POPOVER_OUT_OF_BOUNDARIES","outOfBoundaries","popoverClassName","className","TRANSITION_CONTAINER","style","onResize","reposition","isArrowEnabled","arrowProps","placement","POPOVER_CONTENT","understandChildren","content","referenceProps","fill","openOnTargetFocus","targetClassName","_d","targetProps","isControlled","isHoverInteractionKind","targetTagName","finalTargetProps","onBlur","handleTargetBlur","onFocus","handleTargetFocus","handleTargetClick","POPOVER_TARGET","POPOVER_OPEN","rawTarget","ensureElement","target","undefined","rawTabIndex","tabIndex","clonedTarget","cloneElement","_b","ACTIVE","disabled","isElementOfType","createElement","__assign","e","relatedTarget","lostFocusOnSamePage","isElementInPopover","isMouseInTargetOrPopover","setOpenState","hoverOpenDelay","setTimeout","hoverCloseDelay","eventTarget","eventPopover","closest","isEventFromSelf","current","isEventPopoverCapturing","classList","contains","dismissElement","POPOVER_DISMISS","concat","POPOVER_DISMISS_OVERRIDE","shouldDismiss","isDisabled","DISABLED","elementIsOrContains","nativeEvent","KeyboardEvent","setState","prevState","data","Popover","position","shouldReturnFocusOnClose","wrapperTagName","isContentEmpty","isNodeEnv","console","warn","POPOVER_WARN_EMPTY_CONTENT","wrapperClasses","POPOVER_WRAPPER","FILL","defaultAutoFocus","wrapper","innerRef","handleTargetRef","renderTarget","autoFocus","backdropClassName","POPOVER_BACKDROP","backdropProps","canEscapeKeyClose","canOutsideClickClose","portalClassName","enforceFocus","hasBackdrop","onClose","handleOverlayClose","onClosed","onClosing","onOpened","onOpening","transitionDuration","transitionName","portalContainer","handlePopoverRef","modifiers","getPopperModifiers","renderPopover","updateDarkParent","prevProps","_super","componentDidUpdate","call","popoverElement","nextIsOpen","onInteraction","POPOVER_WARN_UNCONTROLLED_ONINTERACTION","POPOVER_WARN_HAS_BACKDROP_INLINE","error","POPOVER_HAS_BACKDROP_INTERACTION","POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX","childrenCount","Children","count","children","hasContentProp","hasTargetProp","POPOVER_REQUIRES_TARGET","POPOVER_WARN_TOO_MANY_CHILDREN","POPOVER_WARN_DOUBLE_TARGET","POPOVER_WARN_DOUBLE_CONTENT","contentProp","targetProp","toArray","targetChild","contentChild","defaultIsOpen","boundary","_c","flip","preventOverflow","arrowOffset","enabled","fn","order","boundariesElement","updatePopoverState","timeout","cancelOpenTimeout","_e","arrow","element"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/core/src/components/popover/popover.tsx"],"sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport { ModifierFn } from \"popper.js\";\nimport * as React from \"react\";\nimport { Manager, Popper, PopperChildrenProps, Reference, ReferenceChildrenProps } from \"react-popper\";\n\nimport { AbstractPureComponent2, Classes, IRef, refHandler, setRef } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, HTMLDivProps } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Overlay } from \"../overlay/overlay\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverMigrationUtils\";\nimport { IPopoverSharedProps, PopperModifiers } from \"./popoverSharedProps\";\nimport { arrowOffsetModifier, getTransformOrigin } from \"./popperUtils\";\n\nexport const PopoverInteractionKind = {\n    CLICK: \"click\" as \"click\",\n    CLICK_TARGET_ONLY: \"click-target\" as \"click-target\",\n    HOVER: \"hover\" as \"hover\",\n    HOVER_TARGET_ONLY: \"hover-target\" as \"hover-target\",\n};\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type PopoverInteractionKind = typeof PopoverInteractionKind[keyof typeof PopoverInteractionKind];\n\nexport interface IPopoverProps extends IPopoverSharedProps {\n    /** HTML props for the backdrop element. Can be combined with `backdropClassName`. */\n    backdropProps?: React.HTMLProps<HTMLDivElement>;\n\n    /**\n     * The content displayed inside the popover. This can instead be provided as\n     * the _second_ element in `children` (first is `target`).\n     */\n    content?: string | JSX.Element;\n\n    /**\n     * Whether the wrapper and target should take up the full width of their container.\n     * Note that supplying `true` for this prop will force  `targetTagName=\"div\"` and\n     * `wrapperTagName=\"div\"`.\n     */\n    fill?: boolean;\n\n    /**\n     * The kind of interaction that triggers the display of the popover.\n     *\n     * @default PopoverInteractionKind.CLICK\n     */\n    interactionKind?: PopoverInteractionKind;\n\n    /**\n     * Enables an invisible overlay beneath the popover that captures clicks and\n     * prevents interaction with the rest of the document until the popover is\n     * closed. This prop is only available when `interactionKind` is\n     * `PopoverInteractionKind.CLICK`. When popovers with backdrop are opened,\n     * they become focused.\n     *\n     * @default false\n     */\n    hasBackdrop?: boolean;\n\n    /**\n     * Whether the application should return focus to the last active element in the\n     * document after this popover closes.\n     *\n     * This is automatically set to `false` if this is a hover interaction popover.\n     *\n     * If you are attaching a popover _and_ a tooltip to the same target, you must take\n     * care to either disable this prop for the popover _or_ disable the tooltip's\n     * `openOnTargetFocus` prop.\n     *\n     * @default false\n     */\n    shouldReturnFocusOnClose?: boolean;\n\n    /**\n     * Ref supplied to the `Classes.POPOVER` element.\n     */\n    popoverRef?: IRef<HTMLElement>;\n\n    /**\n     * The target to which the popover content is attached. This can instead be\n     * provided as the _first_ element in `children`.\n     */\n    target?: string | JSX.Element;\n}\n\nexport interface IPopoverState {\n    transformOrigin: string;\n    isOpen: boolean;\n    hasDarkParent: boolean;\n}\n\n/** @deprecated use { Popover2 } from \"@blueprintjs/popover2\" */\n\nexport class Popover extends AbstractPureComponent2<IPopoverProps, IPopoverState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Popover`;\n\n    // eslint-disable-next-line deprecation/deprecation\n    private popoverRef = React.createRef<HTMLDivElement>();\n\n    public static defaultProps: IPopoverProps = {\n        boundary: \"scrollParent\",\n        captureDismiss: false,\n        defaultIsOpen: false,\n        disabled: false,\n        fill: false,\n        hasBackdrop: false,\n        hoverCloseDelay: 300,\n        hoverOpenDelay: 150,\n        inheritDarkTheme: true,\n        interactionKind: PopoverInteractionKind.CLICK,\n        minimal: false,\n        modifiers: {},\n        openOnTargetFocus: true,\n        shouldReturnFocusOnClose: false,\n        // N.B. we don't set a default for `placement` or `position` here because that would trigger\n        // a warning in validateProps if the other prop is specified by a user of this component\n        targetTagName: \"span\",\n        transitionDuration: 300,\n        usePortal: true,\n        wrapperTagName: \"span\",\n    };\n\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     */\n    public popoverElement: HTMLElement | null = null;\n\n    /** DOM element that contains the target. */\n    public targetElement: HTMLElement | null = null;\n\n    public state: IPopoverState = {\n        hasDarkParent: false,\n        isOpen: this.getIsOpen(this.props),\n        transformOrigin: \"\",\n    };\n\n    private cancelOpenTimeout?: () => void;\n\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    private isMouseInTargetOrPopover = false;\n\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    private lostFocusOnSamePage = true;\n\n    // Reference to the Poppper.scheduleUpdate() function, this changes every time the popper is mounted\n    private popperScheduleUpdate?: () => void;\n\n    private handlePopoverRef: IRef<HTMLElement> = refHandler(this, \"popoverElement\", this.props.popoverRef);\n\n    private handleTargetRef = (ref: HTMLElement | null) => (this.targetElement = ref);\n\n    public render() {\n        // rename wrapper tag to begin with uppercase letter so it's recognized\n        // as JSX component instead of intrinsic element. but because of its\n        // type, tsc actually recognizes that it is _any_ intrinsic element, so\n        // it can typecheck the HTML props!!\n        const { className, disabled, fill, placement, position = \"auto\", shouldReturnFocusOnClose } = this.props;\n        const { isOpen } = this.state;\n        let { wrapperTagName } = this.props;\n        if (fill) {\n            wrapperTagName = \"div\";\n        }\n\n        const isContentEmpty = Utils.ensureElement(this.understandChildren().content) == null;\n        // need to do this check in render(), because `isOpen` is derived from\n        // state, and state can't necessarily be accessed in validateProps.\n        if (isContentEmpty && !disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n            console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n        }\n\n        const wrapperClasses = classNames(Classes.POPOVER_WRAPPER, className, {\n            [Classes.FILL]: fill,\n        });\n\n        const defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;\n\n        const wrapper = React.createElement(\n            wrapperTagName!,\n            { className: wrapperClasses },\n            <Reference innerRef={this.handleTargetRef}>{this.renderTarget}</Reference>,\n            <Overlay\n                autoFocus={this.props.autoFocus ?? defaultAutoFocus}\n                backdropClassName={Classes.POPOVER_BACKDROP}\n                backdropProps={this.props.backdropProps}\n                canEscapeKeyClose={this.props.canEscapeKeyClose}\n                canOutsideClickClose={this.props.interactionKind === PopoverInteractionKind.CLICK}\n                className={this.props.portalClassName}\n                enforceFocus={this.props.enforceFocus}\n                hasBackdrop={this.props.hasBackdrop}\n                isOpen={isOpen && !isContentEmpty}\n                onClose={this.handleOverlayClose}\n                onClosed={this.props.onClosed}\n                onClosing={this.props.onClosing}\n                onOpened={this.props.onOpened}\n                onOpening={this.props.onOpening}\n                transitionDuration={this.props.transitionDuration}\n                transitionName={Classes.POPOVER}\n                usePortal={this.props.usePortal}\n                portalContainer={this.props.portalContainer}\n                // if hover interaciton, it doesn't make sense to take over focus control\n                shouldReturnFocusOnClose={this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose}\n            >\n                <Popper\n                    innerRef={this.handlePopoverRef}\n                    placement={placement ?? positionToPlacement(position)}\n                    modifiers={this.getPopperModifiers()}\n                >\n                    {this.renderPopover}\n                </Popper>\n            </Overlay>,\n        );\n\n        return <Manager>{wrapper}</Manager>;\n    }\n\n    public componentDidMount() {\n        this.updateDarkParent();\n    }\n\n    public componentDidUpdate(prevProps: IPopoverProps, prevState: IPopoverState) {\n        super.componentDidUpdate(prevProps, prevState);\n\n        if (prevProps.popoverRef !== this.props.popoverRef) {\n            setRef(prevProps.popoverRef, null);\n            this.handlePopoverRef = refHandler(this, \"popoverElement\", this.props.popoverRef);\n            setRef(this.props.popoverRef, this.popoverElement);\n        }\n\n        this.updateDarkParent();\n\n        const nextIsOpen = this.getIsOpen(this.props);\n\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n            this.setOpenState(nextIsOpen);\n            // tricky: setOpenState calls setState only if this.props.isOpen is\n            // not controlled, so we need to invoke setState manually here.\n            this.setState({ isOpen: nextIsOpen });\n        } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n            // special case: close an uncontrolled popover when disabled is set to true\n            this.setOpenState(false);\n        }\n    }\n\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    public reposition = () => this.popperScheduleUpdate?.();\n\n    protected validateProps(props: IPopoverProps & { children?: React.ReactNode }) {\n        if (props.isOpen == null && props.onInteraction != null) {\n            console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n        }\n        if (props.hasBackdrop && !props.usePortal) {\n            console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n        }\n        if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n            console.error(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n        }\n        if (props.placement !== undefined && props.position !== undefined) {\n            console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n        }\n\n        const childrenCount = React.Children.count(props.children);\n        const hasContentProp = props.content !== undefined;\n        const hasTargetProp = props.target !== undefined;\n\n        if (childrenCount === 0 && !hasTargetProp) {\n            console.error(Errors.POPOVER_REQUIRES_TARGET);\n        }\n        if (childrenCount > 2) {\n            console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n        }\n        if (childrenCount > 0 && hasTargetProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n        }\n        if (childrenCount === 2 && hasContentProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_CONTENT);\n        }\n    }\n\n    private updateDarkParent() {\n        if (this.props.usePortal && this.state.isOpen) {\n            const hasDarkParent = this.targetElement != null && this.targetElement.closest(`.${Classes.DARK}`) != null;\n            this.setState({ hasDarkParent });\n        }\n    }\n\n    private renderPopover = (popperProps: PopperChildrenProps) => {\n        const { interactionKind, usePortal } = this.props;\n        const { transformOrigin } = this.state;\n\n        // Need to update our reference to this on every render as it will change.\n        this.popperScheduleUpdate = popperProps.scheduleUpdate;\n\n        const popoverHandlers: HTMLDivProps = {\n            // always check popover clicks for dismiss class\n            onClick: this.handlePopoverClick,\n        };\n        if (\n            interactionKind === PopoverInteractionKind.HOVER ||\n            (!usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY)\n        ) {\n            popoverHandlers.onMouseEnter = this.handleMouseEnter;\n            popoverHandlers.onMouseLeave = this.handleMouseLeave;\n        }\n\n        const popoverClasses = classNames(\n            Classes.POPOVER,\n            {\n                [Classes.DARK]: this.props.inheritDarkTheme && this.state.hasDarkParent,\n                [Classes.MINIMAL]: this.props.minimal,\n                [Classes.POPOVER_CAPTURING_DISMISS]: this.props.captureDismiss,\n                [Classes.POPOVER_OUT_OF_BOUNDARIES]: popperProps.outOfBoundaries === true,\n            },\n            this.props.popoverClassName,\n        );\n\n        return (\n            <div className={Classes.TRANSITION_CONTAINER} ref={popperProps.ref} style={popperProps.style}>\n                <ResizeSensor onResize={this.reposition}>\n                    <div\n                        className={popoverClasses}\n                        style={{ transformOrigin }}\n                        ref={this.popoverRef}\n                        {...popoverHandlers}\n                    >\n                        {this.isArrowEnabled() && (\n                            <PopoverArrow arrowProps={popperProps.arrowProps} placement={popperProps.placement} />\n                        )}\n                        <div className={Classes.POPOVER_CONTENT}>{this.understandChildren().content}</div>\n                    </div>\n                </ResizeSensor>\n            </div>\n        );\n    };\n\n    private renderTarget = (referenceProps: ReferenceChildrenProps) => {\n        const { fill, openOnTargetFocus, targetClassName, targetProps = {} } = this.props;\n        const { isOpen } = this.state;\n        const isControlled = this.isControlled();\n        const isHoverInteractionKind = this.isHoverInteractionKind();\n        let { targetTagName } = this.props;\n        if (fill) {\n            targetTagName = \"div\";\n        }\n\n        const finalTargetProps: React.HTMLProps<HTMLElement> = isHoverInteractionKind\n            ? {\n                  // HOVER handlers\n                  onBlur: this.handleTargetBlur,\n                  onFocus: this.handleTargetFocus,\n                  onMouseEnter: this.handleMouseEnter,\n                  onMouseLeave: this.handleMouseLeave,\n              }\n            : {\n                  // CLICK needs only one handler\n                  onClick: this.handleTargetClick,\n              };\n        finalTargetProps[\"aria-haspopup\"] = \"true\";\n        finalTargetProps.className = classNames(\n            Classes.POPOVER_TARGET,\n            { [Classes.POPOVER_OPEN]: isOpen },\n            targetProps.className,\n            targetClassName,\n        );\n        finalTargetProps.ref = referenceProps.ref;\n\n        const rawTarget = Utils.ensureElement(this.understandChildren().target);\n\n        if (rawTarget === undefined) {\n            return null;\n        }\n\n        const rawTabIndex = rawTarget.props.tabIndex;\n        // ensure target is focusable if relevant prop enabled\n        const tabIndex = rawTabIndex == null && openOnTargetFocus && isHoverInteractionKind ? 0 : rawTabIndex;\n        const clonedTarget: JSX.Element = React.cloneElement(rawTarget, {\n            className: classNames(rawTarget.props.className, {\n                // this class is mainly useful for button targets; we should only apply it for uncontrolled popovers\n                // when they are opened by a user interaction\n                [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n            }),\n            // force disable single Tooltip child when popover is open (BLUEPRINT-552)\n            /* eslint-disable-next-line deprecation/deprecation */\n            disabled: isOpen && Utils.isElementOfType(rawTarget, Tooltip) ? true : rawTarget.props.disabled,\n            tabIndex,\n        });\n        const target = React.createElement(\n            targetTagName!,\n            {\n                ...targetProps,\n                ...finalTargetProps,\n            },\n            clonedTarget,\n        );\n\n        return <ResizeSensor onResize={this.reposition}>{target}</ResizeSensor>;\n    };\n\n    // content and target can be specified as props or as children. this method\n    // normalizes the two approaches, preferring child over prop.\n    private understandChildren() {\n        const { children, content: contentProp, target: targetProp } = this.props;\n        // #validateProps asserts that 1 <= children.length <= 2 so content is optional\n        const [targetChild, contentChild] = React.Children.toArray(children);\n        return {\n            content: contentChild == null ? contentProp : contentChild,\n            target: targetChild == null ? targetProp : targetChild,\n        };\n    }\n\n    private isControlled = () => this.props.isOpen !== undefined;\n\n    private getIsOpen(props: IPopoverProps) {\n        // disabled popovers should never be allowed to open.\n        if (props.disabled) {\n            return false;\n        } else if (props.isOpen != null) {\n            return props.isOpen;\n        } else {\n            return props.defaultIsOpen!;\n        }\n    }\n\n    private getPopperModifiers(): PopperModifiers {\n        const { boundary, modifiers } = this.props;\n        const { flip = {}, preventOverflow = {} } = modifiers!;\n        return {\n            ...modifiers,\n            arrowOffset: {\n                enabled: this.isArrowEnabled(),\n                fn: arrowOffsetModifier,\n                order: 510,\n            },\n            flip: { boundariesElement: boundary, ...flip },\n            preventOverflow: { boundariesElement: boundary, ...preventOverflow },\n            updatePopoverState: {\n                enabled: true,\n                fn: this.updatePopoverState,\n                order: 900,\n            },\n        };\n    }\n\n    private handleTargetFocus = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget == null && !this.lostFocusOnSamePage) {\n                // ignore this focus event -- the target was already focused but the page itself\n                // lost focus (e.g. due to switching tabs).\n                return;\n            }\n            this.handleMouseEnter((e as unknown) as React.MouseEvent<HTMLElement>);\n        }\n        this.props.targetProps?.onFocus?.(e);\n    };\n\n    private handleTargetBlur = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            // if the next element to receive focus is within the popover, we'll want to leave the\n            // popover open. e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n            // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n            // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n            // close the popover if necessary.\n            if (e.relatedTarget != null && !this.isElementInPopover(e.relatedTarget as HTMLElement)) {\n                this.handleMouseLeave((e as unknown) as React.MouseEvent<HTMLElement>);\n            }\n        }\n        this.lostFocusOnSamePage = e.relatedTarget != null;\n        this.props.targetProps?.onBlur?.(e);\n    };\n\n    private handleMouseEnter = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = true;\n\n        // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n        // trigger the mouse leave event, as hovering over the popover shouldn't count.\n        if (\n            !this.props.usePortal &&\n            this.isElementInPopover(e.target as Element) &&\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY &&\n            !this.props.openOnTargetFocus\n        ) {\n            this.handleMouseLeave(e);\n        } else if (!this.props.disabled) {\n            // only begin opening popover when it is enabled\n            this.setOpenState(true, e, this.props.hoverOpenDelay);\n        }\n        this.props.targetProps?.onMouseEnter?.(e);\n    };\n\n    private handleMouseLeave = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = false;\n\n        // wait until the event queue is flushed, because we want to leave the\n        // popover open if the mouse entered the popover immediately after\n        // leaving the target (or vice versa).\n        this.setTimeout(() => {\n            if (this.isMouseInTargetOrPopover) {\n                return;\n            }\n            // user-configurable closing delay is helpful when moving mouse from target to popover\n            this.setOpenState(false, e, this.props.hoverCloseDelay);\n        });\n        this.props.targetProps?.onMouseLeave?.(e);\n    };\n\n    private handlePopoverClick = (e: React.MouseEvent<HTMLElement>) => {\n        const eventTarget = e.target as HTMLElement;\n        const eventPopover = eventTarget.closest(`.${Classes.POPOVER}`);\n        const isEventFromSelf = eventPopover === this.popoverRef.current;\n        const isEventPopoverCapturing = eventPopover?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS);\n        // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n        const dismissElement = eventTarget.closest(`.${Classes.POPOVER_DISMISS}, .${Classes.POPOVER_DISMISS_OVERRIDE}`);\n        const shouldDismiss = dismissElement != null && dismissElement.classList.contains(Classes.POPOVER_DISMISS);\n        const isDisabled = eventTarget.closest(`:disabled, .${Classes.DISABLED}`) != null;\n        if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleOverlayClose = (e?: React.SyntheticEvent<HTMLElement>) => {\n        if (this.targetElement === null || e === undefined) {\n            return;\n        }\n\n        const eventTarget = e.target as HTMLElement;\n        // if click was in target, target event listener will handle things, so don't close\n        if (!Utils.elementIsOrContains(this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleTargetClick = (e: React.MouseEvent<HTMLElement>) => {\n        // ensure click did not originate from within inline popover before closing\n        if (!this.props.disabled && !this.isElementInPopover(e.target as HTMLElement)) {\n            if (this.props.isOpen == null) {\n                this.setState(prevState => ({ isOpen: !prevState.isOpen }));\n            } else {\n                this.setOpenState(!this.props.isOpen, e);\n            }\n        }\n        this.props.targetProps?.onClick?.(e);\n    };\n\n    // a wrapper around setState({isOpen}) that will call props.onInteraction instead when in controlled mode.\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\n    private setOpenState(isOpen: boolean, e?: React.SyntheticEvent<HTMLElement>, timeout?: number) {\n        // cancel any existing timeout because we have new state\n        this.cancelOpenTimeout?.();\n        if (timeout !== undefined && timeout > 0) {\n            this.cancelOpenTimeout = this.setTimeout(() => this.setOpenState(isOpen, e), timeout);\n        } else {\n            if (this.props.isOpen == null) {\n                this.setState({ isOpen });\n            } else {\n                this.props.onInteraction?.(isOpen, e);\n            }\n            if (!isOpen) {\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n                this.props.onClose?.(e!);\n            }\n        }\n    }\n\n    private isArrowEnabled() {\n        const { minimal, modifiers } = this.props;\n        // omitting `arrow` from `modifiers` uses Popper default, which does show an arrow.\n        return !minimal && (modifiers?.arrow == null || modifiers.arrow.enabled);\n    }\n\n    private isElementInPopover(element: Element) {\n        return this.popoverElement?.contains(element);\n    }\n\n    private isHoverInteractionKind() {\n        return (\n            this.props.interactionKind === PopoverInteractionKind.HOVER ||\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY\n        );\n    }\n\n    /** Popper modifier that updates React state (for style properties) based on latest data. */\n    private updatePopoverState: ModifierFn = data => {\n        // always set string; let shouldComponentUpdate determine if update is necessary\n        this.setState({ transformOrigin: getTransformOrigin(data) });\n        return data;\n    };\n}\n"]},"metadata":{},"sourceType":"module"}