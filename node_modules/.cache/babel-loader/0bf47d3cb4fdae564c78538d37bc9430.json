{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __extends, __spreadArray } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Boundary } from \"../../common/boundary\";\nimport * as Classes from \"../../common/classes\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n/** @internal - do not expose this type */\n\nexport var OverflowDirection;\n\n(function (OverflowDirection) {\n  OverflowDirection[OverflowDirection[\"NONE\"] = 0] = \"NONE\";\n  OverflowDirection[OverflowDirection[\"GROW\"] = 1] = \"GROW\";\n  OverflowDirection[OverflowDirection[\"SHRINK\"] = 2] = \"SHRINK\";\n})(OverflowDirection || (OverflowDirection = {}));\n\nvar OverflowList =\n/** @class */\nfunction (_super) {\n  __extends(OverflowList, _super);\n\n  function OverflowList() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      direction: OverflowDirection.NONE,\n      lastOverflowCount: 0,\n      overflow: [],\n      visible: _this.props.items\n    };\n    /** A cache containing the widths of all elements being observed to detect growing/shrinking */\n\n    _this.previousWidths = new Map();\n    _this.spacer = null;\n\n    _this.resize = function (entries) {\n      // if any parent is growing, assume we have more room than before\n      var growing = entries.some(function (entry) {\n        var previousWidth = _this.previousWidths.get(entry.target) || 0;\n        return entry.contentRect.width > previousWidth;\n      });\n\n      _this.repartition(growing);\n\n      entries.forEach(function (entry) {\n        return _this.previousWidths.set(entry.target, entry.contentRect.width);\n      });\n    };\n\n    return _this;\n  }\n\n  OverflowList.ofType = function () {\n    return OverflowList;\n  };\n\n  OverflowList.prototype.componentDidMount = function () {\n    this.repartition(false);\n  };\n\n  OverflowList.prototype.shouldComponentUpdate = function (_nextProps, nextState) {\n    // We want this component to always re-render, even when props haven't changed, so that\n    // changes in the renderers' behavior can be reflected.\n    // The following statement prevents re-rendering only in the case where the state changes\n    // identity (i.e. setState was called), but the state is still the same when\n    // shallow-compared to the previous state.\n    return !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n  };\n\n  OverflowList.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b;\n\n    if (prevProps.observeParents !== this.props.observeParents) {\n      console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n    }\n\n    if (prevProps.collapseFrom !== this.props.collapseFrom || prevProps.items !== this.props.items || prevProps.minVisibleItems !== this.props.minVisibleItems || prevProps.overflowRenderer !== this.props.overflowRenderer || prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow || prevProps.visibleItemRenderer !== this.props.visibleItemRenderer) {\n      // reset visible state if the above props change.\n      this.setState({\n        direction: OverflowDirection.GROW,\n        lastOverflowCount: 0,\n        overflow: [],\n        visible: this.props.items\n      });\n    }\n\n    if (!shallowCompareKeys(prevState, this.state)) {\n      this.repartition(false);\n    }\n\n    var _c = this.state,\n        direction = _c.direction,\n        overflow = _c.overflow,\n        lastOverflowCount = _c.lastOverflowCount;\n\n    if ( // if a resize operation has just completed (transition to NONE)\n    direction === OverflowDirection.NONE && direction !== prevState.direction && overflow.length !== lastOverflowCount) {\n      (_b = (_a = this.props).onOverflow) === null || _b === void 0 ? void 0 : _b.call(_a, overflow.slice());\n    }\n  };\n\n  OverflowList.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        className = _a.className,\n        collapseFrom = _a.collapseFrom,\n        observeParents = _a.observeParents,\n        style = _a.style,\n        _b = _a.tagName,\n        tagName = _b === void 0 ? \"div\" : _b,\n        visibleItemRenderer = _a.visibleItemRenderer;\n    var overflow = this.maybeRenderOverflow();\n    var list = React.createElement(tagName, {\n      className: classNames(Classes.OVERFLOW_LIST, className),\n      style: style\n    }, collapseFrom === Boundary.START ? overflow : null, this.state.visible.map(visibleItemRenderer), collapseFrom === Boundary.END ? overflow : null, React.createElement(\"div\", {\n      className: Classes.OVERFLOW_LIST_SPACER,\n      ref: function (ref) {\n        return _this.spacer = ref;\n      }\n    }));\n    return React.createElement(ResizeSensor, {\n      onResize: this.resize,\n      observeParents: observeParents\n    }, list);\n  };\n\n  OverflowList.prototype.maybeRenderOverflow = function () {\n    var overflow = this.state.overflow;\n\n    if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {\n      return null;\n    }\n\n    return this.props.overflowRenderer(overflow.slice());\n  };\n\n  OverflowList.prototype.repartition = function (growing) {\n    var _this = this;\n\n    if (this.spacer == null) {\n      return;\n    }\n\n    if (growing) {\n      this.setState(function (state) {\n        return {\n          direction: OverflowDirection.GROW,\n          // store last overflow if this is the beginning of a resize (for check in componentDidUpdate).\n          lastOverflowCount: state.direction === OverflowDirection.NONE ? state.overflow.length : state.lastOverflowCount,\n          overflow: [],\n          visible: _this.props.items\n        };\n      });\n    } else if (this.spacer.offsetWidth < 0.9) {\n      // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n      this.setState(function (state) {\n        if (state.visible.length <= _this.props.minVisibleItems) {\n          return null;\n        }\n\n        var collapseFromStart = _this.props.collapseFrom === Boundary.START;\n        var visible = state.visible.slice();\n        var next = collapseFromStart ? visible.shift() : visible.pop();\n\n        if (next === undefined) {\n          return null;\n        }\n\n        var overflow = collapseFromStart ? __spreadArray(__spreadArray([], state.overflow, true), [next], false) : __spreadArray([next], state.overflow, true);\n        return {\n          // set SHRINK mode unless a GROW is already in progress.\n          // GROW shows all items then shrinks until it settles, so we\n          // preserve the fact that the original trigger was a GROW.\n          direction: state.direction === OverflowDirection.NONE ? OverflowDirection.SHRINK : state.direction,\n          overflow: overflow,\n          visible: visible\n        };\n      });\n    } else {\n      // repartition complete!\n      this.setState({\n        direction: OverflowDirection.NONE\n      });\n    }\n  };\n\n  OverflowList.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".OverflowList\");\n  OverflowList.defaultProps = {\n    alwaysRenderOverflow: false,\n    collapseFrom: Boundary.START,\n    minVisibleItems: 0\n  };\n  return OverflowList;\n}(React.Component);\n\nexport { OverflowList };","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,OAAOA,UAAP,MAAuB,YAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AAEA,SAASC,QAAT,QAAyB,uBAAzB;AACA,OAAO,KAAKC,OAAZ,MAAyB,sBAAzB;AACA,SAASC,qCAAT,QAAsD,qBAAtD;AACA,SAASC,kBAAT,QAA0C,oBAA1C;AACA,SAASC,kBAAT,QAAmC,oBAAnC;AACA,SAASC,YAAT,QAA6B,+BAA7B;AAEA;;AACA,WAAYC,iBAAZ;;AAAA,WAAYA,iBAAZ,EAA6B;AACzBA;AACAA;AACAA;AACH,CAJD,EAAYA,iBAAiB,KAAjBA,iBAAiB,MAA7B;;AAsGA;AAAA;AAAA;AAAqCC;;AAArC;AAAA;;AAaWC,kBAA+B;AAClCC,eAAS,EAAEH,iBAAiB,CAACI,IADK;AAElCC,uBAAiB,EAAE,CAFe;AAGlCC,cAAQ,EAAE,EAHwB;AAIlCC,aAAO,EAAEL,KAAI,CAACM,KAAL,CAAWC;AAJc,KAA/B;AAOP;;AACQP,2BAAiB,IAAIQ,GAAJ,EAAjB;AAEAR,mBAA6B,IAA7B;;AAiFAA,mBAAS,UAACS,OAAD,EAAwC;AACrD;AACA,UAAMC,OAAO,GAAGD,OAAO,CAACE,IAAR,CAAa,iBAAK;AAC9B,YAAMC,aAAa,GAAGZ,KAAI,CAACa,cAAL,CAAoBC,GAApB,CAAwBC,KAAK,CAACC,MAA9B,KAAyC,CAA/D;AACA,eAAOD,KAAK,CAACE,WAAN,CAAkBC,KAAlB,GAA0BN,aAAjC;AACH,OAHe,CAAhB;;AAIAZ,WAAI,CAACmB,WAAL,CAAiBT,OAAjB;;AACAD,aAAO,CAACW,OAAR,CAAgB,iBAAK;AAAI,oBAAI,CAACP,cAAL,CAAoBQ,GAApB,CAAwBN,KAAK,CAACC,MAA9B,EAAsCD,KAAK,CAACE,WAAN,CAAkBC,KAAxD;AAA8D,OAAvF;AACH,KARO;;;AAkDX;;AAjJiBI,wBAAd;AACI,WAAOA,YAAP;AACH,GAFa;;AAgBPA,6CAAP;AACI,SAAKH,WAAL,CAAiB,KAAjB;AACH,GAFM;;AAIAG,iDAAP,UAA6BC,UAA7B,EAA+DC,SAA/D,EAA+F;AAC3F;AACA;AACA;AACA;AACA;AACA,WAAO,EAAE,KAAKC,KAAL,KAAeD,SAAf,IAA4B5B,kBAAkB,CAAC,KAAK6B,KAAN,EAAaD,SAAb,CAAhD,CAAP;AACH,GAPM;;AASAF,8CAAP,UAA0BI,SAA1B,EAA2DC,SAA3D,EAA2F;;;AACvF,QAAID,SAAS,CAACE,cAAV,KAA6B,KAAKtB,KAAL,CAAWsB,cAA5C,EAA4D;AACxDC,aAAO,CAACC,IAAR,CAAapC,qCAAb;AACH;;AAED,QACIgC,SAAS,CAACK,YAAV,KAA2B,KAAKzB,KAAL,CAAWyB,YAAtC,IACAL,SAAS,CAACnB,KAAV,KAAoB,KAAKD,KAAL,CAAWC,KAD/B,IAEAmB,SAAS,CAACM,eAAV,KAA8B,KAAK1B,KAAL,CAAW0B,eAFzC,IAGAN,SAAS,CAACO,gBAAV,KAA+B,KAAK3B,KAAL,CAAW2B,gBAH1C,IAIAP,SAAS,CAACQ,oBAAV,KAAmC,KAAK5B,KAAL,CAAW4B,oBAJ9C,IAKAR,SAAS,CAACS,mBAAV,KAAkC,KAAK7B,KAAL,CAAW6B,mBANjD,EAOE;AACE;AACA,WAAKC,QAAL,CAAc;AACVnC,iBAAS,EAAEH,iBAAiB,CAACuC,IADnB;AAEVlC,yBAAiB,EAAE,CAFT;AAGVC,gBAAQ,EAAE,EAHA;AAIVC,eAAO,EAAE,KAAKC,KAAL,CAAWC;AAJV,OAAd;AAMH;;AAED,QAAI,CAACX,kBAAkB,CAAC+B,SAAD,EAAY,KAAKF,KAAjB,CAAvB,EAAgD;AAC5C,WAAKN,WAAL,CAAiB,KAAjB;AACH;;AACK,aAA6C,KAAKM,KAAlD;AAAA,QAAExB,SAAS,eAAX;AAAA,QAAaG,QAAQ,cAArB;AAAA,QAAuBD,iBAAiB,uBAAxC;;AACN,SACI;AACAF,aAAS,KAAKH,iBAAiB,CAACI,IAAhC,IACAD,SAAS,KAAK0B,SAAS,CAAC1B,SADxB,IAEAG,QAAQ,CAACkC,MAAT,KAAoBnC,iBAJxB,EAKE;AACE,uBAAKG,KAAL,EAAWiC,UAAX,MAAqB,IAArB,IAAqBC,aAArB,GAAqB,MAArB,GAAqBA,YAAGpC,QAAQ,CAACqC,KAAT,EAAH,CAArB;AACH;AACJ,GAlCM;;AAoCAnB,kCAAP;AAAA;;AACU,aAA2F,KAAKhB,KAAhG;AAAA,QAAEoC,SAAS,eAAX;AAAA,QAAaX,YAAY,kBAAzB;AAAA,QAA2BH,cAAc,oBAAzC;AAAA,QAA2Ce,KAAK,WAAhD;AAAA,QAAkDH,eAAlD;AAAA,QAAkDI,OAAO,mBAAG,KAAH,GAAQJ,EAAjE;AAAA,QAAmEL,mBAAmB,yBAAtF;AACN,QAAM/B,QAAQ,GAAG,KAAKyC,mBAAL,EAAjB;AACA,QAAMC,IAAI,GAAGvD,KAAK,CAACwD,aAAN,CACTH,OADS,EAET;AACIF,eAAS,EAAEpD,UAAU,CAACG,OAAO,CAACuD,aAAT,EAAwBN,SAAxB,CADzB;AAEIC,WAAK;AAFT,KAFS,EAMTZ,YAAY,KAAKvC,QAAQ,CAACyD,KAA1B,GAAkC7C,QAAlC,GAA6C,IANpC,EAOT,KAAKqB,KAAL,CAAWpB,OAAX,CAAmB6C,GAAnB,CAAuBf,mBAAvB,CAPS,EAQTJ,YAAY,KAAKvC,QAAQ,CAAC2D,GAA1B,GAAgC/C,QAAhC,GAA2C,IARlC,EASTb;AAAKmD,eAAS,EAAEjD,OAAO,CAAC2D,oBAAxB;AAA8CC,SAAG,EAAE,eAAG;AAAI,eAACrD,KAAI,CAACsD,MAAL,GAAcD,GAAf;AAAmB;AAA7E,MATS,CAAb;AAYA,WACI9D,oBAACM,YAAD,EAAa;AAAC0D,cAAQ,EAAE,KAAKC,MAAhB;AAAwB5B,oBAAc,EAAEA;AAAxC,KAAb,EACKkB,IADL,CADJ;AAKH,GApBM;;AAsBCxB,+CAAR;AACY,gBAAQ,GAAK,KAAKG,KAAL,CAAUrB,QAAvB;;AACR,QAAIA,QAAQ,CAACkC,MAAT,KAAoB,CAApB,IAAyB,CAAC,KAAKhC,KAAL,CAAW4B,oBAAzC,EAA+D;AAC3D,aAAO,IAAP;AACH;;AACD,WAAO,KAAK5B,KAAL,CAAW2B,gBAAX,CAA4B7B,QAAQ,CAACqC,KAAT,EAA5B,CAAP;AACH,GANO;;AAkBAnB,uCAAR,UAAoBZ,OAApB,EAAoC;AAApC;;AACI,QAAI,KAAK4C,MAAL,IAAe,IAAnB,EAAyB;AACrB;AACH;;AACD,QAAI5C,OAAJ,EAAa;AACT,WAAK0B,QAAL,CAAc,iBAAK;AAAI,eAAC;AACpBnC,mBAAS,EAAEH,iBAAiB,CAACuC,IADT;AAEpB;AACAlC,2BAAiB,EACbsB,KAAK,CAACxB,SAAN,KAAoBH,iBAAiB,CAACI,IAAtC,GAA6CuB,KAAK,CAACrB,QAAN,CAAekC,MAA5D,GAAqEb,KAAK,CAACtB,iBAJ3D;AAKpBC,kBAAQ,EAAE,EALU;AAMpBC,iBAAO,EAAEL,KAAI,CAACM,KAAL,CAAWC;AANA,SAAD;AAOrB,OAPF;AAQH,KATD,MASO,IAAI,KAAK+C,MAAL,CAAYG,WAAZ,GAA0B,GAA9B,EAAmC;AACtC;AACA,WAAKrB,QAAL,CAAc,iBAAK;AACf,YAAIX,KAAK,CAACpB,OAAN,CAAciC,MAAd,IAAwBtC,KAAI,CAACM,KAAL,CAAW0B,eAAvC,EAAyD;AACrD,iBAAO,IAAP;AACH;;AACD,YAAM0B,iBAAiB,GAAG1D,KAAI,CAACM,KAAL,CAAWyB,YAAX,KAA4BvC,QAAQ,CAACyD,KAA/D;AACA,YAAM5C,OAAO,GAAGoB,KAAK,CAACpB,OAAN,CAAcoC,KAAd,EAAhB;AACA,YAAMkB,IAAI,GAAGD,iBAAiB,GAAGrD,OAAO,CAACuD,KAAR,EAAH,GAAqBvD,OAAO,CAACwD,GAAR,EAAnD;;AACA,YAAIF,IAAI,KAAKG,SAAb,EAAwB;AACpB,iBAAO,IAAP;AACH;;AACD,YAAM1D,QAAQ,GAAGsD,iBAAiB,GAAEK,gCAAKtC,KAAK,CAACrB,QAAX,EAAmB,IAAnB,GAAmB,CAAEuD,IAAF,CAAnB,EAAyB,KAAzB,CAAF,GAA8BI,eAAEJ,IAAF,GAAWlC,KAAK,CAACrB,QAAjB,EAAyB,IAAzB,CAAhE;AACA,eAAO;AACH;AACA;AACA;AACAH,mBAAS,EAAEwB,KAAK,CAACxB,SAAN,KAAoBH,iBAAiB,CAACI,IAAtC,GAA6CJ,iBAAiB,CAACkE,MAA/D,GAAwEvC,KAAK,CAACxB,SAJtF;AAKHG,kBAAQ,UALL;AAMHC,iBAAO;AANJ,SAAP;AAQH,OAnBD;AAoBH,KAtBM,MAsBA;AACH;AACA,WAAK+B,QAAL,CAAc;AAAEnC,iBAAS,EAAEH,iBAAiB,CAACI;AAA/B,OAAd;AACH;AACJ,GAvCO;;AAjHMoB,6BAAc,UAAG3B,kBAAH,EAAqB,eAArB,CAAd;AAEA2B,8BAAgD;AAC1DY,wBAAoB,EAAE,KADoC;AAE1DH,gBAAY,EAAEvC,QAAQ,CAACyD,KAFmC;AAG1DjB,mBAAe,EAAE;AAHyC,GAAhD;AAuJlB;AA1JA,EAAqCzC,KAAK,CAAC0E,SAA3C;;SAAa3C","names":["classNames","React","Boundary","Classes","OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED","DISPLAYNAME_PREFIX","shallowCompareKeys","ResizeSensor","OverflowDirection","__extends","_this","direction","NONE","lastOverflowCount","overflow","visible","props","items","Map","entries","growing","some","previousWidth","previousWidths","get","entry","target","contentRect","width","repartition","forEach","set","OverflowList","_nextProps","nextState","state","prevProps","prevState","observeParents","console","warn","collapseFrom","minVisibleItems","overflowRenderer","alwaysRenderOverflow","visibleItemRenderer","setState","GROW","length","onOverflow","_b","slice","className","style","tagName","maybeRenderOverflow","list","createElement","OVERFLOW_LIST","START","map","END","OVERFLOW_LIST_SPACER","ref","spacer","onResize","resize","offsetWidth","collapseFromStart","next","shift","pop","undefined","__spreadArray","SHRINK","Component"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/core/src/components/overflow-list/overflowList.tsx"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ResizeObserverEntry } from \"@juggle/resize-observer\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { Boundary } from \"../../common/boundary\";\nimport * as Classes from \"../../common/classes\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, Props } from \"../../common/props\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n\n/** @internal - do not expose this type */\nexport enum OverflowDirection {\n    NONE,\n    GROW,\n    SHRINK,\n}\n\n// eslint-disable-next-line deprecation/deprecation\nexport type OverflowListProps<T> = IOverflowListProps<T>;\n/** @deprecated use OverflowListProps */\nexport interface IOverflowListProps<T> extends Props {\n    /**\n     * Whether to force the overflowRenderer to always be called, even if there are zero items\n     * overflowing. This may be useful, for example, if your overflow renderer contains a Popover\n     * which you do not want to close as the list is resized.\n     *\n     * @default false\n     */\n    alwaysRenderOverflow?: boolean;\n\n    /**\n     * Which direction the items should collapse from: start or end of the\n     * children. This also determines whether `overflowRenderer` appears before\n     * (`START`) or after (`END`) the visible items.\n     *\n     * @default Boundary.START\n     */\n    collapseFrom?: Boundary;\n\n    /**\n     * All items to display in the list. Items that do not fit in the container\n     * will be rendered in the overflow instead.\n     */\n    items: readonly T[];\n\n    /**\n     * The minimum number of visible items that should never collapse into the\n     * overflow menu, regardless of DOM dimensions.\n     *\n     * @default 0\n     */\n    minVisibleItems?: number;\n\n    /**\n     * If `true`, all parent DOM elements of the container will also be\n     * observed. If changes to a parent's size is detected, the overflow will be\n     * recalculated.\n     *\n     * Only enable this prop if the overflow should be recalculated when a\n     * parent element resizes in a way that does not also cause the\n     * `OverflowList` to resize.\n     *\n     * @default false\n     */\n    observeParents?: boolean;\n\n    /**\n     * Callback invoked when the overflowed items change. This is called once\n     * after the DOM has settled, rather that on every intermediate change. It\n     * is not invoked if resizing produces an unchanged overflow state.\n     */\n    onOverflow?: (overflowItems: T[]) => void;\n\n    /**\n     * Callback invoked to render the overflowed items. Unlike\n     * `visibleItemRenderer`, this prop is invoked once with all items that do\n     * not fit in the container.\n     *\n     * Typical use cases for this prop will put overflowed items in a dropdown\n     * menu or display a \"+X items\" label.\n     */\n    overflowRenderer: (overflowItems: T[]) => React.ReactNode;\n\n    /** CSS properties to apply to the root element. */\n    style?: React.CSSProperties;\n\n    /**\n     * HTML tag name for the container element.\n     *\n     * @default \"div\"\n     */\n    tagName?: keyof JSX.IntrinsicElements;\n\n    /**\n     * Callback invoked to render each visible item.\n     * Remember to set a `key` on the rendered element!\n     */\n    visibleItemRenderer: (item: T, index: number) => React.ReactChild;\n}\n\nexport interface IOverflowListState<T> {\n    /**\n     * Direction of current overflow operation. An overflow can take several frames to settle.\n     *\n     * @internal don't expose the type\n     */\n    direction: OverflowDirection;\n    /** Length of last overflow to dedupe `onOverflow` calls during smooth resizing. */\n    lastOverflowCount: number;\n    overflow: readonly T[];\n    visible: readonly T[];\n}\n\nexport class OverflowList<T> extends React.Component<OverflowListProps<T>, IOverflowListState<T>> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.OverflowList`;\n\n    public static defaultProps: Partial<OverflowListProps<any>> = {\n        alwaysRenderOverflow: false,\n        collapseFrom: Boundary.START,\n        minVisibleItems: 0,\n    };\n\n    public static ofType<U>() {\n        return OverflowList as new (props: OverflowListProps<U>) => OverflowList<U>;\n    }\n\n    public state: IOverflowListState<T> = {\n        direction: OverflowDirection.NONE,\n        lastOverflowCount: 0,\n        overflow: [],\n        visible: this.props.items,\n    };\n\n    /** A cache containing the widths of all elements being observed to detect growing/shrinking */\n    private previousWidths = new Map<Element, number>();\n\n    private spacer: HTMLElement | null = null;\n\n    public componentDidMount() {\n        this.repartition(false);\n    }\n\n    public shouldComponentUpdate(_nextProps: OverflowListProps<T>, nextState: IOverflowListState<T>) {\n        // We want this component to always re-render, even when props haven't changed, so that\n        // changes in the renderers' behavior can be reflected.\n        // The following statement prevents re-rendering only in the case where the state changes\n        // identity (i.e. setState was called), but the state is still the same when\n        // shallow-compared to the previous state.\n        return !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n    }\n\n    public componentDidUpdate(prevProps: OverflowListProps<T>, prevState: IOverflowListState<T>) {\n        if (prevProps.observeParents !== this.props.observeParents) {\n            console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n        }\n\n        if (\n            prevProps.collapseFrom !== this.props.collapseFrom ||\n            prevProps.items !== this.props.items ||\n            prevProps.minVisibleItems !== this.props.minVisibleItems ||\n            prevProps.overflowRenderer !== this.props.overflowRenderer ||\n            prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow ||\n            prevProps.visibleItemRenderer !== this.props.visibleItemRenderer\n        ) {\n            // reset visible state if the above props change.\n            this.setState({\n                direction: OverflowDirection.GROW,\n                lastOverflowCount: 0,\n                overflow: [],\n                visible: this.props.items,\n            });\n        }\n\n        if (!shallowCompareKeys(prevState, this.state)) {\n            this.repartition(false);\n        }\n        const { direction, overflow, lastOverflowCount } = this.state;\n        if (\n            // if a resize operation has just completed (transition to NONE)\n            direction === OverflowDirection.NONE &&\n            direction !== prevState.direction &&\n            overflow.length !== lastOverflowCount\n        ) {\n            this.props.onOverflow?.(overflow.slice());\n        }\n    }\n\n    public render() {\n        const { className, collapseFrom, observeParents, style, tagName = \"div\", visibleItemRenderer } = this.props;\n        const overflow = this.maybeRenderOverflow();\n        const list = React.createElement(\n            tagName,\n            {\n                className: classNames(Classes.OVERFLOW_LIST, className),\n                style,\n            },\n            collapseFrom === Boundary.START ? overflow : null,\n            this.state.visible.map(visibleItemRenderer),\n            collapseFrom === Boundary.END ? overflow : null,\n            <div className={Classes.OVERFLOW_LIST_SPACER} ref={ref => (this.spacer = ref)} />,\n        );\n\n        return (\n            <ResizeSensor onResize={this.resize} observeParents={observeParents}>\n                {list}\n            </ResizeSensor>\n        );\n    }\n\n    private maybeRenderOverflow() {\n        const { overflow } = this.state;\n        if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {\n            return null;\n        }\n        return this.props.overflowRenderer(overflow.slice());\n    }\n\n    private resize = (entries: readonly ResizeObserverEntry[]) => {\n        // if any parent is growing, assume we have more room than before\n        const growing = entries.some(entry => {\n            const previousWidth = this.previousWidths.get(entry.target) || 0;\n            return entry.contentRect.width > previousWidth;\n        });\n        this.repartition(growing);\n        entries.forEach(entry => this.previousWidths.set(entry.target, entry.contentRect.width));\n    };\n\n    private repartition(growing: boolean) {\n        if (this.spacer == null) {\n            return;\n        }\n        if (growing) {\n            this.setState(state => ({\n                direction: OverflowDirection.GROW,\n                // store last overflow if this is the beginning of a resize (for check in componentDidUpdate).\n                lastOverflowCount:\n                    state.direction === OverflowDirection.NONE ? state.overflow.length : state.lastOverflowCount,\n                overflow: [],\n                visible: this.props.items,\n            }));\n        } else if (this.spacer.offsetWidth < 0.9) {\n            // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n            this.setState(state => {\n                if (state.visible.length <= this.props.minVisibleItems!) {\n                    return null;\n                }\n                const collapseFromStart = this.props.collapseFrom === Boundary.START;\n                const visible = state.visible.slice();\n                const next = collapseFromStart ? visible.shift() : visible.pop();\n                if (next === undefined) {\n                    return null;\n                }\n                const overflow = collapseFromStart ? [...state.overflow, next] : [next, ...state.overflow];\n                return {\n                    // set SHRINK mode unless a GROW is already in progress.\n                    // GROW shows all items then shrinks until it settles, so we\n                    // preserve the fact that the original trigger was a GROW.\n                    direction: state.direction === OverflowDirection.NONE ? OverflowDirection.SHRINK : state.direction,\n                    overflow,\n                    visible,\n                };\n            });\n        } else {\n            // repartition complete!\n            this.setState({ direction: OverflowDirection.NONE });\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}