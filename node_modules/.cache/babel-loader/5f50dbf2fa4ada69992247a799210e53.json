{"ast":null,"code":"/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Tab } from \"./tab\";\nimport { generateTabPanelId, generateTabTitleId, TabTitle } from \"./tabTitle\";\nexport var Expander = function () {\n  return React.createElement(\"div\", {\n    className: Classes.FLEX_EXPANDER\n  });\n};\nvar TAB_SELECTOR = \".\".concat(Classes.TAB);\n\nvar Tabs =\n/** @class */\nfunction (_super) {\n  __extends(Tabs, _super);\n\n  function Tabs(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.tablistElement = null;\n    _this.refHandlers = {\n      tablist: function (tabElement) {\n        return _this.tablistElement = tabElement;\n      }\n    };\n\n    _this.handleKeyDown = function (e) {\n      var _a;\n\n      var focusedElement = (_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.closest(TAB_SELECTOR); // rest of this is potentially expensive and futile, so bail if no tab is focused\n\n      if (focusedElement == null) {\n        return;\n      } // must rely on DOM state because we have no way of mapping `focusedElement` to a JSX.Element\n\n\n      var enabledTabElements = _this.getTabElements().filter(function (el) {\n        return el.getAttribute(\"aria-disabled\") === \"false\";\n      });\n\n      var focusedIndex = enabledTabElements.indexOf(focusedElement);\n\n      var direction = _this.getKeyCodeDirection(e);\n\n      if (focusedIndex >= 0 && direction !== undefined) {\n        e.preventDefault();\n        var length_1 = enabledTabElements.length; // auto-wrapping at 0 and `length`\n\n        var nextFocusedIndex = (focusedIndex + direction + length_1) % length_1;\n        enabledTabElements[nextFocusedIndex].focus();\n      }\n    };\n\n    _this.handleKeyPress = function (e) {\n      var targetTabElement = e.target.closest(TAB_SELECTOR); // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n      // eslint-disable-next-line deprecation/deprecation\n\n      if (targetTabElement != null && Keys.isKeyboardClick(e.which)) {\n        e.preventDefault();\n        targetTabElement.click();\n      }\n    };\n\n    _this.handleTabClick = function (newTabId, event) {\n      var _a, _b;\n\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newTabId, _this.state.selectedTabId, event);\n\n      if (_this.props.selectedTabId === undefined) {\n        _this.setState({\n          selectedTabId: newTabId\n        });\n      }\n    };\n\n    _this.renderTabPanel = function (tab) {\n      var _a = tab.props,\n          className = _a.className,\n          panel = _a.panel,\n          id = _a.id,\n          panelClassName = _a.panelClassName;\n\n      if (panel === undefined) {\n        return undefined;\n      }\n\n      return React.createElement(\"div\", {\n        \"aria-labelledby\": generateTabTitleId(_this.props.id, id),\n        \"aria-hidden\": id !== _this.state.selectedTabId,\n        className: classNames(Classes.TAB_PANEL, className, panelClassName),\n        id: generateTabPanelId(_this.props.id, id),\n        key: id,\n        role: \"tabpanel\"\n      }, panel);\n    };\n\n    _this.renderTabTitle = function (child) {\n      if (isTabElement(child)) {\n        var id = child.props.id;\n        return React.createElement(TabTitle, __assign({}, child.props, {\n          parentId: _this.props.id,\n          onClick: _this.handleTabClick,\n          selected: id === _this.state.selectedTabId\n        }));\n      }\n\n      return child;\n    };\n\n    var selectedTabId = _this.getInitialSelectedTabId();\n\n    _this.state = {\n      selectedTabId: selectedTabId\n    };\n    return _this;\n  }\n\n  Tabs.getDerivedStateFromProps = function (_a) {\n    var selectedTabId = _a.selectedTabId;\n\n    if (selectedTabId !== undefined) {\n      // keep state in sync with controlled prop, so state is canonical source of truth\n      return {\n        selectedTabId: selectedTabId\n      };\n    }\n\n    return null;\n  };\n\n  Tabs.prototype.render = function () {\n    var _a, _b;\n\n    var _c = this.state,\n        indicatorWrapperStyle = _c.indicatorWrapperStyle,\n        selectedTabId = _c.selectedTabId;\n    var tabTitles = React.Children.map(this.props.children, this.renderTabTitle);\n    var tabPanels = this.getTabChildren().filter(this.props.renderActiveTabPanelOnly ? function (tab) {\n      return tab.props.id === selectedTabId;\n    } : function () {\n      return true;\n    }).map(this.renderTabPanel);\n    var tabIndicator = this.props.animate ? React.createElement(\"div\", {\n      className: Classes.TAB_INDICATOR_WRAPPER,\n      style: indicatorWrapperStyle\n    }, React.createElement(\"div\", {\n      className: Classes.TAB_INDICATOR\n    })) : null;\n    var classes = classNames(Classes.TABS, (_a = {}, _a[Classes.VERTICAL] = this.props.vertical, _a), this.props.className);\n    var tabListClasses = classNames(Classes.TAB_LIST, (_b = {}, _b[Classes.LARGE] = this.props.large, _b));\n    return React.createElement(\"div\", {\n      className: classes\n    }, React.createElement(\"div\", {\n      className: tabListClasses,\n      onKeyDown: this.handleKeyDown,\n      onKeyPress: this.handleKeyPress,\n      ref: this.refHandlers.tablist,\n      role: \"tablist\"\n    }, tabIndicator, tabTitles), tabPanels);\n  };\n\n  Tabs.prototype.componentDidMount = function () {\n    this.moveSelectionIndicator(false);\n  };\n\n  Tabs.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (this.state.selectedTabId !== prevState.selectedTabId) {\n      this.moveSelectionIndicator();\n    } else if (prevState.selectedTabId != null) {\n      // comparing React nodes is difficult to do with simple logic, so\n      // shallowly compare just their props as a workaround.\n      var didChildrenChange = !Utils.arraysEqual(this.getTabChildrenProps(prevProps), this.getTabChildrenProps(), Utils.shallowCompareKeys);\n\n      if (didChildrenChange) {\n        this.moveSelectionIndicator();\n      }\n    }\n  };\n\n  Tabs.prototype.getInitialSelectedTabId = function () {\n    // NOTE: providing an unknown ID will hide the selection\n    var _a = this.props,\n        defaultSelectedTabId = _a.defaultSelectedTabId,\n        selectedTabId = _a.selectedTabId;\n\n    if (selectedTabId !== undefined) {\n      return selectedTabId;\n    } else if (defaultSelectedTabId !== undefined) {\n      return defaultSelectedTabId;\n    } else {\n      // select first tab in absence of user input\n      var tabs = this.getTabChildren();\n      return tabs.length === 0 ? undefined : tabs[0].props.id;\n    }\n  };\n\n  Tabs.prototype.getKeyCodeDirection = function (e) {\n    if (isEventKeyCode(e, Keys.ARROW_LEFT, Keys.ARROW_UP)) {\n      return -1;\n    } else if (isEventKeyCode(e, Keys.ARROW_RIGHT, Keys.ARROW_DOWN)) {\n      return 1;\n    }\n\n    return undefined;\n  };\n\n  Tabs.prototype.getTabChildrenProps = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    return this.getTabChildren(props).map(function (child) {\n      return child.props;\n    });\n  };\n  /** Filters children to only `<Tab>`s */\n\n\n  Tabs.prototype.getTabChildren = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    return React.Children.toArray(props.children).filter(isTabElement);\n  };\n  /** Queries root HTML element for all tabs with optional filter selector */\n\n\n  Tabs.prototype.getTabElements = function (subselector) {\n    if (subselector === void 0) {\n      subselector = \"\";\n    }\n\n    if (this.tablistElement == null) {\n      return [];\n    }\n\n    return Array.from(this.tablistElement.querySelectorAll(TAB_SELECTOR + subselector));\n  };\n  /**\n   * Calculate the new height, width, and position of the tab indicator.\n   * Store the CSS values so the transition animation can start.\n   */\n\n\n  Tabs.prototype.moveSelectionIndicator = function (animate) {\n    if (animate === void 0) {\n      animate = true;\n    }\n\n    if (this.tablistElement == null || !this.props.animate) {\n      return;\n    }\n\n    var tabIdSelector = \"\".concat(TAB_SELECTOR, \"[data-tab-id=\\\"\").concat(this.state.selectedTabId, \"\\\"]\");\n    var selectedTabElement = this.tablistElement.querySelector(tabIdSelector);\n    var indicatorWrapperStyle = {\n      display: \"none\"\n    };\n\n    if (selectedTabElement != null) {\n      var clientHeight = selectedTabElement.clientHeight,\n          clientWidth = selectedTabElement.clientWidth,\n          offsetLeft = selectedTabElement.offsetLeft,\n          offsetTop = selectedTabElement.offsetTop;\n      indicatorWrapperStyle = {\n        height: clientHeight,\n        transform: \"translateX(\".concat(Math.floor(offsetLeft), \"px) translateY(\").concat(Math.floor(offsetTop), \"px)\"),\n        width: clientWidth\n      };\n\n      if (!animate) {\n        indicatorWrapperStyle.transition = \"none\";\n      }\n    }\n\n    this.setState({\n      indicatorWrapperStyle: indicatorWrapperStyle\n    });\n  };\n  /** Insert a `Tabs.Expander` between any two children to right-align all subsequent children. */\n\n\n  Tabs.Expander = Expander;\n  Tabs.Tab = Tab;\n  Tabs.defaultProps = {\n    animate: true,\n    large: false,\n    renderActiveTabPanelOnly: false,\n    vertical: false\n  };\n  Tabs.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Tabs\");\n  return Tabs;\n}(AbstractPureComponent2);\n\nexport { Tabs };\n\nfunction isEventKeyCode(e) {\n  var codes = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    codes[_i - 1] = arguments[_i];\n  } // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n  // eslint-disable-next-line deprecation/deprecation\n\n\n  return codes.indexOf(e.which) >= 0;\n}\n\nfunction isTabElement(child) {\n  return Utils.isElementOfType(child, Tab);\n}","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","Keys","DISPLAYNAME_PREFIX","Utils","Tab","generateTabPanelId","generateTabTitleId","TabTitle","Expander","className","FLEX_EXPANDER","TAB_SELECTOR","TAB","__extends","props","_super","_this","tablist","tabElement","tablistElement","e","focusedElement","activeElement","_a","closest","enabledTabElements","getTabElements","filter","getAttribute","focusedIndex","indexOf","direction","getKeyCodeDirection","undefined","preventDefault","nextFocusedIndex","length_1","focus","targetTabElement","target","isKeyboardClick","which","click","newTabId","event","onChange","_b","state","selectedTabId","setState","tab","panel","id","panelClassName","TAB_PANEL","key","role","child","isTabElement","__assign","parentId","onClick","handleTabClick","selected","getInitialSelectedTabId","Tabs","indicatorWrapperStyle","tabTitles","Children","map","children","renderTabTitle","tabPanels","getTabChildren","renderActiveTabPanelOnly","renderTabPanel","tabIndicator","animate","TAB_INDICATOR_WRAPPER","style","TAB_INDICATOR","classes","TABS","VERTICAL","vertical","tabListClasses","TAB_LIST","LARGE","large","onKeyDown","handleKeyDown","onKeyPress","handleKeyPress","ref","refHandlers","moveSelectionIndicator","prevProps","prevState","didChildrenChange","arraysEqual","getTabChildrenProps","shallowCompareKeys","defaultSelectedTabId","tabs","length","isEventKeyCode","ARROW_LEFT","ARROW_UP","ARROW_RIGHT","ARROW_DOWN","toArray","subselector","Array","from","querySelectorAll","tabIdSelector","concat","selectedTabElement","querySelector","display","clientWidth","offsetLeft","offsetTop","height","clientHeight","transform","Math","floor","width","transition","codes","isElementOfType"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/core/src/components/tabs/tabs.tsx"],"sourcesContent":["/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX, Props } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { TabProps, Tab, TabId } from \"./tab\";\nimport { generateTabPanelId, generateTabTitleId, TabTitle } from \"./tabTitle\";\n\nexport const Expander: React.FC = () => <div className={Classes.FLEX_EXPANDER} />;\n\ntype TabElement = React.ReactElement<TabProps & { children: React.ReactNode }>;\n\nconst TAB_SELECTOR = `.${Classes.TAB}`;\n\n// eslint-disable-next-line deprecation/deprecation\nexport type TabsProps = ITabsProps;\n/** @deprecated use TabsProps */\nexport interface ITabsProps extends Props {\n    /**\n     * Whether the selected tab indicator should animate its movement.\n     *\n     * @default true\n     */\n    animate?: boolean;\n\n    /** Tab elements. */\n    children: React.ReactNode;\n\n    /**\n     * Initial selected tab `id`, for uncontrolled usage.\n     * Note that this prop refers only to `<Tab>` children; other types of elements are ignored.\n     *\n     * @default first tab\n     */\n    defaultSelectedTabId?: TabId;\n\n    /**\n     * Unique identifier for this `Tabs` container. This will be combined with the `id` of each\n     * `Tab` child to generate ARIA accessibility attributes. IDs are required and should be\n     * unique on the page to support server-side rendering.\n     */\n    id: TabId;\n\n    /**\n     * If set to `true`, the tab titles will display with larger styling.\n     * This will apply large styles only to the tabs at this level, not to nested tabs.\n     *\n     * @default false\n     */\n    large?: boolean;\n\n    /**\n     * Whether inactive tab panels should be removed from the DOM and unmounted in React.\n     * This can be a performance enhancement when rendering many complex panels, but requires\n     * careful support for unmounting and remounting.\n     *\n     * @default false\n     */\n    renderActiveTabPanelOnly?: boolean;\n\n    /**\n     * Selected tab `id`, for controlled usage.\n     * Providing this prop will put the component in controlled mode.\n     * Unknown ids will result in empty selection (no errors).\n     */\n    selectedTabId?: TabId;\n\n    /**\n     * Whether to show tabs stacked vertically on the left side.\n     *\n     * @default false\n     */\n    vertical?: boolean;\n\n    /**\n     * A callback function that is invoked when a tab in the tab list is clicked.\n     */\n    onChange?(newTabId: TabId, prevTabId: TabId | undefined, event: React.MouseEvent<HTMLElement>): void;\n}\n\nexport interface ITabsState {\n    indicatorWrapperStyle?: React.CSSProperties;\n    selectedTabId?: TabId;\n}\n\nexport class Tabs extends AbstractPureComponent2<TabsProps, ITabsState> {\n    /** Insert a `Tabs.Expander` between any two children to right-align all subsequent children. */\n    public static Expander = Expander;\n\n    public static Tab = Tab;\n\n    public static defaultProps: Partial<TabsProps> = {\n        animate: true,\n        large: false,\n        renderActiveTabPanelOnly: false,\n        vertical: false,\n    };\n\n    public static displayName = `${DISPLAYNAME_PREFIX}.Tabs`;\n\n    public static getDerivedStateFromProps({ selectedTabId }: TabsProps) {\n        if (selectedTabId !== undefined) {\n            // keep state in sync with controlled prop, so state is canonical source of truth\n            return { selectedTabId };\n        }\n        return null;\n    }\n\n    private tablistElement: HTMLDivElement | null = null;\n\n    private refHandlers = {\n        tablist: (tabElement: HTMLDivElement) => (this.tablistElement = tabElement),\n    };\n\n    constructor(props: TabsProps) {\n        super(props);\n        const selectedTabId = this.getInitialSelectedTabId();\n        this.state = { selectedTabId };\n    }\n\n    public render() {\n        const { indicatorWrapperStyle, selectedTabId } = this.state;\n\n        const tabTitles = React.Children.map(this.props.children, this.renderTabTitle);\n\n        const tabPanels = this.getTabChildren()\n            .filter(this.props.renderActiveTabPanelOnly ? tab => tab.props.id === selectedTabId : () => true)\n            .map(this.renderTabPanel);\n\n        const tabIndicator = this.props.animate ? (\n            <div className={Classes.TAB_INDICATOR_WRAPPER} style={indicatorWrapperStyle}>\n                <div className={Classes.TAB_INDICATOR} />\n            </div>\n        ) : null;\n\n        const classes = classNames(Classes.TABS, { [Classes.VERTICAL]: this.props.vertical }, this.props.className);\n        const tabListClasses = classNames(Classes.TAB_LIST, {\n            [Classes.LARGE]: this.props.large,\n        });\n\n        return (\n            <div className={classes}>\n                <div\n                    className={tabListClasses}\n                    onKeyDown={this.handleKeyDown}\n                    onKeyPress={this.handleKeyPress}\n                    ref={this.refHandlers.tablist}\n                    role=\"tablist\"\n                >\n                    {tabIndicator}\n                    {tabTitles}\n                </div>\n                {tabPanels}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.moveSelectionIndicator(false);\n    }\n\n    public componentDidUpdate(prevProps: TabsProps, prevState: ITabsState) {\n        if (this.state.selectedTabId !== prevState.selectedTabId) {\n            this.moveSelectionIndicator();\n        } else if (prevState.selectedTabId != null) {\n            // comparing React nodes is difficult to do with simple logic, so\n            // shallowly compare just their props as a workaround.\n            const didChildrenChange = !Utils.arraysEqual(\n                this.getTabChildrenProps(prevProps),\n                this.getTabChildrenProps(),\n                Utils.shallowCompareKeys,\n            );\n            if (didChildrenChange) {\n                this.moveSelectionIndicator();\n            }\n        }\n    }\n\n    private getInitialSelectedTabId() {\n        // NOTE: providing an unknown ID will hide the selection\n        const { defaultSelectedTabId, selectedTabId } = this.props;\n        if (selectedTabId !== undefined) {\n            return selectedTabId;\n        } else if (defaultSelectedTabId !== undefined) {\n            return defaultSelectedTabId;\n        } else {\n            // select first tab in absence of user input\n            const tabs = this.getTabChildren();\n            return tabs.length === 0 ? undefined : tabs[0].props.id;\n        }\n    }\n\n    private getKeyCodeDirection(e: React.KeyboardEvent<HTMLElement>) {\n        if (isEventKeyCode(e, Keys.ARROW_LEFT, Keys.ARROW_UP)) {\n            return -1;\n        } else if (isEventKeyCode(e, Keys.ARROW_RIGHT, Keys.ARROW_DOWN)) {\n            return 1;\n        }\n        return undefined;\n    }\n\n    private getTabChildrenProps(props: TabsProps & { children?: React.ReactNode } = this.props) {\n        return this.getTabChildren(props).map(child => child.props);\n    }\n\n    /** Filters children to only `<Tab>`s */\n    private getTabChildren(props: TabsProps & { children?: React.ReactNode } = this.props) {\n        return React.Children.toArray(props.children).filter(isTabElement);\n    }\n\n    /** Queries root HTML element for all tabs with optional filter selector */\n    private getTabElements(subselector = \"\") {\n        if (this.tablistElement == null) {\n            return [];\n        }\n        return Array.from(this.tablistElement.querySelectorAll(TAB_SELECTOR + subselector));\n    }\n\n    private handleKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        const focusedElement = document.activeElement?.closest(TAB_SELECTOR);\n        // rest of this is potentially expensive and futile, so bail if no tab is focused\n        if (focusedElement == null) {\n            return;\n        }\n\n        // must rely on DOM state because we have no way of mapping `focusedElement` to a JSX.Element\n        const enabledTabElements = this.getTabElements().filter(el => el.getAttribute(\"aria-disabled\") === \"false\");\n        const focusedIndex = enabledTabElements.indexOf(focusedElement);\n        const direction = this.getKeyCodeDirection(e);\n\n        if (focusedIndex >= 0 && direction !== undefined) {\n            e.preventDefault();\n            const { length } = enabledTabElements;\n            // auto-wrapping at 0 and `length`\n            const nextFocusedIndex = (focusedIndex + direction + length) % length;\n            (enabledTabElements[nextFocusedIndex] as HTMLElement).focus();\n        }\n    };\n\n    private handleKeyPress = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        const targetTabElement = (e.target as HTMLElement).closest(TAB_SELECTOR) as HTMLElement;\n        // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        // eslint-disable-next-line deprecation/deprecation\n        if (targetTabElement != null && Keys.isKeyboardClick(e.which)) {\n            e.preventDefault();\n            targetTabElement.click();\n        }\n    };\n\n    private handleTabClick = (newTabId: TabId, event: React.MouseEvent<HTMLElement>) => {\n        this.props.onChange?.(newTabId, this.state.selectedTabId, event);\n        if (this.props.selectedTabId === undefined) {\n            this.setState({ selectedTabId: newTabId });\n        }\n    };\n\n    /**\n     * Calculate the new height, width, and position of the tab indicator.\n     * Store the CSS values so the transition animation can start.\n     */\n    private moveSelectionIndicator(animate = true) {\n        if (this.tablistElement == null || !this.props.animate) {\n            return;\n        }\n\n        const tabIdSelector = `${TAB_SELECTOR}[data-tab-id=\"${this.state.selectedTabId}\"]`;\n        const selectedTabElement = this.tablistElement.querySelector(tabIdSelector) as HTMLElement;\n\n        let indicatorWrapperStyle: React.CSSProperties = { display: \"none\" };\n        if (selectedTabElement != null) {\n            const { clientHeight, clientWidth, offsetLeft, offsetTop } = selectedTabElement;\n            indicatorWrapperStyle = {\n                height: clientHeight,\n                transform: `translateX(${Math.floor(offsetLeft)}px) translateY(${Math.floor(offsetTop)}px)`,\n                width: clientWidth,\n            };\n\n            if (!animate) {\n                indicatorWrapperStyle.transition = \"none\";\n            }\n        }\n        this.setState({ indicatorWrapperStyle });\n    }\n\n    private renderTabPanel = (tab: TabElement) => {\n        const { className, panel, id, panelClassName } = tab.props;\n        if (panel === undefined) {\n            return undefined;\n        }\n        return (\n            <div\n                aria-labelledby={generateTabTitleId(this.props.id, id)}\n                aria-hidden={id !== this.state.selectedTabId}\n                className={classNames(Classes.TAB_PANEL, className, panelClassName)}\n                id={generateTabPanelId(this.props.id, id)}\n                key={id}\n                role=\"tabpanel\"\n            >\n                {panel}\n            </div>\n        );\n    };\n\n    private renderTabTitle = (child: React.ReactNode) => {\n        if (isTabElement(child)) {\n            const { id } = child.props;\n            return (\n                <TabTitle\n                    {...child.props}\n                    parentId={this.props.id}\n                    onClick={this.handleTabClick}\n                    selected={id === this.state.selectedTabId}\n                />\n            );\n        }\n        return child;\n    };\n}\n\nfunction isEventKeyCode(e: React.KeyboardEvent<HTMLElement>, ...codes: number[]) {\n    // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n    // eslint-disable-next-line deprecation/deprecation\n    return codes.indexOf(e.which) >= 0;\n}\n\nfunction isTabElement(child: any): child is TabElement {\n    return Utils.isElementOfType(child, Tab);\n}\n"]},"metadata":{},"sourceType":"module"}