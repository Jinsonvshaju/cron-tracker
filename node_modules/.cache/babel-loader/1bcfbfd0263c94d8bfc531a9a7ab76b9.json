{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, DISPLAYNAME_PREFIX, Intent, Keys, Position, refHandler, removeNonHTMLProps, setRef, Utils } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { ButtonGroup } from \"../button/buttonGroup\";\nimport { Button } from \"../button/buttons\";\nimport { ControlGroup } from \"./controlGroup\";\nimport { InputGroup } from \"./inputGroup\";\nimport { clampValue, getValueOrEmptyValue, isValidNumericKeyboardEvent, isValueNumeric, parseStringToStringNumber, sanitizeNumericInput, toLocaleString, toMaxPrecision } from \"./numericInputUtils\";\nvar IncrementDirection;\n\n(function (IncrementDirection) {\n  IncrementDirection[IncrementDirection[\"DOWN\"] = -1] = \"DOWN\";\n  IncrementDirection[IncrementDirection[\"UP\"] = 1] = \"UP\";\n})(IncrementDirection || (IncrementDirection = {}));\n\nvar NON_HTML_PROPS = [\"allowNumericCharactersOnly\", \"buttonPosition\", \"clampValueOnBlur\", \"className\", \"defaultValue\", \"majorStepSize\", \"minorStepSize\", \"onButtonClick\", \"onValueChange\", \"selectAllOnFocus\", \"selectAllOnIncrement\", \"stepSize\"];\n\nvar NumericInput =\n/** @class */\nfunction (_super) {\n  __extends(NumericInput, _super);\n\n  function NumericInput() {\n    var _this = this;\n\n    var _a;\n\n    _this = _super.apply(this, arguments) || this;\n    _this.state = {\n      currentImeInputInvalid: false,\n      shouldSelectAfterUpdate: false,\n      stepMaxPrecision: NumericInput.getStepMaxPrecision(_this.props),\n      value: getValueOrEmptyValue((_a = _this.props.value) !== null && _a !== void 0 ? _a : _this.props.defaultValue)\n    }; // updating these flags need not trigger re-renders, so don't include them in this.state.\n\n    _this.didPasteEventJustOccur = false;\n    _this.delta = 0;\n    _this.inputElement = null;\n    _this.inputRef = refHandler(_this, \"inputElement\", _this.props.inputRef);\n    _this.incrementButtonHandlers = _this.getButtonEventHandlers(IncrementDirection.UP);\n    _this.decrementButtonHandlers = _this.getButtonEventHandlers(IncrementDirection.DOWN);\n\n    _this.handleButtonClick = function (e, direction) {\n      var _a, _b;\n\n      var delta = _this.updateDelta(direction, e);\n\n      var nextValue = _this.incrementValue(delta);\n\n      (_b = (_a = _this.props).onButtonClick) === null || _b === void 0 ? void 0 : _b.call(_a, Number(parseStringToStringNumber(nextValue, _this.props.locale)), nextValue);\n    };\n\n    _this.stopContinuousChange = function () {\n      _this.delta = 0;\n\n      _this.clearTimeouts();\n\n      clearInterval(_this.intervalId);\n      document.removeEventListener(\"mouseup\", _this.stopContinuousChange);\n    };\n\n    _this.handleContinuousChange = function () {\n      var _a, _b, _c, _d; // If either min or max prop is set, when reaching the limit\n      // the button will be disabled and stopContinuousChange will be never fired,\n      // hence the need to check on each iteration to properly clear the timeout\n\n\n      if (_this.props.min !== undefined || _this.props.max !== undefined) {\n        var min = (_a = _this.props.min) !== null && _a !== void 0 ? _a : -Infinity;\n        var max = (_b = _this.props.max) !== null && _b !== void 0 ? _b : Infinity;\n        var valueAsNumber = Number(parseStringToStringNumber(_this.state.value, _this.props.locale));\n\n        if (valueAsNumber <= min || valueAsNumber >= max) {\n          _this.stopContinuousChange();\n\n          return;\n        }\n      }\n\n      var nextValue = _this.incrementValue(_this.delta);\n\n      (_d = (_c = _this.props).onButtonClick) === null || _d === void 0 ? void 0 : _d.call(_c, Number(parseStringToStringNumber(nextValue, _this.props.locale)), nextValue);\n    }; // Callbacks - Input\n    // =================\n\n\n    _this.handleInputFocus = function (e) {\n      var _a, _b; // update this state flag to trigger update for input selection (see componentDidUpdate)\n\n\n      _this.setState({\n        shouldSelectAfterUpdate: _this.props.selectAllOnFocus\n      });\n\n      (_b = (_a = _this.props).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleInputBlur = function (e) {\n      var _a, _b; // always disable this flag on blur so it's ready for next time.\n\n\n      _this.setState({\n        shouldSelectAfterUpdate: false\n      });\n\n      if (_this.props.clampValueOnBlur) {\n        var value = e.target.value;\n\n        _this.handleNextValue(_this.roundAndClampValue(value));\n      }\n\n      (_b = (_a = _this.props).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleInputKeyDown = function (e) {\n      var _a, _b;\n\n      if (_this.props.disabled || _this.props.readOnly) {\n        return;\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      var keyCode = e.keyCode;\n      var direction;\n\n      if (keyCode === Keys.ARROW_UP) {\n        direction = IncrementDirection.UP;\n      } else if (keyCode === Keys.ARROW_DOWN) {\n        direction = IncrementDirection.DOWN;\n      }\n\n      if (direction !== undefined) {\n        // when the input field has focus, some key combinations will modify\n        // the field's selection range. we'll actually want to select all\n        // text in the field after we modify the value on the following\n        // lines. preventing the default selection behavior lets us do that\n        // without interference.\n        e.preventDefault();\n\n        var delta = _this.updateDelta(direction, e);\n\n        _this.incrementValue(delta);\n      }\n\n      (_b = (_a = _this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleCompositionEnd = function (e) {\n      if (_this.props.allowNumericCharactersOnly) {\n        _this.handleNextValue(sanitizeNumericInput(e.data, _this.props.locale));\n\n        _this.setState({\n          currentImeInputInvalid: false\n        });\n      }\n    };\n\n    _this.handleCompositionUpdate = function (e) {\n      if (_this.props.allowNumericCharactersOnly) {\n        var data = e.data;\n        var sanitizedValue = sanitizeNumericInput(data, _this.props.locale);\n\n        if (sanitizedValue.length === 0 && data.length > 0) {\n          _this.setState({\n            currentImeInputInvalid: true\n          });\n        } else {\n          _this.setState({\n            currentImeInputInvalid: false\n          });\n        }\n      }\n    };\n\n    _this.handleInputKeyPress = function (e) {\n      var _a, _b; // we prohibit keystrokes in onKeyPress instead of onKeyDown, because\n      // e.key is not trustworthy in onKeyDown in all browsers.\n\n\n      if (_this.props.allowNumericCharactersOnly && !isValidNumericKeyboardEvent(e, _this.props.locale)) {\n        e.preventDefault();\n      }\n\n      (_b = (_a = _this.props).onKeyPress) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleInputPaste = function (e) {\n      var _a, _b;\n\n      _this.didPasteEventJustOccur = true;\n      (_b = (_a = _this.props).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleInputChange = function (e) {\n      var value = e.target.value;\n      var nextValue = value;\n\n      if (_this.props.allowNumericCharactersOnly && _this.didPasteEventJustOccur) {\n        _this.didPasteEventJustOccur = false;\n        nextValue = sanitizeNumericInput(value, _this.props.locale);\n      }\n\n      _this.handleNextValue(nextValue);\n\n      _this.setState({\n        shouldSelectAfterUpdate: false\n      });\n    };\n\n    return _this;\n  }\n\n  NumericInput.getDerivedStateFromProps = function (props, state) {\n    var _a, _b;\n\n    var nextState = {\n      prevMaxProp: props.max,\n      prevMinProp: props.min\n    };\n    var didMinChange = props.min !== state.prevMinProp;\n    var didMaxChange = props.max !== state.prevMaxProp;\n    var didBoundsChange = didMinChange || didMaxChange; // in controlled mode, use props.value\n    // in uncontrolled mode, if state.value has not been assigned yet (upon initial mount), use props.defaultValue\n\n    var value = (_b = (_a = props.value) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : state.value;\n    var stepMaxPrecision = NumericInput.getStepMaxPrecision(props);\n    var sanitizedValue = value !== NumericInput.VALUE_EMPTY ? NumericInput.roundAndClampValue(value, stepMaxPrecision, props.min, props.max, 0, props.locale) : NumericInput.VALUE_EMPTY; // if a new min and max were provided that cause the existing value to fall\n    // outside of the new bounds, then clamp the value to the new valid range.\n\n    if (didBoundsChange && sanitizedValue !== state.value) {\n      return __assign(__assign({}, nextState), {\n        stepMaxPrecision: stepMaxPrecision,\n        value: sanitizedValue\n      });\n    }\n\n    return __assign(__assign({}, nextState), {\n      stepMaxPrecision: stepMaxPrecision,\n      value: value\n    });\n  }; // Value Helpers\n  // =============\n\n\n  NumericInput.getStepMaxPrecision = function (props) {\n    if (props.minorStepSize != null) {\n      return Utils.countDecimalPlaces(props.minorStepSize);\n    } else {\n      return Utils.countDecimalPlaces(props.stepSize);\n    }\n  };\n\n  NumericInput.roundAndClampValue = function (value, stepMaxPrecision, min, max, delta, locale) {\n    if (delta === void 0) {\n      delta = 0;\n    }\n\n    if (!isValueNumeric(value, locale)) {\n      return NumericInput.VALUE_EMPTY;\n    }\n\n    var currentValue = parseStringToStringNumber(value, locale);\n    var nextValue = toMaxPrecision(Number(currentValue) + delta, stepMaxPrecision);\n    var clampedValue = clampValue(nextValue, min, max);\n    return toLocaleString(clampedValue, locale);\n  };\n\n  NumericInput.prototype.render = function () {\n    var _a;\n\n    var _b = this.props,\n        buttonPosition = _b.buttonPosition,\n        className = _b.className,\n        fill = _b.fill,\n        large = _b.large;\n    var containerClasses = classNames(Classes.NUMERIC_INPUT, (_a = {}, _a[Classes.LARGE] = large, _a), className);\n    var buttons = this.renderButtons();\n    return React.createElement(ControlGroup, {\n      className: containerClasses,\n      fill: fill\n    }, buttonPosition === Position.LEFT && buttons, this.renderInput(), buttonPosition === Position.RIGHT && buttons);\n  };\n\n  NumericInput.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b, _c;\n\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n\n    if (prevProps.inputRef !== this.props.inputRef) {\n      setRef(prevProps.inputRef, null);\n      this.inputRef = refHandler(this, \"inputElement\", this.props.inputRef);\n      setRef(this.props.inputRef, this.inputElement);\n    }\n\n    if (this.state.shouldSelectAfterUpdate) {\n      (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.setSelectionRange(0, this.state.value.length);\n    }\n\n    var didMinChange = this.props.min !== prevProps.min;\n    var didMaxChange = this.props.max !== prevProps.max;\n    var didBoundsChange = didMinChange || didMaxChange;\n    var didLocaleChange = this.props.locale !== prevProps.locale;\n    var didValueChange = this.state.value !== prevState.value;\n\n    if (didBoundsChange && didValueChange || didLocaleChange && prevState.value !== NumericInput.VALUE_EMPTY) {\n      // we clamped the value due to a bounds change, so we should fire the change callback\n      var valueToParse = didLocaleChange ? prevState.value : this.state.value;\n      var valueAsString = parseStringToStringNumber(valueToParse, prevProps.locale);\n      var localizedValue = toLocaleString(+valueAsString, this.props.locale);\n      (_c = (_b = this.props).onValueChange) === null || _c === void 0 ? void 0 : _c.call(_b, +valueAsString, localizedValue, this.inputElement);\n    }\n  };\n\n  NumericInput.prototype.validateProps = function (nextProps) {\n    var majorStepSize = nextProps.majorStepSize,\n        max = nextProps.max,\n        min = nextProps.min,\n        minorStepSize = nextProps.minorStepSize,\n        stepSize = nextProps.stepSize,\n        value = nextProps.value;\n\n    if (min != null && max != null && min > max) {\n      console.error(Errors.NUMERIC_INPUT_MIN_MAX);\n    }\n\n    if (stepSize <= 0) {\n      console.error(Errors.NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE);\n    }\n\n    if (minorStepSize && minorStepSize <= 0) {\n      console.error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE);\n    }\n\n    if (majorStepSize && majorStepSize <= 0) {\n      console.error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE);\n    }\n\n    if (minorStepSize && minorStepSize > stepSize) {\n      console.error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND);\n    }\n\n    if (majorStepSize && majorStepSize < stepSize) {\n      console.error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND);\n    } // controlled mode\n\n\n    if (value != null) {\n      var stepMaxPrecision = NumericInput.getStepMaxPrecision(nextProps);\n      var sanitizedValue = NumericInput.roundAndClampValue(value.toString(), stepMaxPrecision, min, max, 0, this.props.locale);\n      var valueDoesNotMatch = sanitizedValue !== value.toString();\n      var localizedValue = toLocaleString(Number(parseStringToStringNumber(value, this.props.locale)), this.props.locale);\n      var isNotLocalized = sanitizedValue !== localizedValue;\n\n      if (valueDoesNotMatch && isNotLocalized) {\n        console.warn(Errors.NUMERIC_INPUT_CONTROLLED_VALUE_INVALID);\n      }\n    }\n  }; // Render Helpers\n  // ==============\n\n\n  NumericInput.prototype.renderButtons = function () {\n    var _a = this.props,\n        intent = _a.intent,\n        max = _a.max,\n        min = _a.min,\n        locale = _a.locale;\n    var value = parseStringToStringNumber(this.state.value, locale);\n    var disabled = this.props.disabled || this.props.readOnly;\n    var isIncrementDisabled = max !== undefined && value !== \"\" && +value >= max;\n    var isDecrementDisabled = min !== undefined && value !== \"\" && +value <= min;\n    return React.createElement(ButtonGroup, {\n      className: Classes.FIXED,\n      key: \"button-group\",\n      vertical: true\n    }, React.createElement(Button, __assign({\n      \"aria-label\": \"increment\",\n      disabled: disabled || isIncrementDisabled,\n      icon: \"chevron-up\",\n      intent: intent\n    }, this.incrementButtonHandlers)), React.createElement(Button, __assign({\n      \"aria-label\": \"decrement\",\n      disabled: disabled || isDecrementDisabled,\n      icon: \"chevron-down\",\n      intent: intent\n    }, this.decrementButtonHandlers)));\n  };\n\n  NumericInput.prototype.renderInput = function () {\n    var inputGroupHtmlProps = removeNonHTMLProps(this.props, NON_HTML_PROPS, true);\n    return React.createElement(InputGroup, __assign({\n      asyncControl: this.props.asyncControl,\n      autoComplete: \"off\"\n    }, inputGroupHtmlProps, {\n      intent: this.state.currentImeInputInvalid ? Intent.DANGER : this.props.intent,\n      inputRef: this.inputRef,\n      large: this.props.large,\n      leftIcon: this.props.leftIcon,\n      onFocus: this.handleInputFocus,\n      onBlur: this.handleInputBlur,\n      onChange: this.handleInputChange,\n      onCompositionEnd: this.handleCompositionEnd,\n      onCompositionUpdate: this.handleCompositionUpdate,\n      onKeyDown: this.handleInputKeyDown,\n      onKeyPress: this.handleInputKeyPress,\n      onPaste: this.handleInputPaste,\n      rightElement: this.props.rightElement,\n      value: this.state.value\n    }));\n  }; // Callbacks - Buttons\n  // ===================\n\n\n  NumericInput.prototype.getButtonEventHandlers = function (direction) {\n    var _this = this;\n\n    return {\n      // keydown is fired repeatedly when held so it's implicitly continuous\n      onKeyDown: function (evt) {\n        // eslint-disable-next-line deprecation/deprecation\n        if (!_this.props.disabled && Keys.isKeyboardClick(evt.keyCode)) {\n          _this.handleButtonClick(evt, direction);\n        }\n      },\n      onMouseDown: function (evt) {\n        if (!_this.props.disabled) {\n          _this.handleButtonClick(evt, direction);\n\n          _this.startContinuousChange();\n        }\n      }\n    };\n  };\n\n  NumericInput.prototype.startContinuousChange = function () {\n    var _this = this; // The button's onMouseUp event handler doesn't fire if the user\n    // releases outside of the button, so we need to watch all the way\n    // from the top.\n\n\n    document.addEventListener(\"mouseup\", this.stopContinuousChange); // Initial delay is slightly longer to prevent the user from\n    // accidentally triggering the continuous increment/decrement.\n\n    this.setTimeout(function () {\n      _this.intervalId = window.setInterval(_this.handleContinuousChange, NumericInput.CONTINUOUS_CHANGE_INTERVAL);\n    }, NumericInput.CONTINUOUS_CHANGE_DELAY);\n  }; // Data logic\n  // ==========\n\n\n  NumericInput.prototype.handleNextValue = function (valueAsString) {\n    var _a, _b;\n\n    if (this.props.value == null) {\n      this.setState({\n        value: valueAsString\n      });\n    }\n\n    (_b = (_a = this.props).onValueChange) === null || _b === void 0 ? void 0 : _b.call(_a, Number(parseStringToStringNumber(valueAsString, this.props.locale)), valueAsString, this.inputElement);\n  };\n\n  NumericInput.prototype.incrementValue = function (delta) {\n    // pretend we're incrementing from 0 if currValue is empty\n    var currValue = this.state.value === NumericInput.VALUE_EMPTY ? NumericInput.VALUE_ZERO : this.state.value;\n    var nextValue = this.roundAndClampValue(currValue, delta);\n\n    if (nextValue !== this.state.value) {\n      this.handleNextValue(nextValue);\n      this.setState({\n        shouldSelectAfterUpdate: this.props.selectAllOnIncrement\n      });\n    } // return value used in continuous change updates\n\n\n    return nextValue;\n  };\n\n  NumericInput.prototype.getIncrementDelta = function (direction, isShiftKeyPressed, isAltKeyPressed) {\n    var _a = this.props,\n        majorStepSize = _a.majorStepSize,\n        minorStepSize = _a.minorStepSize,\n        stepSize = _a.stepSize;\n\n    if (isShiftKeyPressed && majorStepSize != null) {\n      return direction * majorStepSize;\n    } else if (isAltKeyPressed && minorStepSize != null) {\n      return direction * minorStepSize;\n    } else {\n      return direction * stepSize;\n    }\n  };\n\n  NumericInput.prototype.roundAndClampValue = function (value, delta) {\n    if (delta === void 0) {\n      delta = 0;\n    }\n\n    return NumericInput.roundAndClampValue(value, this.state.stepMaxPrecision, this.props.min, this.props.max, delta, this.props.locale);\n  };\n\n  NumericInput.prototype.updateDelta = function (direction, e) {\n    this.delta = this.getIncrementDelta(direction, e.shiftKey, e.altKey);\n    return this.delta;\n  };\n\n  NumericInput.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".NumericInput\");\n  NumericInput.VALUE_EMPTY = \"\";\n  NumericInput.VALUE_ZERO = \"0\";\n  NumericInput.defaultProps = {\n    allowNumericCharactersOnly: true,\n    buttonPosition: Position.RIGHT,\n    clampValueOnBlur: false,\n    defaultValue: NumericInput.VALUE_EMPTY,\n    large: false,\n    majorStepSize: 10,\n    minorStepSize: 0.1,\n    selectAllOnFocus: false,\n    selectAllOnIncrement: false,\n    stepSize: 1\n  };\n  NumericInput.CONTINUOUS_CHANGE_DELAY = 300;\n  NumericInput.CONTINUOUS_CHANGE_INTERVAL = 100;\n  return NumericInput;\n}(AbstractPureComponent2);\n\nexport { NumericInput };","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","DISPLAYNAME_PREFIX","Intent","Keys","Position","refHandler","removeNonHTMLProps","setRef","Utils","Errors","ButtonGroup","Button","ControlGroup","InputGroup","clampValue","getValueOrEmptyValue","isValidNumericKeyboardEvent","isValueNumeric","parseStringToStringNumber","sanitizeNumericInput","toLocaleString","toMaxPrecision","IncrementDirection","NON_HTML_PROPS","__extends","_this","currentImeInputInvalid","shouldSelectAfterUpdate","stepMaxPrecision","NumericInput","getStepMaxPrecision","props","value","_a","defaultValue","inputRef","getButtonEventHandlers","UP","DOWN","e","direction","delta","updateDelta","nextValue","incrementValue","onButtonClick","_b","Number","locale","clearTimeouts","clearInterval","intervalId","document","removeEventListener","stopContinuousChange","min","undefined","max","Infinity","valueAsNumber","state","_d","setState","selectAllOnFocus","onFocus","clampValueOnBlur","target","handleNextValue","roundAndClampValue","onBlur","disabled","readOnly","keyCode","ARROW_UP","ARROW_DOWN","preventDefault","onKeyDown","allowNumericCharactersOnly","data","sanitizedValue","length","onKeyPress","didPasteEventJustOccur","onPaste","nextState","prevMaxProp","prevMinProp","didMinChange","didMaxChange","didBoundsChange","toString","VALUE_EMPTY","minorStepSize","countDecimalPlaces","stepSize","currentValue","clampedValue","buttonPosition","className","fill","large","containerClasses","NUMERIC_INPUT","LARGE","buttons","renderButtons","LEFT","renderInput","RIGHT","prevProps","prevState","_super","componentDidUpdate","call","inputElement","setSelectionRange","didLocaleChange","didValueChange","valueToParse","valueAsString","localizedValue","onValueChange","_c","nextProps","console","error","NUMERIC_INPUT_MIN_MAX","NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE","NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE","majorStepSize","NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE","NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND","NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND","valueDoesNotMatch","isNotLocalized","warn","NUMERIC_INPUT_CONTROLLED_VALUE_INVALID","intent","isIncrementDisabled","isDecrementDisabled","FIXED","key","vertical","__assign","icon","incrementButtonHandlers","decrementButtonHandlers","inputGroupHtmlProps","asyncControl","autoComplete","DANGER","leftIcon","handleInputFocus","handleInputBlur","onChange","handleInputChange","onCompositionEnd","handleCompositionEnd","onCompositionUpdate","handleCompositionUpdate","handleInputKeyDown","handleInputKeyPress","handleInputPaste","rightElement","isKeyboardClick","evt","handleButtonClick","onMouseDown","startContinuousChange","addEventListener","setTimeout","window","setInterval","handleContinuousChange","CONTINUOUS_CHANGE_INTERVAL","CONTINUOUS_CHANGE_DELAY","currValue","VALUE_ZERO","selectAllOnIncrement","isShiftKeyPressed","isAltKeyPressed","getIncrementDelta","shiftKey","altKey"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/core/src/components/forms/numericInput.tsx"],"sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport type { IconName } from \"@blueprintjs/icons\";\n\nimport {\n    AbstractPureComponent2,\n    Classes,\n    DISPLAYNAME_PREFIX,\n    HTMLInputProps,\n    IntentProps,\n    Intent,\n    Props,\n    IRef,\n    Keys,\n    MaybeElement,\n    Position,\n    refHandler,\n    removeNonHTMLProps,\n    setRef,\n    Utils,\n} from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { ButtonGroup } from \"../button/buttonGroup\";\nimport { Button } from \"../button/buttons\";\nimport { ControlGroup } from \"./controlGroup\";\nimport { InputGroup } from \"./inputGroup\";\nimport {\n    clampValue,\n    getValueOrEmptyValue,\n    isValidNumericKeyboardEvent,\n    isValueNumeric,\n    parseStringToStringNumber,\n    sanitizeNumericInput,\n    toLocaleString,\n    toMaxPrecision,\n} from \"./numericInputUtils\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type NumericInputProps = INumericInputProps;\n/** @deprecated use NumericInputProps */\nexport interface INumericInputProps extends IntentProps, Props {\n    /**\n     * Whether to allow only floating-point number characters in the field,\n     * mimicking the native `input[type=\"number\"]`.\n     *\n     * @default true\n     */\n    allowNumericCharactersOnly?: boolean;\n\n    /**\n     * Set this to `true` if you will be controlling the `value` of this input with asynchronous updates.\n     * These may occur if you do not immediately call setState in a parent component with the value from\n     * the `onChange` handler.\n     */\n    asyncControl?: boolean;\n\n    /**\n     * The position of the buttons with respect to the input field.\n     *\n     * @default Position.RIGHT\n     */\n    buttonPosition?: typeof Position.LEFT | typeof Position.RIGHT | \"none\";\n\n    /**\n     * Whether the value should be clamped to `[min, max]` on blur.\n     * The value will be clamped to each bound only if the bound is defined.\n     * Note that native `input[type=\"number\"]` controls do *NOT* clamp on blur.\n     *\n     * @default false\n     */\n    clampValueOnBlur?: boolean;\n\n    /**\n     * In uncontrolled mode, this sets the default value of the input.\n     * Note that this value is only used upon component instantiation and changes to this prop\n     * during the component lifecycle will be ignored.\n     *\n     * @default \"\"\n     */\n    defaultValue?: number | string;\n\n    /**\n     * Whether the input is non-interactive.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /** Whether the numeric input should take up the full width of its container. */\n    fill?: boolean;\n\n    /**\n     * Ref handler that receives HTML `<input>` element backing this component.\n     */\n    inputRef?: IRef<HTMLInputElement>;\n\n    /**\n     * If set to `true`, the input will display with larger styling.\n     * This is equivalent to setting `Classes.LARGE` via className on the\n     * parent control group and on the child input group.\n     *\n     * @default false\n     */\n    large?: boolean;\n\n    /**\n     * Name of a Blueprint UI icon (or an icon element) to render on the left side of input.\n     */\n    leftIcon?: IconName | MaybeElement;\n\n    /**\n     * The locale name, which is passed to the component to format the number and allowing to type the number in the specific locale.\n     * [See MDN documentation for more info about browser locale identification](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation).\n     *\n     * @default \"\"\n     */\n    locale?: string;\n\n    /**\n     * The increment between successive values when <kbd>shift</kbd> is held.\n     * Pass explicit `null` value to disable this interaction.\n     *\n     * @default 10\n     */\n    majorStepSize?: number | null;\n\n    /** The maximum value of the input. */\n    max?: number;\n\n    /** The minimum value of the input. */\n    min?: number;\n\n    /**\n     * The increment between successive values when <kbd>alt</kbd> is held.\n     * Pass explicit `null` value to disable this interaction.\n     *\n     * @default 0.1\n     */\n    minorStepSize?: number | null;\n\n    /** The placeholder text in the absence of any value. */\n    placeholder?: string;\n\n    /**\n     * Element to render on right side of input.\n     * For best results, use a minimal button, tag, or small spinner.\n     */\n    rightElement?: JSX.Element;\n\n    /**\n     * Whether the entire text field should be selected on focus.\n     *\n     * @default false\n     */\n    selectAllOnFocus?: boolean;\n\n    /**\n     * Whether the entire text field should be selected on increment.\n     *\n     * @default false\n     */\n    selectAllOnIncrement?: boolean;\n\n    /**\n     * The increment between successive values when no modifier keys are held.\n     *\n     * @default 1\n     */\n    stepSize?: number;\n\n    /**\n     * The value to display in the input field.\n     */\n    value?: number | string;\n\n    /** The callback invoked when the value changes due to a button click. */\n    onButtonClick?(valueAsNumber: number, valueAsString: string): void;\n\n    /** The callback invoked when the value changes due to typing, arrow keys, or button clicks. */\n    onValueChange?(valueAsNumber: number, valueAsString: string, inputElement: HTMLInputElement | null): void;\n}\n\nexport interface INumericInputState {\n    currentImeInputInvalid: boolean;\n    prevMinProp?: number;\n    prevMaxProp?: number;\n    shouldSelectAfterUpdate: boolean;\n    stepMaxPrecision: number;\n    value: string;\n}\n\nenum IncrementDirection {\n    DOWN = -1,\n    UP = +1,\n}\n\nconst NON_HTML_PROPS: Array<keyof NumericInputProps> = [\n    \"allowNumericCharactersOnly\",\n    \"buttonPosition\",\n    \"clampValueOnBlur\",\n    \"className\",\n    \"defaultValue\",\n    \"majorStepSize\",\n    \"minorStepSize\",\n    \"onButtonClick\",\n    \"onValueChange\",\n    \"selectAllOnFocus\",\n    \"selectAllOnIncrement\",\n    \"stepSize\",\n];\n\ntype ButtonEventHandlers = Required<Pick<React.HTMLAttributes<Element>, \"onKeyDown\" | \"onMouseDown\">>;\n\nexport class NumericInput extends AbstractPureComponent2<HTMLInputProps & NumericInputProps, INumericInputState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.NumericInput`;\n\n    public static VALUE_EMPTY = \"\";\n\n    public static VALUE_ZERO = \"0\";\n\n    public static defaultProps: NumericInputProps = {\n        allowNumericCharactersOnly: true,\n        buttonPosition: Position.RIGHT,\n        clampValueOnBlur: false,\n        defaultValue: NumericInput.VALUE_EMPTY,\n        large: false,\n        majorStepSize: 10,\n        minorStepSize: 0.1,\n        selectAllOnFocus: false,\n        selectAllOnIncrement: false,\n        stepSize: 1,\n    };\n\n    public static getDerivedStateFromProps(props: NumericInputProps, state: INumericInputState) {\n        const nextState = {\n            prevMaxProp: props.max,\n            prevMinProp: props.min,\n        };\n\n        const didMinChange = props.min !== state.prevMinProp;\n        const didMaxChange = props.max !== state.prevMaxProp;\n        const didBoundsChange = didMinChange || didMaxChange;\n\n        // in controlled mode, use props.value\n        // in uncontrolled mode, if state.value has not been assigned yet (upon initial mount), use props.defaultValue\n        const value = props.value?.toString() ?? state.value;\n        const stepMaxPrecision = NumericInput.getStepMaxPrecision(props);\n\n        const sanitizedValue =\n            value !== NumericInput.VALUE_EMPTY\n                ? NumericInput.roundAndClampValue(value, stepMaxPrecision, props.min, props.max, 0, props.locale)\n                : NumericInput.VALUE_EMPTY;\n\n        // if a new min and max were provided that cause the existing value to fall\n        // outside of the new bounds, then clamp the value to the new valid range.\n        if (didBoundsChange && sanitizedValue !== state.value) {\n            return { ...nextState, stepMaxPrecision, value: sanitizedValue };\n        }\n        return { ...nextState, stepMaxPrecision, value };\n    }\n\n    private static CONTINUOUS_CHANGE_DELAY = 300;\n\n    private static CONTINUOUS_CHANGE_INTERVAL = 100;\n\n    // Value Helpers\n    // =============\n    private static getStepMaxPrecision(props: HTMLInputProps & NumericInputProps) {\n        if (props.minorStepSize != null) {\n            return Utils.countDecimalPlaces(props.minorStepSize);\n        } else {\n            return Utils.countDecimalPlaces(props.stepSize!);\n        }\n    }\n\n    private static roundAndClampValue(\n        value: string,\n        stepMaxPrecision: number,\n        min: number | undefined,\n        max: number | undefined,\n        delta = 0,\n        locale: string | undefined,\n    ) {\n        if (!isValueNumeric(value, locale)) {\n            return NumericInput.VALUE_EMPTY;\n        }\n        const currentValue = parseStringToStringNumber(value, locale);\n        const nextValue = toMaxPrecision(Number(currentValue) + delta, stepMaxPrecision);\n        const clampedValue = clampValue(nextValue, min, max);\n        return toLocaleString(clampedValue, locale);\n    }\n\n    public state: INumericInputState = {\n        currentImeInputInvalid: false,\n        shouldSelectAfterUpdate: false,\n        stepMaxPrecision: NumericInput.getStepMaxPrecision(this.props),\n        value: getValueOrEmptyValue(this.props.value ?? this.props.defaultValue),\n    };\n\n    // updating these flags need not trigger re-renders, so don't include them in this.state.\n    private didPasteEventJustOccur = false;\n\n    private delta = 0;\n\n    public inputElement: HTMLInputElement | null = null;\n\n    private inputRef: IRef<HTMLInputElement> = refHandler(this, \"inputElement\", this.props.inputRef);\n\n    private intervalId?: number;\n\n    private incrementButtonHandlers = this.getButtonEventHandlers(IncrementDirection.UP);\n\n    private decrementButtonHandlers = this.getButtonEventHandlers(IncrementDirection.DOWN);\n\n    public render() {\n        const { buttonPosition, className, fill, large } = this.props;\n        const containerClasses = classNames(Classes.NUMERIC_INPUT, { [Classes.LARGE]: large }, className);\n        const buttons = this.renderButtons();\n        return (\n            <ControlGroup className={containerClasses} fill={fill}>\n                {buttonPosition === Position.LEFT && buttons}\n                {this.renderInput()}\n                {buttonPosition === Position.RIGHT && buttons}\n            </ControlGroup>\n        );\n    }\n\n    public componentDidUpdate(prevProps: NumericInputProps, prevState: INumericInputState) {\n        super.componentDidUpdate(prevProps, prevState);\n\n        if (prevProps.inputRef !== this.props.inputRef) {\n            setRef(prevProps.inputRef, null);\n            this.inputRef = refHandler(this, \"inputElement\", this.props.inputRef);\n            setRef(this.props.inputRef, this.inputElement);\n        }\n\n        if (this.state.shouldSelectAfterUpdate) {\n            this.inputElement?.setSelectionRange(0, this.state.value.length);\n        }\n\n        const didMinChange = this.props.min !== prevProps.min;\n        const didMaxChange = this.props.max !== prevProps.max;\n        const didBoundsChange = didMinChange || didMaxChange;\n        const didLocaleChange = this.props.locale !== prevProps.locale;\n        const didValueChange = this.state.value !== prevState.value;\n\n        if ((didBoundsChange && didValueChange) || (didLocaleChange && prevState.value !== NumericInput.VALUE_EMPTY)) {\n            // we clamped the value due to a bounds change, so we should fire the change callback\n            const valueToParse = didLocaleChange ? prevState.value : this.state.value;\n            const valueAsString = parseStringToStringNumber(valueToParse, prevProps.locale);\n            const localizedValue = toLocaleString(+valueAsString, this.props.locale);\n\n            this.props.onValueChange?.(+valueAsString, localizedValue, this.inputElement);\n        }\n    }\n\n    protected validateProps(nextProps: HTMLInputProps & NumericInputProps) {\n        const { majorStepSize, max, min, minorStepSize, stepSize, value } = nextProps;\n        if (min != null && max != null && min > max) {\n            console.error(Errors.NUMERIC_INPUT_MIN_MAX);\n        }\n        if (stepSize! <= 0) {\n            console.error(Errors.NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE);\n        }\n        if (minorStepSize && minorStepSize <= 0) {\n            console.error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE);\n        }\n        if (majorStepSize && majorStepSize <= 0) {\n            console.error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE);\n        }\n        if (minorStepSize && minorStepSize > stepSize!) {\n            console.error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND);\n        }\n        if (majorStepSize && majorStepSize < stepSize!) {\n            console.error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND);\n        }\n\n        // controlled mode\n        if (value != null) {\n            const stepMaxPrecision = NumericInput.getStepMaxPrecision(nextProps);\n            const sanitizedValue = NumericInput.roundAndClampValue(\n                value.toString(),\n                stepMaxPrecision,\n                min,\n                max,\n                0,\n                this.props.locale,\n            );\n            const valueDoesNotMatch = sanitizedValue !== value.toString();\n            const localizedValue = toLocaleString(\n                Number(parseStringToStringNumber(value, this.props.locale)),\n                this.props.locale,\n            );\n            const isNotLocalized = sanitizedValue !== localizedValue;\n\n            if (valueDoesNotMatch && isNotLocalized) {\n                console.warn(Errors.NUMERIC_INPUT_CONTROLLED_VALUE_INVALID);\n            }\n        }\n    }\n\n    // Render Helpers\n    // ==============\n\n    private renderButtons() {\n        const { intent, max, min, locale } = this.props;\n        const value = parseStringToStringNumber(this.state.value, locale);\n        const disabled = this.props.disabled || this.props.readOnly;\n        const isIncrementDisabled = max !== undefined && value !== \"\" && +value >= max;\n        const isDecrementDisabled = min !== undefined && value !== \"\" && +value <= min;\n\n        return (\n            <ButtonGroup className={Classes.FIXED} key=\"button-group\" vertical={true}>\n                <Button\n                    aria-label=\"increment\"\n                    disabled={disabled || isIncrementDisabled}\n                    icon=\"chevron-up\"\n                    intent={intent}\n                    {...this.incrementButtonHandlers}\n                />\n                <Button\n                    aria-label=\"decrement\"\n                    disabled={disabled || isDecrementDisabled}\n                    icon=\"chevron-down\"\n                    intent={intent}\n                    {...this.decrementButtonHandlers}\n                />\n            </ButtonGroup>\n        );\n    }\n\n    private renderInput() {\n        const inputGroupHtmlProps = removeNonHTMLProps(this.props, NON_HTML_PROPS, true);\n        return (\n            <InputGroup\n                asyncControl={this.props.asyncControl}\n                autoComplete=\"off\"\n                {...inputGroupHtmlProps}\n                intent={this.state.currentImeInputInvalid ? Intent.DANGER : this.props.intent}\n                inputRef={this.inputRef}\n                large={this.props.large}\n                leftIcon={this.props.leftIcon}\n                onFocus={this.handleInputFocus}\n                onBlur={this.handleInputBlur}\n                onChange={this.handleInputChange}\n                onCompositionEnd={this.handleCompositionEnd}\n                onCompositionUpdate={this.handleCompositionUpdate}\n                onKeyDown={this.handleInputKeyDown}\n                onKeyPress={this.handleInputKeyPress}\n                onPaste={this.handleInputPaste}\n                rightElement={this.props.rightElement}\n                value={this.state.value}\n            />\n        );\n    }\n\n    // Callbacks - Buttons\n    // ===================\n\n    private getButtonEventHandlers(direction: IncrementDirection): ButtonEventHandlers {\n        return {\n            // keydown is fired repeatedly when held so it's implicitly continuous\n            onKeyDown: evt => {\n                // eslint-disable-next-line deprecation/deprecation\n                if (!this.props.disabled && Keys.isKeyboardClick(evt.keyCode)) {\n                    this.handleButtonClick(evt, direction);\n                }\n            },\n            onMouseDown: evt => {\n                if (!this.props.disabled) {\n                    this.handleButtonClick(evt, direction);\n                    this.startContinuousChange();\n                }\n            },\n        };\n    }\n\n    private handleButtonClick = (e: React.MouseEvent | React.KeyboardEvent, direction: IncrementDirection) => {\n        const delta = this.updateDelta(direction, e);\n        const nextValue = this.incrementValue(delta);\n        this.props.onButtonClick?.(Number(parseStringToStringNumber(nextValue, this.props.locale)), nextValue);\n    };\n\n    private startContinuousChange() {\n        // The button's onMouseUp event handler doesn't fire if the user\n        // releases outside of the button, so we need to watch all the way\n        // from the top.\n        document.addEventListener(\"mouseup\", this.stopContinuousChange);\n\n        // Initial delay is slightly longer to prevent the user from\n        // accidentally triggering the continuous increment/decrement.\n        this.setTimeout(() => {\n            this.intervalId = window.setInterval(this.handleContinuousChange, NumericInput.CONTINUOUS_CHANGE_INTERVAL);\n        }, NumericInput.CONTINUOUS_CHANGE_DELAY);\n    }\n\n    private stopContinuousChange = () => {\n        this.delta = 0;\n        this.clearTimeouts();\n        clearInterval(this.intervalId);\n        document.removeEventListener(\"mouseup\", this.stopContinuousChange);\n    };\n\n    private handleContinuousChange = () => {\n        // If either min or max prop is set, when reaching the limit\n        // the button will be disabled and stopContinuousChange will be never fired,\n        // hence the need to check on each iteration to properly clear the timeout\n        if (this.props.min !== undefined || this.props.max !== undefined) {\n            const min = this.props.min ?? -Infinity;\n            const max = this.props.max ?? Infinity;\n            const valueAsNumber = Number(parseStringToStringNumber(this.state.value, this.props.locale));\n            if (valueAsNumber <= min || valueAsNumber >= max) {\n                this.stopContinuousChange();\n                return;\n            }\n        }\n        const nextValue = this.incrementValue(this.delta);\n        this.props.onButtonClick?.(Number(parseStringToStringNumber(nextValue, this.props.locale)), nextValue);\n    };\n\n    // Callbacks - Input\n    // =================\n\n    private handleInputFocus = (e: React.FocusEvent<HTMLInputElement>) => {\n        // update this state flag to trigger update for input selection (see componentDidUpdate)\n        this.setState({ shouldSelectAfterUpdate: this.props.selectAllOnFocus! });\n        this.props.onFocus?.(e);\n    };\n\n    private handleInputBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n        // always disable this flag on blur so it's ready for next time.\n        this.setState({ shouldSelectAfterUpdate: false });\n\n        if (this.props.clampValueOnBlur) {\n            const { value } = e.target as HTMLInputElement;\n            this.handleNextValue(this.roundAndClampValue(value));\n        }\n\n        this.props.onBlur?.(e);\n    };\n\n    private handleInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n        if (this.props.disabled || this.props.readOnly) {\n            return;\n        }\n\n        // eslint-disable-next-line deprecation/deprecation\n        const { keyCode } = e;\n\n        let direction: IncrementDirection | undefined;\n\n        if (keyCode === Keys.ARROW_UP) {\n            direction = IncrementDirection.UP;\n        } else if (keyCode === Keys.ARROW_DOWN) {\n            direction = IncrementDirection.DOWN;\n        }\n\n        if (direction !== undefined) {\n            // when the input field has focus, some key combinations will modify\n            // the field's selection range. we'll actually want to select all\n            // text in the field after we modify the value on the following\n            // lines. preventing the default selection behavior lets us do that\n            // without interference.\n            e.preventDefault();\n\n            const delta = this.updateDelta(direction, e);\n            this.incrementValue(delta);\n        }\n\n        this.props.onKeyDown?.(e);\n    };\n\n    private handleCompositionEnd = (e: React.CompositionEvent<HTMLInputElement>) => {\n        if (this.props.allowNumericCharactersOnly) {\n            this.handleNextValue(sanitizeNumericInput(e.data, this.props.locale));\n            this.setState({ currentImeInputInvalid: false });\n        }\n    };\n\n    private handleCompositionUpdate = (e: React.CompositionEvent<HTMLInputElement>) => {\n        if (this.props.allowNumericCharactersOnly) {\n            const { data } = e;\n            const sanitizedValue = sanitizeNumericInput(data, this.props.locale);\n            if (sanitizedValue.length === 0 && data.length > 0) {\n                this.setState({ currentImeInputInvalid: true });\n            } else {\n                this.setState({ currentImeInputInvalid: false });\n            }\n        }\n    };\n\n    private handleInputKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {\n        // we prohibit keystrokes in onKeyPress instead of onKeyDown, because\n        // e.key is not trustworthy in onKeyDown in all browsers.\n        if (this.props.allowNumericCharactersOnly && !isValidNumericKeyboardEvent(e, this.props.locale)) {\n            e.preventDefault();\n        }\n\n        this.props.onKeyPress?.(e);\n    };\n\n    private handleInputPaste = (e: React.ClipboardEvent<HTMLInputElement>) => {\n        this.didPasteEventJustOccur = true;\n        this.props.onPaste?.(e);\n    };\n\n    private handleInputChange = (e: React.FormEvent) => {\n        const { value } = e.target as HTMLInputElement;\n        let nextValue = value;\n        if (this.props.allowNumericCharactersOnly && this.didPasteEventJustOccur) {\n            this.didPasteEventJustOccur = false;\n            nextValue = sanitizeNumericInput(value, this.props.locale);\n        }\n\n        this.handleNextValue(nextValue);\n        this.setState({ shouldSelectAfterUpdate: false });\n    };\n\n    // Data logic\n    // ==========\n\n    private handleNextValue(valueAsString: string) {\n        if (this.props.value == null) {\n            this.setState({ value: valueAsString });\n        }\n\n        this.props.onValueChange?.(\n            Number(parseStringToStringNumber(valueAsString, this.props.locale)),\n            valueAsString,\n            this.inputElement,\n        );\n    }\n\n    private incrementValue(delta: number) {\n        // pretend we're incrementing from 0 if currValue is empty\n        const currValue = this.state.value === NumericInput.VALUE_EMPTY ? NumericInput.VALUE_ZERO : this.state.value;\n        const nextValue = this.roundAndClampValue(currValue, delta);\n\n        if (nextValue !== this.state.value) {\n            this.handleNextValue(nextValue);\n            this.setState({ shouldSelectAfterUpdate: this.props.selectAllOnIncrement! });\n        }\n\n        // return value used in continuous change updates\n        return nextValue;\n    }\n\n    private getIncrementDelta(direction: IncrementDirection, isShiftKeyPressed: boolean, isAltKeyPressed: boolean) {\n        const { majorStepSize, minorStepSize, stepSize } = this.props;\n\n        if (isShiftKeyPressed && majorStepSize != null) {\n            return direction * majorStepSize;\n        } else if (isAltKeyPressed && minorStepSize != null) {\n            return direction * minorStepSize;\n        } else {\n            return direction * stepSize!;\n        }\n    }\n\n    private roundAndClampValue(value: string, delta = 0) {\n        return NumericInput.roundAndClampValue(\n            value,\n            this.state.stepMaxPrecision,\n            this.props.min,\n            this.props.max,\n            delta,\n            this.props.locale,\n        );\n    }\n\n    private updateDelta(direction: IncrementDirection, e: React.MouseEvent | React.KeyboardEvent) {\n        this.delta = this.getIncrementDelta(direction, e.shiftKey, e.altKey);\n        return this.delta;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}