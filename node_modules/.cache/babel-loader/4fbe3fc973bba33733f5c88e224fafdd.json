{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Children } from \"react\";\nimport { isElementOfType } from \"../../common/utils\";\nimport { Hotkey } from \"./hotkey\";\nimport { comboMatches, getKeyCombo, parseKeyCombo } from \"./hotkeyParser\";\nimport { hideHotkeysDialogAfterDelay, isHotkeysDialogShowing, showHotkeysDialog } from \"./hotkeysDialog\";\nvar SHOW_DIALOG_KEY = \"?\";\nexport var HotkeyScope;\n\n(function (HotkeyScope) {\n  HotkeyScope[\"LOCAL\"] = \"local\";\n  HotkeyScope[\"GLOBAL\"] = \"global\";\n})(HotkeyScope || (HotkeyScope = {}));\n\nvar HotkeysEvents =\n/** @class */\nfunction () {\n  function HotkeysEvents(scope) {\n    var _this = this;\n\n    this.scope = scope;\n    this.actions = [];\n\n    this.handleKeyDown = function (e) {\n      var combo = getKeyCombo(e);\n\n      var isTextInput = _this.isTextInput(e);\n\n      if (!isTextInput && comboMatches(parseKeyCombo(SHOW_DIALOG_KEY), combo)) {\n        if (isHotkeysDialogShowing()) {\n          hideHotkeysDialogAfterDelay();\n        } else {\n          showHotkeysDialog(_this.actions.map(function (action) {\n            return action.props;\n          }));\n        }\n\n        return;\n      } else if (isHotkeysDialogShowing()) {\n        return;\n      }\n\n      _this.invokeNamedCallbackIfComboRecognized(combo, \"onKeyDown\", e);\n    };\n\n    this.handleKeyUp = function (e) {\n      if (isHotkeysDialogShowing()) {\n        return;\n      }\n\n      _this.invokeNamedCallbackIfComboRecognized(getKeyCombo(e), \"onKeyUp\", e);\n    };\n  }\n\n  HotkeysEvents.prototype.count = function () {\n    return this.actions.length;\n  };\n\n  HotkeysEvents.prototype.clear = function () {\n    this.actions = [];\n  };\n\n  HotkeysEvents.prototype.setHotkeys = function (props) {\n    var _this = this;\n\n    var actions = [];\n    Children.forEach(props.children, function (child) {\n      if (isElementOfType(child, Hotkey) && _this.isScope(child.props)) {\n        actions.push({\n          combo: parseKeyCombo(child.props.combo),\n          props: child.props\n        });\n      }\n    });\n    this.actions = actions;\n  };\n\n  HotkeysEvents.prototype.invokeNamedCallbackIfComboRecognized = function (combo, callbackName, e) {\n    var _a, _b;\n\n    var isTextInput = this.isTextInput(e);\n\n    for (var _i = 0, _c = this.actions; _i < _c.length; _i++) {\n      var action = _c[_i];\n      var shouldIgnore = isTextInput && !action.props.allowInInput || action.props.disabled;\n\n      if (!shouldIgnore && comboMatches(action.combo, combo)) {\n        if (action.props.preventDefault) {\n          e.preventDefault();\n        }\n\n        if (action.props.stopPropagation) {\n          // set a flag just for unit testing. not meant to be referenced in feature work.\n          e.isPropagationStopped = true;\n          e.stopPropagation();\n        }\n\n        (_b = (_a = action.props)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n      }\n    }\n  };\n\n  HotkeysEvents.prototype.isScope = function (props) {\n    return (props.global ? HotkeyScope.GLOBAL : HotkeyScope.LOCAL) === this.scope;\n  };\n\n  HotkeysEvents.prototype.isTextInput = function (e) {\n    var elem = e.target; // we check these cases for unit testing, but this should not happen\n    // during normal operation\n\n    if (elem == null || elem.closest == null) {\n      return false;\n    }\n\n    var editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n    if (editable == null) {\n      return false;\n    } // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n\n\n    if (editable.tagName.toLowerCase() === \"input\") {\n      var inputType = editable.type;\n\n      if (inputType === \"checkbox\" || inputType === \"radio\") {\n        return false;\n      }\n    } // don't let read-only fields prevent hotkey behavior\n\n\n    if (editable.readOnly) {\n      return false;\n    }\n\n    return true;\n  };\n\n  return HotkeysEvents;\n}();\n\nexport { HotkeysEvents };","map":{"version":3,"mappings":"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","names":["Children","isElementOfType","Hotkey","comboMatches","getKeyCombo","parseKeyCombo","hideHotkeysDialogAfterDelay","isHotkeysDialogShowing","showHotkeysDialog","SHOW_DIALOG_KEY","HotkeyScope","scope","e","combo","isTextInput","_this","actions","map","props","invokeNamedCallbackIfComboRecognized","HotkeysEvents","length","forEach","children","child","isScope","push","callbackName","_i","action","shouldIgnore","allowInInput","disabled","preventDefault","stopPropagation","isPropagationStopped","_b","global","GLOBAL","LOCAL","elem","target","closest","editable","tagName","toLowerCase","inputType","type","readOnly"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/core/src/components/hotkeys/hotkeysEvents.ts"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Children, ReactNode } from \"react\";\n\nimport { isElementOfType } from \"../../common/utils\";\nimport { Hotkey, IHotkeyProps } from \"./hotkey\";\nimport { comboMatches, getKeyCombo, IKeyCombo, parseKeyCombo } from \"./hotkeyParser\";\nimport { hideHotkeysDialogAfterDelay, isHotkeysDialogShowing, showHotkeysDialog } from \"./hotkeysDialog\";\nimport { IHotkeysProps } from \"./hotkeysTypes\";\n\nconst SHOW_DIALOG_KEY = \"?\";\n\nexport enum HotkeyScope {\n    LOCAL = \"local\",\n    GLOBAL = \"global\",\n}\n\nexport interface IHotkeyAction {\n    combo: IKeyCombo;\n    props: IHotkeyProps;\n}\n\nexport class HotkeysEvents {\n    private actions = [] as IHotkeyAction[];\n\n    public constructor(private scope: HotkeyScope) {}\n\n    public count() {\n        return this.actions.length;\n    }\n\n    public clear() {\n        this.actions = [];\n    }\n\n    public setHotkeys(props: IHotkeysProps & { children?: ReactNode }) {\n        const actions = [] as IHotkeyAction[];\n        Children.forEach(props.children, (child: ReactNode) => {\n            if (isElementOfType(child, Hotkey) && this.isScope(child.props)) {\n                actions.push({\n                    combo: parseKeyCombo(child.props.combo),\n                    props: child.props,\n                });\n            }\n        });\n        this.actions = actions;\n    }\n\n    public handleKeyDown = (e: KeyboardEvent) => {\n        const combo = getKeyCombo(e);\n        const isTextInput = this.isTextInput(e);\n\n        if (!isTextInput && comboMatches(parseKeyCombo(SHOW_DIALOG_KEY), combo)) {\n            if (isHotkeysDialogShowing()) {\n                hideHotkeysDialogAfterDelay();\n            } else {\n                showHotkeysDialog(this.actions.map(action => action.props));\n            }\n            return;\n        } else if (isHotkeysDialogShowing()) {\n            return;\n        }\n\n        this.invokeNamedCallbackIfComboRecognized(combo, \"onKeyDown\", e);\n    };\n\n    public handleKeyUp = (e: KeyboardEvent) => {\n        if (isHotkeysDialogShowing()) {\n            return;\n        }\n        this.invokeNamedCallbackIfComboRecognized(getKeyCombo(e), \"onKeyUp\", e);\n    };\n\n    private invokeNamedCallbackIfComboRecognized(\n        combo: IKeyCombo,\n        callbackName: \"onKeyDown\" | \"onKeyUp\",\n        e: KeyboardEvent,\n    ) {\n        const isTextInput = this.isTextInput(e);\n        for (const action of this.actions) {\n            const shouldIgnore = (isTextInput && !action.props.allowInInput) || action.props.disabled;\n            if (!shouldIgnore && comboMatches(action.combo, combo)) {\n                if (action.props.preventDefault) {\n                    e.preventDefault();\n                }\n                if (action.props.stopPropagation) {\n                    // set a flag just for unit testing. not meant to be referenced in feature work.\n                    (e as any).isPropagationStopped = true;\n                    e.stopPropagation();\n                }\n                action.props[callbackName]?.(e);\n            }\n        }\n    }\n\n    private isScope(props: IHotkeyProps) {\n        return (props.global ? HotkeyScope.GLOBAL : HotkeyScope.LOCAL) === this.scope;\n    }\n\n    private isTextInput(e: KeyboardEvent) {\n        const elem = e.target as HTMLElement;\n        // we check these cases for unit testing, but this should not happen\n        // during normal operation\n        if (elem == null || elem.closest == null) {\n            return false;\n        }\n\n        const editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n        if (editable == null) {\n            return false;\n        }\n\n        // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n        if (editable.tagName.toLowerCase() === \"input\") {\n            const inputType = (editable as HTMLInputElement).type;\n            if (inputType === \"checkbox\" || inputType === \"radio\") {\n                return false;\n            }\n        }\n\n        // don't let read-only fields prevent hotkey behavior\n        if ((editable as HTMLInputElement).readOnly) {\n            return false;\n        }\n\n        return true;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}