{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { formatPercentage } from \"./sliderUtils\"; // props that require number values, for validation\n\nvar NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"];\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\n\nvar Handle =\n/** @class */\nfunction (_super) {\n  __extends(Handle, _super);\n\n  function Handle() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      isMoving: false\n    };\n    _this.handleElement = null;\n    _this.refHandlers = {\n      handle: function (el) {\n        return _this.handleElement = el;\n      }\n    };\n\n    _this.beginHandleMovement = function (event) {\n      document.addEventListener(\"mousemove\", _this.handleHandleMovement);\n      document.addEventListener(\"mouseup\", _this.endHandleMovement);\n\n      _this.setState({\n        isMoving: true\n      });\n\n      _this.changeValue(_this.clientToValue(_this.mouseEventClientOffset(event)));\n    };\n\n    _this.beginHandleTouchMovement = function (event) {\n      document.addEventListener(\"touchmove\", _this.handleHandleTouchMovement);\n      document.addEventListener(\"touchend\", _this.endHandleTouchMovement);\n      document.addEventListener(\"touchcancel\", _this.endHandleTouchMovement);\n\n      _this.setState({\n        isMoving: true\n      });\n\n      _this.changeValue(_this.clientToValue(_this.touchEventClientOffset(event)));\n    };\n\n    _this.getStyleProperties = function () {\n      if (_this.handleElement == null) {\n        return {};\n      } // The handle midpoint of RangeSlider is actually shifted by a margin to\n      // be on the edge of the visible handle element. Because the midpoint\n      // calculation does not take this margin into account, we instead\n      // measure the long side (which is equal to the short side plus the\n      // margin).\n\n\n      var _a = _this.props,\n          _b = _a.min,\n          min = _b === void 0 ? 0 : _b,\n          tickSizeRatio = _a.tickSizeRatio,\n          value = _a.value,\n          vertical = _a.vertical;\n\n      var handleMidpoint = _this.getHandleMidpointAndOffset(_this.handleElement, true).handleMidpoint;\n\n      var offsetRatio = (value - min) * tickSizeRatio;\n      var offsetCalc = \"calc(\".concat(formatPercentage(offsetRatio), \" - \").concat(handleMidpoint, \"px)\");\n      return vertical ? {\n        bottom: offsetCalc\n      } : {\n        left: offsetCalc\n      };\n    };\n\n    _this.endHandleMovement = function (event) {\n      _this.handleMoveEndedAt(_this.mouseEventClientOffset(event));\n    };\n\n    _this.endHandleTouchMovement = function (event) {\n      _this.handleMoveEndedAt(_this.touchEventClientOffset(event));\n    };\n\n    _this.handleMoveEndedAt = function (clientPixel) {\n      var _a, _b;\n\n      _this.removeDocumentEventListeners();\n\n      _this.setState({\n        isMoving: false\n      }); // always invoke onRelease; changeValue may call onChange if value is different\n\n\n      var finalValue = _this.changeValue(_this.clientToValue(clientPixel));\n\n      (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, finalValue);\n    };\n\n    _this.handleHandleMovement = function (event) {\n      _this.handleMovedTo(_this.mouseEventClientOffset(event));\n    };\n\n    _this.handleHandleTouchMovement = function (event) {\n      _this.handleMovedTo(_this.touchEventClientOffset(event));\n    };\n\n    _this.handleMovedTo = function (clientPixel) {\n      if (_this.state.isMoving && !_this.props.disabled) {\n        _this.changeValue(_this.clientToValue(clientPixel));\n      }\n    };\n\n    _this.handleKeyDown = function (event) {\n      var _a = _this.props,\n          stepSize = _a.stepSize,\n          value = _a.value; // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n\n      /* eslint-disable-next-line deprecation/deprecation */\n\n      var which = event.which;\n\n      if (which === Keys.ARROW_DOWN || which === Keys.ARROW_LEFT) {\n        _this.changeValue(value - stepSize); // this key event has been handled! prevent browser scroll on up/down\n\n\n        event.preventDefault();\n      } else if (which === Keys.ARROW_UP || which === Keys.ARROW_RIGHT) {\n        _this.changeValue(value + stepSize);\n\n        event.preventDefault();\n      }\n    };\n\n    _this.handleKeyUp = function (event) {\n      var _a, _b; // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n\n      /* eslint-disable-next-line deprecation/deprecation */\n\n\n      if ([Keys.ARROW_UP, Keys.ARROW_DOWN, Keys.ARROW_LEFT, Keys.ARROW_RIGHT].indexOf(event.which) >= 0) {\n        (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.value);\n      }\n    };\n\n    return _this;\n  }\n\n  Handle.prototype.componentDidMount = function () {\n    // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n    // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n    this.forceUpdate();\n  };\n\n  Handle.prototype.render = function () {\n    var _a;\n\n    var _b = this.props,\n        className = _b.className,\n        disabled = _b.disabled,\n        label = _b.label;\n    var isMoving = this.state.isMoving;\n    return React.createElement(\"span\", {\n      className: classNames(Classes.SLIDER_HANDLE, (_a = {}, _a[Classes.ACTIVE] = isMoving, _a), className),\n      onKeyDown: disabled ? undefined : this.handleKeyDown,\n      onKeyUp: disabled ? undefined : this.handleKeyUp,\n      onMouseDown: disabled ? undefined : this.beginHandleMovement,\n      onTouchStart: disabled ? undefined : this.beginHandleTouchMovement,\n      ref: this.refHandlers.handle,\n      style: this.getStyleProperties(),\n      tabIndex: 0\n    }, label == null ? null : React.createElement(\"span\", {\n      className: Classes.SLIDER_LABEL\n    }, label));\n  };\n\n  Handle.prototype.componentWillUnmount = function () {\n    this.removeDocumentEventListeners();\n  };\n  /** Convert client pixel to value between min and max. */\n\n\n  Handle.prototype.clientToValue = function (clientPixel) {\n    var _a = this.props,\n        stepSize = _a.stepSize,\n        tickSize = _a.tickSize,\n        value = _a.value,\n        vertical = _a.vertical;\n\n    if (this.handleElement == null) {\n      return value;\n    } // #1769: this logic doesn't work perfectly when the tick size is\n    // smaller than the handle size; it may be off by a tick or two.\n\n\n    var clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n    var handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n    var pixelDelta = clientPixelNormalized - handleCenterPixel;\n\n    if (isNaN(pixelDelta)) {\n      return value;\n    } // convert pixels to range value in increments of `stepSize`\n\n\n    return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n  };\n\n  Handle.prototype.mouseEventClientOffset = function (event) {\n    return this.props.vertical ? event.clientY : event.clientX;\n  };\n\n  Handle.prototype.touchEventClientOffset = function (event) {\n    var touch = event.changedTouches[0];\n    return this.props.vertical ? touch.clientY : touch.clientX;\n  };\n\n  Handle.prototype.validateProps = function (props) {\n    for (var _i = 0, NUMBER_PROPS_1 = NUMBER_PROPS; _i < NUMBER_PROPS_1.length; _i++) {\n      var prop = NUMBER_PROPS_1[_i];\n\n      if (typeof props[prop] !== \"number\") {\n        throw new Error(\"[Blueprint] <Handle> requires number value for \".concat(prop, \" prop\"));\n      }\n    }\n  };\n  /** Clamp value and invoke callback if it differs from current value */\n\n\n  Handle.prototype.changeValue = function (newValue, callback) {\n    if (callback === void 0) {\n      callback = this.props.onChange;\n    }\n\n    newValue = this.clamp(newValue);\n\n    if (!isNaN(newValue) && this.props.value !== newValue) {\n      callback === null || callback === void 0 ? void 0 : callback(newValue);\n    }\n\n    return newValue;\n  };\n  /** Clamp value between min and max props */\n\n\n  Handle.prototype.clamp = function (value) {\n    return clamp(value, this.props.min, this.props.max);\n  };\n\n  Handle.prototype.getHandleElementCenterPixel = function (handleElement) {\n    var _a = this.getHandleMidpointAndOffset(handleElement),\n        handleMidpoint = _a.handleMidpoint,\n        handleOffset = _a.handleOffset;\n\n    return handleOffset + handleMidpoint;\n  };\n\n  Handle.prototype.getHandleMidpointAndOffset = function (handleElement, useOppositeDimension) {\n    if (useOppositeDimension === void 0) {\n      useOppositeDimension = false;\n    }\n\n    if (handleElement == null) {\n      return {\n        handleMidpoint: 0,\n        handleOffset: 0\n      };\n    }\n\n    var vertical = this.props.vertical; // getBoundingClientRect().height includes border size; clientHeight does not.\n\n    var handleRect = handleElement.getBoundingClientRect();\n    var sizeKey = vertical ? useOppositeDimension ? \"width\" : \"height\" : useOppositeDimension ? \"height\" : \"width\"; // \"bottom\" value seems to be consistently incorrect, so explicitly\n    // calculate it using the window offset instead.\n\n    var handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n    return {\n      handleMidpoint: handleRect[sizeKey] / 2,\n      handleOffset: handleOffset\n    };\n  };\n\n  Handle.prototype.removeDocumentEventListeners = function () {\n    document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n    document.removeEventListener(\"mouseup\", this.endHandleMovement);\n    document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n    document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n    document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n  };\n\n  Handle.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".SliderHandle\");\n  return Handle;\n}(AbstractPureComponent2);\n\nexport { Handle };","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","Keys","DISPLAYNAME_PREFIX","clamp","formatPercentage","NUMBER_PROPS","__extends","_this","isMoving","handle","el","handleElement","event","document","addEventListener","handleHandleMovement","endHandleMovement","setState","changeValue","clientToValue","mouseEventClientOffset","handleHandleTouchMovement","endHandleTouchMovement","touchEventClientOffset","props","_b","min","tickSizeRatio","value","vertical","getHandleMidpointAndOffset","handleMidpoint","offsetRatio","offsetCalc","concat","bottom","left","handleMoveEndedAt","clientPixel","removeDocumentEventListeners","finalValue","onRelease","handleMovedTo","state","disabled","stepSize","which","ARROW_DOWN","ARROW_LEFT","preventDefault","ARROW_UP","ARROW_RIGHT","indexOf","Handle","forceUpdate","className","label","SLIDER_HANDLE","_a","ACTIVE","onKeyDown","undefined","handleKeyDown","onKeyUp","handleKeyUp","onMouseDown","beginHandleMovement","onTouchStart","beginHandleTouchMovement","ref","refHandlers","style","getStyleProperties","tabIndex","SLIDER_LABEL","tickSize","clientPixelNormalized","window","innerHeight","handleCenterPixel","getHandleElementCenterPixel","pixelDelta","isNaN","Math","round","clientY","clientX","touch","changedTouches","_i","prop","Error","newValue","callback","onChange","max","handleOffset","useOppositeDimension","handleRect","getBoundingClientRect","sizeKey","top","removeEventListener"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/core/src/components/slider/handle.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { HandleProps } from \"./handleProps\";\nimport { formatPercentage } from \"./sliderUtils\";\n\n/**\n * Props for the internal <Handle> component needs some additional info from the parent Slider.\n */\nexport interface IInternalHandleProps extends HandleProps {\n    disabled?: boolean;\n    label: JSX.Element | string | undefined;\n    max: number;\n    min: number;\n    stepSize: number;\n    tickSize: number;\n    tickSizeRatio: number;\n    vertical: boolean;\n}\n\nexport interface IHandleState {\n    /** whether slider handle is currently being dragged */\n    isMoving?: boolean;\n}\n\n// props that require number values, for validation\nconst NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"];\n\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\n\nexport class Handle extends AbstractPureComponent2<IInternalHandleProps, IHandleState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.SliderHandle`;\n\n    public state = {\n        isMoving: false,\n    };\n\n    private handleElement: HTMLElement | null = null;\n\n    private refHandlers = {\n        handle: (el: HTMLSpanElement) => (this.handleElement = el),\n    };\n\n    public componentDidMount() {\n        // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n        // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n        this.forceUpdate();\n    }\n\n    public render() {\n        const { className, disabled, label } = this.props;\n        const { isMoving } = this.state;\n\n        return (\n            <span\n                className={classNames(Classes.SLIDER_HANDLE, { [Classes.ACTIVE]: isMoving }, className)}\n                onKeyDown={disabled ? undefined : this.handleKeyDown}\n                onKeyUp={disabled ? undefined : this.handleKeyUp}\n                onMouseDown={disabled ? undefined : this.beginHandleMovement}\n                onTouchStart={disabled ? undefined : this.beginHandleTouchMovement}\n                ref={this.refHandlers.handle}\n                style={this.getStyleProperties()}\n                tabIndex={0}\n            >\n                {label == null ? null : <span className={Classes.SLIDER_LABEL}>{label}</span>}\n            </span>\n        );\n    }\n\n    public componentWillUnmount() {\n        this.removeDocumentEventListeners();\n    }\n\n    /** Convert client pixel to value between min and max. */\n    public clientToValue(clientPixel: number) {\n        const { stepSize, tickSize, value, vertical } = this.props;\n        if (this.handleElement == null) {\n            return value;\n        }\n\n        // #1769: this logic doesn't work perfectly when the tick size is\n        // smaller than the handle size; it may be off by a tick or two.\n        const clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n        const handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n        const pixelDelta = clientPixelNormalized - handleCenterPixel;\n\n        if (isNaN(pixelDelta)) {\n            return value;\n        }\n        // convert pixels to range value in increments of `stepSize`\n        return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n    }\n\n    public mouseEventClientOffset(event: MouseEvent | React.MouseEvent<HTMLElement>) {\n        return this.props.vertical ? event.clientY : event.clientX;\n    }\n\n    public touchEventClientOffset(event: TouchEvent | React.TouchEvent<HTMLElement>) {\n        const touch = event.changedTouches[0];\n        return this.props.vertical ? touch.clientY : touch.clientX;\n    }\n\n    public beginHandleMovement = (event: MouseEvent | React.MouseEvent<HTMLElement>) => {\n        document.addEventListener(\"mousemove\", this.handleHandleMovement);\n        document.addEventListener(\"mouseup\", this.endHandleMovement);\n        this.setState({ isMoving: true });\n        this.changeValue(this.clientToValue(this.mouseEventClientOffset(event)));\n    };\n\n    public beginHandleTouchMovement = (event: TouchEvent | React.TouchEvent<HTMLElement>) => {\n        document.addEventListener(\"touchmove\", this.handleHandleTouchMovement);\n        document.addEventListener(\"touchend\", this.endHandleTouchMovement);\n        document.addEventListener(\"touchcancel\", this.endHandleTouchMovement);\n        this.setState({ isMoving: true });\n        this.changeValue(this.clientToValue(this.touchEventClientOffset(event)));\n    };\n\n    protected validateProps(props: IInternalHandleProps) {\n        for (const prop of NUMBER_PROPS) {\n            if (typeof (props as any)[prop] !== \"number\") {\n                throw new Error(`[Blueprint] <Handle> requires number value for ${prop} prop`);\n            }\n        }\n    }\n\n    private getStyleProperties = (): React.CSSProperties => {\n        if (this.handleElement == null) {\n            return {};\n        }\n\n        // The handle midpoint of RangeSlider is actually shifted by a margin to\n        // be on the edge of the visible handle element. Because the midpoint\n        // calculation does not take this margin into account, we instead\n        // measure the long side (which is equal to the short side plus the\n        // margin).\n\n        const { min = 0, tickSizeRatio, value, vertical } = this.props;\n        const { handleMidpoint } = this.getHandleMidpointAndOffset(this.handleElement, true);\n        const offsetRatio = (value - min) * tickSizeRatio;\n        const offsetCalc = `calc(${formatPercentage(offsetRatio)} - ${handleMidpoint}px)`;\n        return vertical ? { bottom: offsetCalc } : { left: offsetCalc };\n    };\n\n    private endHandleMovement = (event: MouseEvent) => {\n        this.handleMoveEndedAt(this.mouseEventClientOffset(event));\n    };\n\n    private endHandleTouchMovement = (event: TouchEvent) => {\n        this.handleMoveEndedAt(this.touchEventClientOffset(event));\n    };\n\n    private handleMoveEndedAt = (clientPixel: number) => {\n        this.removeDocumentEventListeners();\n        this.setState({ isMoving: false });\n        // always invoke onRelease; changeValue may call onChange if value is different\n        const finalValue = this.changeValue(this.clientToValue(clientPixel));\n        this.props.onRelease?.(finalValue);\n    };\n\n    private handleHandleMovement = (event: MouseEvent) => {\n        this.handleMovedTo(this.mouseEventClientOffset(event));\n    };\n\n    private handleHandleTouchMovement = (event: TouchEvent) => {\n        this.handleMovedTo(this.touchEventClientOffset(event));\n    };\n\n    private handleMovedTo = (clientPixel: number) => {\n        if (this.state.isMoving && !this.props.disabled) {\n            this.changeValue(this.clientToValue(clientPixel));\n        }\n    };\n\n    private handleKeyDown = (event: React.KeyboardEvent<HTMLSpanElement>) => {\n        const { stepSize, value } = this.props;\n        // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        /* eslint-disable-next-line deprecation/deprecation */\n        const { which } = event;\n        if (which === Keys.ARROW_DOWN || which === Keys.ARROW_LEFT) {\n            this.changeValue(value - stepSize);\n            // this key event has been handled! prevent browser scroll on up/down\n            event.preventDefault();\n        } else if (which === Keys.ARROW_UP || which === Keys.ARROW_RIGHT) {\n            this.changeValue(value + stepSize);\n            event.preventDefault();\n        }\n    };\n\n    private handleKeyUp = (event: React.KeyboardEvent<HTMLSpanElement>) => {\n        // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        /* eslint-disable-next-line deprecation/deprecation */\n        if ([Keys.ARROW_UP, Keys.ARROW_DOWN, Keys.ARROW_LEFT, Keys.ARROW_RIGHT].indexOf(event.which) >= 0) {\n            this.props.onRelease?.(this.props.value);\n        }\n    };\n\n    /** Clamp value and invoke callback if it differs from current value */\n    private changeValue(newValue: number, callback = this.props.onChange) {\n        newValue = this.clamp(newValue);\n        if (!isNaN(newValue) && this.props.value !== newValue) {\n            callback?.(newValue);\n        }\n        return newValue;\n    }\n\n    /** Clamp value between min and max props */\n    private clamp(value: number) {\n        return clamp(value, this.props.min, this.props.max);\n    }\n\n    private getHandleElementCenterPixel(handleElement: HTMLElement) {\n        const { handleMidpoint, handleOffset } = this.getHandleMidpointAndOffset(handleElement);\n        return handleOffset + handleMidpoint;\n    }\n\n    private getHandleMidpointAndOffset(handleElement: HTMLElement, useOppositeDimension = false) {\n        if (handleElement == null) {\n            return { handleMidpoint: 0, handleOffset: 0 };\n        }\n\n        const { vertical } = this.props;\n\n        // getBoundingClientRect().height includes border size; clientHeight does not.\n        const handleRect = handleElement.getBoundingClientRect();\n\n        const sizeKey = vertical\n            ? useOppositeDimension\n                ? \"width\"\n                : \"height\"\n            : useOppositeDimension\n            ? \"height\"\n            : \"width\";\n\n        // \"bottom\" value seems to be consistently incorrect, so explicitly\n        // calculate it using the window offset instead.\n        const handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n\n        return { handleMidpoint: handleRect[sizeKey] / 2, handleOffset };\n    }\n\n    private removeDocumentEventListeners() {\n        document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n        document.removeEventListener(\"mouseup\", this.endHandleMovement);\n        document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n        document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n        document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}