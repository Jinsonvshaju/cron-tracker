{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { Browser } from \"../../compatibility\";\nvar BUFFER_WIDTH_DEFAULT = 5;\nvar BUFFER_WIDTH_IE = 30;\n\nvar EditableText =\n/** @class */\nfunction (_super) {\n  __extends(EditableText, _super);\n\n  function EditableText(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.inputElement = null;\n    _this.valueElement = null;\n    _this.refHandlers = {\n      content: function (spanElement) {\n        _this.valueElement = spanElement;\n      },\n      input: function (input) {\n        if (input != null) {\n          _this.inputElement = input; // temporary fix for #3882\n\n          if (!_this.props.alwaysRenderInput) {\n            _this.inputElement.focus();\n          }\n\n          if (_this.state != null && _this.state.isEditing) {\n            var supportsSelection = inputSupportsSelection(input);\n\n            if (supportsSelection) {\n              var length_1 = input.value.length;\n              input.setSelectionRange(_this.props.selectAllOnFocus ? 0 : length_1, length_1);\n            }\n\n            if (!supportsSelection || !_this.props.selectAllOnFocus) {\n              input.scrollLeft = input.scrollWidth;\n            }\n          }\n        }\n      }\n    };\n\n    _this.cancelEditing = function () {\n      var _a, _b, _c, _d;\n\n      var _e = _this.state,\n          lastValue = _e.lastValue,\n          value = _e.value;\n\n      _this.setState({\n        isEditing: false,\n        value: lastValue\n      });\n\n      if (value !== lastValue) {\n        (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, lastValue);\n      }\n\n      (_d = (_c = _this.props).onCancel) === null || _d === void 0 ? void 0 : _d.call(_c, lastValue);\n    };\n\n    _this.toggleEditing = function () {\n      var _a, _b;\n\n      if (_this.state.isEditing) {\n        var value = _this.state.value;\n\n        _this.setState({\n          isEditing: false,\n          lastValue: value\n        });\n\n        (_b = (_a = _this.props).onConfirm) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n      } else if (!_this.props.disabled) {\n        _this.setState({\n          isEditing: true\n        });\n      }\n    };\n\n    _this.handleFocus = function () {\n      var _a = _this.props,\n          alwaysRenderInput = _a.alwaysRenderInput,\n          disabled = _a.disabled,\n          selectAllOnFocus = _a.selectAllOnFocus;\n\n      if (!disabled) {\n        _this.setState({\n          isEditing: true\n        });\n      }\n\n      if (alwaysRenderInput && selectAllOnFocus && _this.inputElement != null) {\n        var length_2 = _this.inputElement.value.length;\n\n        _this.inputElement.setSelectionRange(0, length_2);\n      }\n    };\n\n    _this.handleTextChange = function (event) {\n      var _a, _b;\n\n      var value = event.target.value; // state value should be updated only when uncontrolled\n\n      if (_this.props.value == null) {\n        _this.setState({\n          value: value\n        });\n      }\n\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    };\n\n    _this.handleKeyEvent = function (event) {\n      // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n\n      /* eslint-disable-next-line deprecation/deprecation */\n      var altKey = event.altKey,\n          ctrlKey = event.ctrlKey,\n          metaKey = event.metaKey,\n          shiftKey = event.shiftKey,\n          which = event.which;\n\n      if (which === Keys.ESCAPE) {\n        _this.cancelEditing();\n\n        return;\n      }\n\n      var hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;\n\n      if (which === Keys.ENTER) {\n        // prevent IE11 from full screening with alt + enter\n        // shift + enter adds a newline by default\n        if (altKey || shiftKey) {\n          event.preventDefault();\n        }\n\n        if (_this.props.confirmOnEnterKey && _this.props.multiline) {\n          if (event.target != null && hasModifierKey) {\n            insertAtCaret(event.target, \"\\n\");\n\n            _this.handleTextChange(event);\n          } else {\n            _this.toggleEditing();\n          }\n        } else if (!_this.props.multiline || hasModifierKey) {\n          _this.toggleEditing();\n        }\n      }\n    };\n\n    var value = props.value == null ? props.defaultValue : props.value;\n    _this.state = {\n      inputHeight: 0,\n      inputWidth: 0,\n      isEditing: props.isEditing === true && props.disabled === false,\n      lastValue: value,\n      value: value\n    };\n    return _this;\n  }\n\n  EditableText.prototype.render = function () {\n    var _a;\n\n    var _b;\n\n    var _c = this.props,\n        alwaysRenderInput = _c.alwaysRenderInput,\n        disabled = _c.disabled,\n        multiline = _c.multiline,\n        contentId = _c.contentId;\n    var value = (_b = this.props.value) !== null && _b !== void 0 ? _b : this.state.value;\n    var hasValue = value != null && value !== \"\";\n    var classes = classNames(Classes.EDITABLE_TEXT, Classes.intentClass(this.props.intent), (_a = {}, _a[Classes.DISABLED] = disabled, _a[Classes.EDITABLE_TEXT_EDITING] = this.state.isEditing, _a[Classes.EDITABLE_TEXT_PLACEHOLDER] = !hasValue, _a[Classes.MULTILINE] = multiline, _a), this.props.className);\n    var contentStyle;\n\n    if (multiline) {\n      // set height only in multiline mode when not editing\n      // otherwise we're measuring this element to determine appropriate height of text\n      contentStyle = {\n        height: !this.state.isEditing ? this.state.inputHeight : undefined\n      };\n    } else {\n      // minWidth only applies in single line mode (multiline == width 100%)\n      contentStyle = {\n        height: this.state.inputHeight,\n        lineHeight: this.state.inputHeight != null ? \"\".concat(this.state.inputHeight, \"px\") : undefined,\n        minWidth: this.props.minWidth\n      };\n    } // If we are always rendering an input, then NEVER make the container div focusable.\n    // Otherwise, make container div focusable when not editing, so it can still be tabbed\n    // to focus (when the input is rendered, it is itself focusable so container div doesn't need to be)\n\n\n    var tabIndex = alwaysRenderInput || this.state.isEditing || disabled ? undefined : 0; // we need the contents to be rendered while editing so that we can measure their height\n    // and size the container element responsively\n\n    var shouldHideContents = alwaysRenderInput && !this.state.isEditing;\n    var spanProps = contentId != null ? {\n      id: contentId\n    } : {};\n    return React.createElement(\"div\", {\n      className: classes,\n      onFocus: this.handleFocus,\n      tabIndex: tabIndex\n    }, alwaysRenderInput || this.state.isEditing ? this.renderInput(value) : undefined, shouldHideContents ? undefined : React.createElement(\"span\", __assign({}, spanProps, {\n      className: Classes.EDITABLE_TEXT_CONTENT,\n      ref: this.refHandlers.content,\n      style: contentStyle\n    }), hasValue ? value : this.props.placeholder));\n  };\n\n  EditableText.prototype.componentDidMount = function () {\n    this.updateInputDimensions();\n  };\n\n  EditableText.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b;\n\n    var newState = {}; // allow setting the value to undefined/null in controlled mode\n\n    if (this.props.value !== prevProps.value && (prevProps.value != null || this.props.value != null)) {\n      newState.value = this.props.value;\n    }\n\n    if (this.props.isEditing != null && this.props.isEditing !== prevProps.isEditing) {\n      newState.isEditing = this.props.isEditing;\n    }\n\n    if (this.props.disabled || this.props.disabled == null && prevProps.disabled) {\n      newState.isEditing = false;\n    }\n\n    this.setState(newState);\n\n    if (this.state.isEditing && !prevState.isEditing) {\n      (_b = (_a = this.props).onEdit) === null || _b === void 0 ? void 0 : _b.call(_a, this.state.value);\n    } // updateInputDimensions is an expensive method. Call it only when the props\n    // it depends on change\n\n\n    if (this.state.value !== prevState.value || this.props.alwaysRenderInput !== prevProps.alwaysRenderInput || this.props.maxLines !== prevProps.maxLines || this.props.minLines !== prevProps.minLines || this.props.minWidth !== prevProps.minWidth || this.props.multiline !== prevProps.multiline) {\n      this.updateInputDimensions();\n    }\n  };\n\n  EditableText.prototype.renderInput = function (value) {\n    var _a = this.props,\n        disabled = _a.disabled,\n        maxLength = _a.maxLength,\n        multiline = _a.multiline,\n        type = _a.type,\n        placeholder = _a.placeholder;\n    var props = {\n      className: Classes.EDITABLE_TEXT_INPUT,\n      disabled: disabled,\n      maxLength: maxLength,\n      onBlur: this.toggleEditing,\n      onChange: this.handleTextChange,\n      onKeyDown: this.handleKeyEvent,\n      placeholder: placeholder,\n      value: value\n    };\n    var _b = this.state,\n        inputHeight = _b.inputHeight,\n        inputWidth = _b.inputWidth;\n\n    if (inputHeight !== 0 && inputWidth !== 0) {\n      props.style = {\n        height: inputHeight,\n        lineHeight: !multiline && inputHeight != null ? \"\".concat(inputHeight, \"px\") : undefined,\n        width: multiline ? \"100%\" : inputWidth\n      };\n    }\n\n    return multiline ? React.createElement(\"textarea\", __assign({\n      ref: this.refHandlers.input\n    }, props)) : React.createElement(\"input\", __assign({\n      ref: this.refHandlers.input,\n      type: type\n    }, props));\n  };\n\n  EditableText.prototype.updateInputDimensions = function () {\n    if (this.valueElement != null) {\n      var _a = this.props,\n          maxLines = _a.maxLines,\n          minLines = _a.minLines,\n          minWidth = _a.minWidth,\n          multiline = _a.multiline;\n      var _b = this.valueElement,\n          parentElement_1 = _b.parentElement,\n          textContent = _b.textContent;\n      var _c = this.valueElement,\n          scrollHeight_1 = _c.scrollHeight,\n          scrollWidth = _c.scrollWidth;\n      var lineHeight = getLineHeight(this.valueElement); // add one line to computed <span> height if text ends in newline\n      // because <span> collapses that trailing whitespace but <textarea> shows it\n\n      if (multiline && this.state.isEditing && /\\n$/.test(textContent !== null && textContent !== void 0 ? textContent : \"\")) {\n        scrollHeight_1 += lineHeight;\n      }\n\n      if (lineHeight > 0) {\n        // line height could be 0 if the isNaN block from getLineHeight kicks in\n        scrollHeight_1 = clamp(scrollHeight_1, minLines * lineHeight, maxLines * lineHeight);\n      } // Chrome's input caret height misaligns text so the line-height must be larger than font-size.\n      // The computed scrollHeight must also account for a larger inherited line-height from the parent.\n\n\n      scrollHeight_1 = Math.max(scrollHeight_1, getFontSize(this.valueElement) + 1, getLineHeight(parentElement_1)); // Need to add a small buffer so text does not shift prior to resizing, causing an infinite loop.\n      // IE needs a larger buffer than other browsers.\n\n      scrollWidth += Browser.isInternetExplorer() ? BUFFER_WIDTH_IE : BUFFER_WIDTH_DEFAULT;\n      this.setState({\n        inputHeight: scrollHeight_1,\n        inputWidth: Math.max(scrollWidth, minWidth)\n      }); // synchronizes the ::before pseudo-element's height while editing for Chrome 53\n\n      if (multiline && this.state.isEditing) {\n        this.setTimeout(function () {\n          return parentElement_1.style.height = \"\".concat(scrollHeight_1, \"px\");\n        });\n      }\n    }\n  };\n\n  EditableText.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".EditableText\");\n  EditableText.defaultProps = {\n    alwaysRenderInput: false,\n    confirmOnEnterKey: false,\n    defaultValue: \"\",\n    disabled: false,\n    maxLines: Infinity,\n    minLines: 1,\n    minWidth: 80,\n    multiline: false,\n    placeholder: \"Click to Edit\",\n    type: \"text\"\n  };\n  return EditableText;\n}(AbstractPureComponent2);\n\nexport { EditableText };\n\nfunction getFontSize(element) {\n  var fontSize = getComputedStyle(element).fontSize;\n  return fontSize === \"\" ? 0 : parseInt(fontSize.slice(0, -2), 10);\n}\n\nfunction getLineHeight(element) {\n  // getComputedStyle() => 18.0001px => 18\n  var lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10); // this check will be true if line-height is a keyword like \"normal\"\n\n  if (isNaN(lineHeight)) {\n    // @see http://stackoverflow.com/a/18430767/6342931\n    var line = document.createElement(\"span\");\n    line.innerHTML = \"<br>\";\n    element.appendChild(line);\n    var singleLineHeight = element.offsetHeight;\n    line.innerHTML = \"<br><br>\";\n    var doubleLineHeight = element.offsetHeight;\n    element.removeChild(line); // this can return 0 in edge cases\n\n    lineHeight = doubleLineHeight - singleLineHeight;\n  }\n\n  return lineHeight;\n}\n\nfunction insertAtCaret(el, text) {\n  var selectionEnd = el.selectionEnd,\n      selectionStart = el.selectionStart,\n      value = el.value;\n\n  if (selectionStart >= 0) {\n    var before_1 = value.substring(0, selectionStart);\n    var after_1 = value.substring(selectionEnd, value.length);\n    var len = text.length;\n    el.value = \"\".concat(before_1).concat(text).concat(after_1);\n    el.selectionStart = selectionStart + len;\n    el.selectionEnd = selectionStart + len;\n  }\n}\n\nfunction inputSupportsSelection(input) {\n  switch (input.type) {\n    // HTMLTextAreaElement\n    case \"textarea\":\n      return true;\n    // HTMLInputElement\n    // see https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n\n    case \"text\":\n    case \"search\":\n    case \"tel\":\n    case \"url\":\n    case \"password\":\n      return true;\n\n    default:\n      return false;\n  }\n}","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","Keys","DISPLAYNAME_PREFIX","clamp","Browser","BUFFER_WIDTH_DEFAULT","BUFFER_WIDTH_IE","__extends","props","context","_super","_this","content","spanElement","valueElement","input","inputElement","alwaysRenderInput","focus","state","isEditing","supportsSelection","inputSupportsSelection","value","length","setSelectionRange","selectAllOnFocus","length_1","scrollLeft","scrollWidth","lastValue","setState","onChange","_b","onCancel","_d","onConfirm","disabled","length_2","event","target","ctrlKey","metaKey","shiftKey","which","ESCAPE","cancelEditing","hasModifierKey","altKey","ENTER","preventDefault","confirmOnEnterKey","multiline","insertAtCaret","handleTextChange","toggleEditing","defaultValue","inputHeight","inputWidth","EditableText","contentId","hasValue","classes","EDITABLE_TEXT","intentClass","intent","_a","DISABLED","EDITABLE_TEXT_EDITING","EDITABLE_TEXT_PLACEHOLDER","MULTILINE","className","contentStyle","height","undefined","lineHeight","minWidth","tabIndex","shouldHideContents","spanProps","id","onFocus","handleFocus","renderInput","EDITABLE_TEXT_CONTENT","ref","refHandlers","style","placeholder","updateInputDimensions","prevProps","prevState","newState","onEdit","maxLines","minLines","maxLength","type","EDITABLE_TEXT_INPUT","onBlur","onKeyDown","handleKeyEvent","width","parentElement_1","textContent","scrollHeight_1","getLineHeight","test","Math","max","getFontSize","isInternetExplorer","setTimeout","Infinity","element","fontSize","getComputedStyle","parseInt","slice","isNaN","line","document","createElement","innerHTML","appendChild","singleLineHeight","offsetHeight","doubleLineHeight","removeChild","el","text","selectionStart","before_1","substring","after_1","selectionEnd","len","concat"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/core/src/components/editable-text/editableText.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX, IntentProps, Props } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { Browser } from \"../../compatibility\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type EditableTextProps = IEditableTextProps;\n/** @deprecated use EditableTextProps */\nexport interface IEditableTextProps extends IntentProps, Props {\n    /**\n     * EXPERIMENTAL FEATURE.\n     *\n     * When true, this forces the component to _always_ render an editable input (or textarea)\n     * both when the component is focussed and unfocussed, instead of the component's default\n     * behavior of switching between a text span and a text input upon interaction.\n     *\n     * This behavior can help in certain applications where, for example, a custom right-click\n     * context menu is used to supply clipboard copy and paste functionality.\n     *\n     * @default false\n     */\n    alwaysRenderInput?: boolean;\n\n    /**\n     * If `true` and in multiline mode, the `enter` key will trigger onConfirm and `mod+enter`\n     * will insert a newline. If `false`, the key bindings are inverted such that `enter`\n     * adds a newline.\n     *\n     * @default false\n     */\n    confirmOnEnterKey?: boolean;\n\n    /** Default text value of uncontrolled input. */\n    defaultValue?: string;\n\n    /**\n     * Whether the text can be edited.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /** Whether the component is currently being edited. */\n    isEditing?: boolean;\n\n    /** Maximum number of characters allowed. Unlimited by default. */\n    maxLength?: number;\n\n    /** Minimum width in pixels of the input, when not `multiline`. */\n    minWidth?: number;\n\n    /**\n     * Whether the component supports multiple lines of text.\n     * This prop should not be changed during the component's lifetime.\n     *\n     * @default false\n     */\n    multiline?: boolean;\n\n    /**\n     * Maximum number of lines before scrolling begins, when `multiline`.\n     */\n    maxLines?: number;\n\n    /**\n     * Minimum number of lines (essentially minimum height), when `multiline`.\n     *\n     * @default 1\n     */\n    minLines?: number;\n\n    /**\n     * Placeholder text when there is no value.\n     *\n     * @default \"Click to Edit\"\n     */\n    placeholder?: string;\n\n    /**\n     * Whether the entire text field should be selected on focus.\n     * If `false`, the cursor is placed at the end of the text.\n     * This prop is ignored on inputs with type other then text, search, url, tel and password. See https://html.spec.whatwg.org/multipage/input.html#do-not-apply for details.\n     *\n     * @default false\n     */\n    selectAllOnFocus?: boolean;\n\n    /**\n     * The type of input that should be shown, when not `multiline`.\n     */\n    type?: string;\n\n    /** Text value of controlled input. */\n    value?: string;\n\n    /** ID attribute to pass to the underlying element that contains the text contents. This allows for referencing via aria attributes */\n    contentId?: string;\n\n    /** Callback invoked when user cancels input with the `esc` key. Receives last confirmed value. */\n    onCancel?(value: string): void;\n\n    /** Callback invoked when user changes input in any way. */\n    onChange?(value: string): void;\n\n    /** Callback invoked when user confirms value with `enter` key or by blurring input. */\n    onConfirm?(value: string): void;\n\n    /** Callback invoked after the user enters edit mode. */\n    onEdit?(value: string | undefined): void;\n}\n\nexport interface IEditableTextState {\n    /** Pixel height of the input, measured from span size */\n    inputHeight?: number;\n    /** Pixel width of the input, measured from span size */\n    inputWidth?: number;\n    /** Whether the value is currently being edited */\n    isEditing?: boolean;\n    /** The last confirmed value */\n    lastValue?: string;\n    /** The controlled input value, may be different from prop during editing */\n    value?: string;\n}\n\nconst BUFFER_WIDTH_DEFAULT = 5;\nconst BUFFER_WIDTH_IE = 30;\n\nexport class EditableText extends AbstractPureComponent2<EditableTextProps, IEditableTextState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.EditableText`;\n\n    public static defaultProps: EditableTextProps = {\n        alwaysRenderInput: false,\n        confirmOnEnterKey: false,\n        defaultValue: \"\",\n        disabled: false,\n        maxLines: Infinity,\n        minLines: 1,\n        minWidth: 80,\n        multiline: false,\n        placeholder: \"Click to Edit\",\n        type: \"text\",\n    };\n\n    private inputElement: HTMLInputElement | HTMLTextAreaElement | null = null;\n\n    private valueElement: HTMLSpanElement | null = null;\n\n    private refHandlers = {\n        content: (spanElement: HTMLSpanElement | null) => {\n            this.valueElement = spanElement;\n        },\n        input: (input: HTMLInputElement | HTMLTextAreaElement | null) => {\n            if (input != null) {\n                this.inputElement = input;\n\n                // temporary fix for #3882\n                if (!this.props.alwaysRenderInput) {\n                    this.inputElement.focus();\n                }\n\n                if (this.state != null && this.state.isEditing) {\n                    const supportsSelection = inputSupportsSelection(input);\n                    if (supportsSelection) {\n                        const { length } = input.value;\n                        input.setSelectionRange(this.props.selectAllOnFocus ? 0 : length, length);\n                    }\n                    if (!supportsSelection || !this.props.selectAllOnFocus) {\n                        input.scrollLeft = input.scrollWidth;\n                    }\n                }\n            }\n        },\n    };\n\n    public constructor(props: EditableTextProps, context?: any) {\n        super(props, context);\n\n        const value = props.value == null ? props.defaultValue : props.value;\n        this.state = {\n            inputHeight: 0,\n            inputWidth: 0,\n            isEditing: props.isEditing === true && props.disabled === false,\n            lastValue: value,\n            value,\n        };\n    }\n\n    public render() {\n        const { alwaysRenderInput, disabled, multiline, contentId } = this.props;\n        const value = this.props.value ?? this.state.value;\n        const hasValue = value != null && value !== \"\";\n\n        const classes = classNames(\n            Classes.EDITABLE_TEXT,\n            Classes.intentClass(this.props.intent),\n            {\n                [Classes.DISABLED]: disabled,\n                [Classes.EDITABLE_TEXT_EDITING]: this.state.isEditing,\n                [Classes.EDITABLE_TEXT_PLACEHOLDER]: !hasValue,\n                [Classes.MULTILINE]: multiline,\n            },\n            this.props.className,\n        );\n\n        let contentStyle: React.CSSProperties;\n        if (multiline) {\n            // set height only in multiline mode when not editing\n            // otherwise we're measuring this element to determine appropriate height of text\n            contentStyle = { height: !this.state.isEditing ? this.state.inputHeight : undefined };\n        } else {\n            // minWidth only applies in single line mode (multiline == width 100%)\n            contentStyle = {\n                height: this.state.inputHeight,\n                lineHeight: this.state.inputHeight != null ? `${this.state.inputHeight}px` : undefined,\n                minWidth: this.props.minWidth,\n            };\n        }\n\n        // If we are always rendering an input, then NEVER make the container div focusable.\n        // Otherwise, make container div focusable when not editing, so it can still be tabbed\n        // to focus (when the input is rendered, it is itself focusable so container div doesn't need to be)\n        const tabIndex = alwaysRenderInput || this.state.isEditing || disabled ? undefined : 0;\n\n        // we need the contents to be rendered while editing so that we can measure their height\n        // and size the container element responsively\n        const shouldHideContents = alwaysRenderInput && !this.state.isEditing;\n\n        const spanProps: React.HTMLProps<HTMLSpanElement> = contentId != null ? { id: contentId } : {};\n\n        return (\n            <div className={classes} onFocus={this.handleFocus} tabIndex={tabIndex}>\n                {alwaysRenderInput || this.state.isEditing ? this.renderInput(value) : undefined}\n                {shouldHideContents ? undefined : (\n                    <span\n                        {...spanProps}\n                        className={Classes.EDITABLE_TEXT_CONTENT}\n                        ref={this.refHandlers.content}\n                        style={contentStyle}\n                    >\n                        {hasValue ? value : this.props.placeholder}\n                    </span>\n                )}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateInputDimensions();\n    }\n\n    public componentDidUpdate(prevProps: EditableTextProps, prevState: IEditableTextState) {\n        const newState: IEditableTextState = {};\n        // allow setting the value to undefined/null in controlled mode\n        if (this.props.value !== prevProps.value && (prevProps.value != null || this.props.value != null)) {\n            newState.value = this.props.value;\n        }\n        if (this.props.isEditing != null && this.props.isEditing !== prevProps.isEditing) {\n            newState.isEditing = this.props.isEditing;\n        }\n        if (this.props.disabled || (this.props.disabled == null && prevProps.disabled)) {\n            newState.isEditing = false;\n        }\n\n        this.setState(newState);\n\n        if (this.state.isEditing && !prevState.isEditing) {\n            this.props.onEdit?.(this.state.value);\n        }\n        // updateInputDimensions is an expensive method. Call it only when the props\n        // it depends on change\n        if (\n            this.state.value !== prevState.value ||\n            this.props.alwaysRenderInput !== prevProps.alwaysRenderInput ||\n            this.props.maxLines !== prevProps.maxLines ||\n            this.props.minLines !== prevProps.minLines ||\n            this.props.minWidth !== prevProps.minWidth ||\n            this.props.multiline !== prevProps.multiline\n        ) {\n            this.updateInputDimensions();\n        }\n    }\n\n    public cancelEditing = () => {\n        const { lastValue, value } = this.state;\n        this.setState({ isEditing: false, value: lastValue });\n        if (value !== lastValue) {\n            this.props.onChange?.(lastValue!);\n        }\n        this.props.onCancel?.(lastValue!);\n    };\n\n    public toggleEditing = () => {\n        if (this.state.isEditing) {\n            const { value } = this.state;\n            this.setState({ isEditing: false, lastValue: value });\n            this.props.onConfirm?.(value!);\n        } else if (!this.props.disabled) {\n            this.setState({ isEditing: true });\n        }\n    };\n\n    private handleFocus = () => {\n        const { alwaysRenderInput, disabled, selectAllOnFocus } = this.props;\n\n        if (!disabled) {\n            this.setState({ isEditing: true });\n        }\n\n        if (alwaysRenderInput && selectAllOnFocus && this.inputElement != null) {\n            const { length } = this.inputElement.value;\n            this.inputElement.setSelectionRange(0, length);\n        }\n    };\n\n    private handleTextChange = (event: React.FormEvent<HTMLElement>) => {\n        const value = (event.target as HTMLInputElement).value;\n        // state value should be updated only when uncontrolled\n        if (this.props.value == null) {\n            this.setState({ value });\n        }\n        this.props.onChange?.(value);\n    };\n\n    private handleKeyEvent = (event: React.KeyboardEvent<HTMLElement>) => {\n        // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        /* eslint-disable-next-line deprecation/deprecation */\n        const { altKey, ctrlKey, metaKey, shiftKey, which } = event;\n        if (which === Keys.ESCAPE) {\n            this.cancelEditing();\n            return;\n        }\n\n        const hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;\n        if (which === Keys.ENTER) {\n            // prevent IE11 from full screening with alt + enter\n            // shift + enter adds a newline by default\n            if (altKey || shiftKey) {\n                event.preventDefault();\n            }\n\n            if (this.props.confirmOnEnterKey && this.props.multiline) {\n                if (event.target != null && hasModifierKey) {\n                    insertAtCaret(event.target as HTMLTextAreaElement, \"\\n\");\n                    this.handleTextChange(event);\n                } else {\n                    this.toggleEditing();\n                }\n            } else if (!this.props.multiline || hasModifierKey) {\n                this.toggleEditing();\n            }\n        }\n    };\n\n    private renderInput(value: string | undefined) {\n        const { disabled, maxLength, multiline, type, placeholder } = this.props;\n        const props: React.InputHTMLAttributes<HTMLInputElement | HTMLTextAreaElement> = {\n            className: Classes.EDITABLE_TEXT_INPUT,\n            disabled,\n            maxLength,\n            onBlur: this.toggleEditing,\n            onChange: this.handleTextChange,\n            onKeyDown: this.handleKeyEvent,\n            placeholder,\n            value,\n        };\n\n        const { inputHeight, inputWidth } = this.state;\n        if (inputHeight !== 0 && inputWidth !== 0) {\n            props.style = {\n                height: inputHeight,\n                lineHeight: !multiline && inputHeight != null ? `${inputHeight}px` : undefined,\n                width: multiline ? \"100%\" : inputWidth,\n            };\n        }\n\n        return multiline ? (\n            <textarea ref={this.refHandlers.input} {...props} />\n        ) : (\n            <input ref={this.refHandlers.input} type={type} {...props} />\n        );\n    }\n\n    private updateInputDimensions() {\n        if (this.valueElement != null) {\n            const { maxLines, minLines, minWidth, multiline } = this.props;\n            const { parentElement, textContent } = this.valueElement;\n            let { scrollHeight, scrollWidth } = this.valueElement;\n            const lineHeight = getLineHeight(this.valueElement);\n            // add one line to computed <span> height if text ends in newline\n            // because <span> collapses that trailing whitespace but <textarea> shows it\n            if (multiline && this.state.isEditing && /\\n$/.test(textContent ?? \"\")) {\n                scrollHeight += lineHeight;\n            }\n            if (lineHeight > 0) {\n                // line height could be 0 if the isNaN block from getLineHeight kicks in\n                scrollHeight = clamp(scrollHeight, minLines! * lineHeight, maxLines! * lineHeight);\n            }\n            // Chrome's input caret height misaligns text so the line-height must be larger than font-size.\n            // The computed scrollHeight must also account for a larger inherited line-height from the parent.\n            scrollHeight = Math.max(scrollHeight, getFontSize(this.valueElement) + 1, getLineHeight(parentElement!));\n            // Need to add a small buffer so text does not shift prior to resizing, causing an infinite loop.\n            // IE needs a larger buffer than other browsers.\n            scrollWidth += Browser.isInternetExplorer() ? BUFFER_WIDTH_IE : BUFFER_WIDTH_DEFAULT;\n\n            this.setState({\n                inputHeight: scrollHeight,\n                inputWidth: Math.max(scrollWidth, minWidth!),\n            });\n            // synchronizes the ::before pseudo-element's height while editing for Chrome 53\n            if (multiline && this.state.isEditing) {\n                this.setTimeout(() => (parentElement!.style.height = `${scrollHeight}px`));\n            }\n        }\n    }\n}\n\nfunction getFontSize(element: HTMLElement) {\n    const fontSize = getComputedStyle(element).fontSize;\n    return fontSize === \"\" ? 0 : parseInt(fontSize.slice(0, -2), 10);\n}\n\nfunction getLineHeight(element: HTMLElement) {\n    // getComputedStyle() => 18.0001px => 18\n    let lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10);\n    // this check will be true if line-height is a keyword like \"normal\"\n    if (isNaN(lineHeight)) {\n        // @see http://stackoverflow.com/a/18430767/6342931\n        const line = document.createElement(\"span\");\n        line.innerHTML = \"<br>\";\n        element.appendChild(line);\n        const singleLineHeight = element.offsetHeight;\n        line.innerHTML = \"<br><br>\";\n        const doubleLineHeight = element.offsetHeight;\n        element.removeChild(line);\n        // this can return 0 in edge cases\n        lineHeight = doubleLineHeight - singleLineHeight;\n    }\n    return lineHeight;\n}\n\nfunction insertAtCaret(el: HTMLTextAreaElement, text: string) {\n    const { selectionEnd, selectionStart, value } = el;\n    if (selectionStart >= 0) {\n        const before = value.substring(0, selectionStart);\n        const after = value.substring(selectionEnd, value.length);\n        const len = text.length;\n        el.value = `${before}${text}${after}`;\n        el.selectionStart = selectionStart + len;\n        el.selectionEnd = selectionStart + len;\n    }\n}\n\nfunction inputSupportsSelection(input: HTMLInputElement | HTMLTextAreaElement) {\n    switch (input.type) {\n        // HTMLTextAreaElement\n        case \"textarea\":\n            return true;\n        // HTMLInputElement\n        // see https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n        case \"text\":\n        case \"search\":\n        case \"tel\":\n        case \"url\":\n        case \"password\":\n            return true;\n        default:\n            return false;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}