{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { clamp } from \"../../common/utils\";\n/** Returns the `decimal` number separator based on locale */\n\nfunction getDecimalSeparator(locale) {\n  var testNumber = 1.9;\n  var testText = testNumber.toLocaleString(locale);\n  var one = 1 .toLocaleString(locale);\n  var nine = 9 .toLocaleString(locale);\n  var pattern = \"\".concat(one, \"(.+)\").concat(nine);\n  var result = new RegExp(pattern).exec(testText);\n  return result && result[1] || \".\";\n}\n\nexport function toLocaleString(num, locale) {\n  if (locale === void 0) {\n    locale = \"en-US\";\n  }\n\n  return sanitizeNumericInput(num.toLocaleString(locale), locale);\n}\nexport function clampValue(value, min, max) {\n  // defaultProps won't work if the user passes in null, so just default\n  // to +/- infinity here instead, as a catch-all.\n  var adjustedMin = min != null ? min : -Infinity;\n  var adjustedMax = max != null ? max : Infinity;\n  return clamp(value, adjustedMin, adjustedMax);\n}\nexport function getValueOrEmptyValue(value) {\n  if (value === void 0) {\n    value = \"\";\n  }\n\n  return value.toString();\n}\n/** Transform the localized character (ex. \"\") to a javascript recognizable string number (ex. \"10.99\")  */\n\nfunction transformLocalizedNumberToStringNumber(character, locale) {\n  var charactersMap = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (value) {\n    return value.toLocaleString(locale);\n  });\n  var jsNumber = charactersMap.indexOf(character);\n\n  if (jsNumber !== -1) {\n    return jsNumber;\n  } else {\n    return character;\n  }\n}\n/** Transforms the localized number (ex. \"10,99\") to a javascript recognizable string number (ex. \"10.99\")  */\n\n\nexport function parseStringToStringNumber(value, locale) {\n  var valueAsString = \"\" + value;\n\n  if (parseFloat(valueAsString).toString() === value.toString()) {\n    return value.toString();\n  }\n\n  if (locale !== undefined) {\n    var decimalSeparator = getDecimalSeparator(locale);\n    var sanitizedString = sanitizeNumericInput(valueAsString, locale);\n    return sanitizedString.split(\"\").map(function (character) {\n      return transformLocalizedNumberToStringNumber(character, locale);\n    }).join(\"\").replace(decimalSeparator, \".\");\n  }\n\n  return value.toString();\n}\n/** Returns `true` if the string represents a valid numeric value, like \"1e6\". */\n\nexport function isValueNumeric(value, locale) {\n  // checking if a string is numeric in Typescript is a big pain, because\n  // we can't simply toss a string parameter to isFinite. below is the\n  // essential approach that jQuery uses, which involves subtracting a\n  // parsed numeric value from the string representation of the value. we\n  // need to cast the value to the `any` type to allow this operation\n  // between dissimilar types.\n  var stringToStringNumber = parseStringToStringNumber(value, locale);\n  return value != null && stringToStringNumber - parseFloat(stringToStringNumber) + 1 >= 0;\n}\nexport function isValidNumericKeyboardEvent(e, locale) {\n  // unit tests may not include e.key. don't bother disabling those events.\n  if (e.key == null) {\n    return true;\n  } // allow modified key strokes that may involve letters and other\n  // non-numeric/invalid characters (Cmd + A, Cmd + C, Cmd + V, Cmd + X).\n\n\n  if (e.ctrlKey || e.altKey || e.metaKey) {\n    return true;\n  } // keys that print a single character when pressed have a `key` name of\n  // length 1. every other key has a longer `key` name (e.g. \"Backspace\",\n  // \"ArrowUp\", \"Shift\"). since none of those keys can print a character\n  // to the field--and since they may have important native behaviors\n  // beyond printing a character--we don't want to disable their effects.\n\n\n  var isSingleCharKey = e.key.length === 1;\n\n  if (!isSingleCharKey) {\n    return true;\n  } // now we can simply check that the single character that wants to be printed\n  // is a floating-point number character that we're allowed to print.\n\n\n  return isFloatingPointNumericCharacter(e.key, locale);\n}\n/**\n * A regex that matches a string of length 1 (i.e. a standalone character)\n * if and only if it is a floating-point number character as defined by W3C:\n * https://www.w3.org/TR/2012/WD-html-markup-20120329/datatypes.html#common.data.float\n *\n * Floating-point number characters are the only characters that can be\n * printed within a default input[type=\"number\"]. This component should\n * behave the same way when this.props.allowNumericCharactersOnly = true.\n * See here for the input[type=\"number\"].value spec:\n * https://www.w3.org/TR/2012/WD-html-markup-20120329/input.number.html#input.number.attrs.value\n */\n\nfunction isFloatingPointNumericCharacter(character, locale) {\n  if (locale !== undefined) {\n    var decimalSeparator = getDecimalSeparator(locale).replace(\".\", \"\\\\.\");\n    var numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (value) {\n      return value.toLocaleString(locale);\n    }).join(\"\");\n    var localeFloatingPointNumericCharacterRegex = new RegExp(\"^[Ee\" + numbers + \"\\\\+\\\\-\" + decimalSeparator + \"]$\");\n    return localeFloatingPointNumericCharacterRegex.test(character);\n  } else {\n    var floatingPointNumericCharacterRegex = /^[Ee0-9\\+\\-\\.]$/;\n    return floatingPointNumericCharacterRegex.test(character);\n  }\n}\n/**\n * Round the value to have _up to_ the specified maximum precision.\n *\n * This differs from `toFixed(5)` in that trailing zeroes are not added on\n * more precise values, resulting in shorter strings.\n */\n\n\nexport function toMaxPrecision(value, maxPrecision) {\n  // round the value to have the specified maximum precision (toFixed is the wrong choice,\n  // because it would show trailing zeros in the decimal part out to the specified precision)\n  // source: http://stackoverflow.com/a/18358056/5199574\n  var scaleFactor = Math.pow(10, maxPrecision);\n  return Math.round(value * scaleFactor) / scaleFactor;\n}\n/**\n * Convert Japanese full-width numbers, e.g. 'ï¼•', to ASCII, e.g. '5'\n * This should be called before performing any other numeric string input validation.\n */\n\nfunction convertFullWidthNumbersToAscii(value) {\n  return value.replace(/[\\uFF10-\\uFF19]/g, function (m) {\n    return String.fromCharCode(m.charCodeAt(0) - 0xfee0);\n  });\n}\n/**\n * Convert full-width (Japanese) numbers to ASCII, and strip all characters that are not valid floating-point numeric characters\n */\n\n\nexport function sanitizeNumericInput(value, locale) {\n  var valueChars = convertFullWidthNumbersToAscii(value).split(\"\");\n  var sanitizedValueChars = valueChars.filter(function (valueChar) {\n    return isFloatingPointNumericCharacter(valueChar, locale);\n  });\n  return sanitizedValueChars.join(\"\");\n}","map":{"version":3,"mappings":"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","names":["clamp","getDecimalSeparator","locale","testNumber","testText","toLocaleString","one","nine","pattern","concat","result","RegExp","exec","num","sanitizeNumericInput","clampValue","value","min","max","adjustedMin","Infinity","adjustedMax","getValueOrEmptyValue","toString","transformLocalizedNumberToStringNumber","character","charactersMap","map","jsNumber","indexOf","parseStringToStringNumber","valueAsString","parseFloat","undefined","decimalSeparator","sanitizedString","split","join","replace","isValueNumeric","stringToStringNumber","isValidNumericKeyboardEvent","e","key","ctrlKey","altKey","metaKey","isSingleCharKey","length","isFloatingPointNumericCharacter","numbers","localeFloatingPointNumericCharacterRegex","test","floatingPointNumericCharacterRegex","toMaxPrecision","maxPrecision","scaleFactor","Math","pow","round","convertFullWidthNumbersToAscii","fromCharCode","m","charCodeAt","valueChars","sanitizedValueChars","filter","valueChar"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/core/src/components/forms/numericInputUtils.ts"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { clamp } from \"../../common/utils\";\n\n/** Returns the `decimal` number separator based on locale */\nfunction getDecimalSeparator(locale: string) {\n    const testNumber = 1.9;\n    const testText = testNumber.toLocaleString(locale);\n    const one = (1).toLocaleString(locale);\n    const nine = (9).toLocaleString(locale);\n    const pattern = `${one}(.+)${nine}`;\n\n    const result = new RegExp(pattern).exec(testText);\n\n    return (result && result[1]) || \".\";\n}\n\nexport function toLocaleString(num: number, locale: string = \"en-US\") {\n    return sanitizeNumericInput(num.toLocaleString(locale), locale);\n}\n\nexport function clampValue(value: number, min?: number, max?: number) {\n    // defaultProps won't work if the user passes in null, so just default\n    // to +/- infinity here instead, as a catch-all.\n    const adjustedMin = min != null ? min : -Infinity;\n    const adjustedMax = max != null ? max : Infinity;\n    return clamp(value, adjustedMin, adjustedMax);\n}\n\nexport function getValueOrEmptyValue(value: number | string = \"\") {\n    return value.toString();\n}\n\n/** Transform the localized character (ex. \"\") to a javascript recognizable string number (ex. \"10.99\")  */\nfunction transformLocalizedNumberToStringNumber(character: string, locale: string) {\n    const charactersMap = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(value => value.toLocaleString(locale));\n    const jsNumber = charactersMap.indexOf(character);\n\n    if (jsNumber !== -1) {\n        return jsNumber;\n    } else {\n        return character;\n    }\n}\n\n/** Transforms the localized number (ex. \"10,99\") to a javascript recognizable string number (ex. \"10.99\")  */\nexport function parseStringToStringNumber(value: number | string, locale: string | undefined): string {\n    const valueAsString = \"\" + value;\n    if (parseFloat(valueAsString).toString() === value.toString()) {\n        return value.toString();\n    }\n\n    if (locale !== undefined) {\n        const decimalSeparator = getDecimalSeparator(locale);\n        const sanitizedString = sanitizeNumericInput(valueAsString, locale);\n\n        return sanitizedString\n            .split(\"\")\n            .map(character => transformLocalizedNumberToStringNumber(character, locale))\n            .join(\"\")\n            .replace(decimalSeparator, \".\");\n    }\n\n    return value.toString();\n}\n\n/** Returns `true` if the string represents a valid numeric value, like \"1e6\". */\nexport function isValueNumeric(value: string, locale: string | undefined) {\n    // checking if a string is numeric in Typescript is a big pain, because\n    // we can't simply toss a string parameter to isFinite. below is the\n    // essential approach that jQuery uses, which involves subtracting a\n    // parsed numeric value from the string representation of the value. we\n    // need to cast the value to the `any` type to allow this operation\n    // between dissimilar types.\n    const stringToStringNumber = parseStringToStringNumber(value, locale);\n    return value != null && (stringToStringNumber as any) - parseFloat(stringToStringNumber) + 1 >= 0;\n}\n\nexport function isValidNumericKeyboardEvent(e: React.KeyboardEvent, locale: string | undefined) {\n    // unit tests may not include e.key. don't bother disabling those events.\n    if (e.key == null) {\n        return true;\n    }\n\n    // allow modified key strokes that may involve letters and other\n    // non-numeric/invalid characters (Cmd + A, Cmd + C, Cmd + V, Cmd + X).\n    if (e.ctrlKey || e.altKey || e.metaKey) {\n        return true;\n    }\n\n    // keys that print a single character when pressed have a `key` name of\n    // length 1. every other key has a longer `key` name (e.g. \"Backspace\",\n    // \"ArrowUp\", \"Shift\"). since none of those keys can print a character\n    // to the field--and since they may have important native behaviors\n    // beyond printing a character--we don't want to disable their effects.\n    const isSingleCharKey = e.key.length === 1;\n    if (!isSingleCharKey) {\n        return true;\n    }\n\n    // now we can simply check that the single character that wants to be printed\n    // is a floating-point number character that we're allowed to print.\n    return isFloatingPointNumericCharacter(e.key, locale);\n}\n\n/**\n * A regex that matches a string of length 1 (i.e. a standalone character)\n * if and only if it is a floating-point number character as defined by W3C:\n * https://www.w3.org/TR/2012/WD-html-markup-20120329/datatypes.html#common.data.float\n *\n * Floating-point number characters are the only characters that can be\n * printed within a default input[type=\"number\"]. This component should\n * behave the same way when this.props.allowNumericCharactersOnly = true.\n * See here for the input[type=\"number\"].value spec:\n * https://www.w3.org/TR/2012/WD-html-markup-20120329/input.number.html#input.number.attrs.value\n */\nfunction isFloatingPointNumericCharacter(character: string, locale: string | undefined) {\n    if (locale !== undefined) {\n        const decimalSeparator = getDecimalSeparator(locale).replace(\".\", \"\\\\.\");\n        const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(value => value.toLocaleString(locale)).join(\"\");\n        const localeFloatingPointNumericCharacterRegex = new RegExp(\n            \"^[Ee\" + numbers + \"\\\\+\\\\-\" + decimalSeparator + \"]$\",\n        );\n\n        return localeFloatingPointNumericCharacterRegex.test(character);\n    } else {\n        const floatingPointNumericCharacterRegex = /^[Ee0-9\\+\\-\\.]$/;\n\n        return floatingPointNumericCharacterRegex.test(character);\n    }\n}\n\n/**\n * Round the value to have _up to_ the specified maximum precision.\n *\n * This differs from `toFixed(5)` in that trailing zeroes are not added on\n * more precise values, resulting in shorter strings.\n */\nexport function toMaxPrecision(value: number, maxPrecision: number) {\n    // round the value to have the specified maximum precision (toFixed is the wrong choice,\n    // because it would show trailing zeros in the decimal part out to the specified precision)\n    // source: http://stackoverflow.com/a/18358056/5199574\n    const scaleFactor = Math.pow(10, maxPrecision);\n    return Math.round(value * scaleFactor) / scaleFactor;\n}\n\n/**\n * Convert Japanese full-width numbers, e.g. 'ï¼•', to ASCII, e.g. '5'\n * This should be called before performing any other numeric string input validation.\n */\nfunction convertFullWidthNumbersToAscii(value: string) {\n    return value.replace(/[\\uFF10-\\uFF19]/g, m => String.fromCharCode(m.charCodeAt(0) - 0xfee0));\n}\n\n/**\n * Convert full-width (Japanese) numbers to ASCII, and strip all characters that are not valid floating-point numeric characters\n */\nexport function sanitizeNumericInput(value: string, locale: string | undefined) {\n    const valueChars = convertFullWidthNumbersToAscii(value).split(\"\");\n    const sanitizedValueChars = valueChars.filter(valueChar => isFloatingPointNumericCharacter(valueChar, locale));\n\n    return sanitizedValueChars.join(\"\");\n}\n"]},"metadata":{},"sourceType":"module"}