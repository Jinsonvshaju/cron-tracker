{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, Intent } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, HandleType } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n/**\n * SFC used to pass slider handle props to a `MultiSlider`.\n * This element is not rendered directly.\n */\n\nvar MultiSliderHandle = function () {\n  return null;\n};\n\nMultiSliderHandle.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".MultiSliderHandle\");\n\nvar MultiSlider =\n/** @class */\nfunction (_super) {\n  __extends(MultiSlider, _super);\n\n  function MultiSlider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      labelPrecision: getLabelPrecision(_this.props),\n      tickSize: 0,\n      tickSizeRatio: 0\n    };\n    _this.handleElements = [];\n    _this.trackElement = null;\n\n    _this.addHandleRef = function (ref) {\n      if (ref != null) {\n        _this.handleElements.push(ref);\n      }\n    };\n\n    _this.maybeHandleTrackClick = function (event) {\n      if (_this.canHandleTrackEvent(event)) {\n        var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {\n          return handle.mouseEventClientOffset(event);\n        });\n\n        if (foundHandle) {\n          foundHandle.beginHandleMovement(event);\n        }\n      }\n    };\n\n    _this.maybeHandleTrackTouch = function (event) {\n      if (_this.canHandleTrackEvent(event)) {\n        var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {\n          return handle.touchEventClientOffset(event);\n        });\n\n        if (foundHandle) {\n          foundHandle.beginHandleTouchMovement(event);\n        }\n      }\n    };\n\n    _this.canHandleTrackEvent = function (event) {\n      var target = event.target; // ensure event does not come from inside the handle\n\n      return !_this.props.disabled && target.closest(\".\".concat(Classes.SLIDER_HANDLE)) == null;\n    };\n\n    _this.getHandlerForIndex = function (index, callback) {\n      return function (newValue) {\n        callback === null || callback === void 0 ? void 0 : callback(_this.getNewHandleValues(newValue, index));\n      };\n    };\n\n    _this.handleChange = function (newValues) {\n      var _a, _b;\n\n      var handleProps = getSortedInteractiveHandleProps(_this.props);\n      var oldValues = handleProps.map(function (handle) {\n        return handle.value;\n      });\n\n      if (!Utils.arraysEqual(newValues, oldValues)) {\n        (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n        handleProps.forEach(function (handle, index) {\n          var _a;\n\n          if (oldValues[index] !== newValues[index]) {\n            (_a = handle.onChange) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n          }\n        });\n      }\n    };\n\n    _this.handleRelease = function (newValues) {\n      var _a, _b;\n\n      var handleProps = getSortedInteractiveHandleProps(_this.props);\n      (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n      handleProps.forEach(function (handle, index) {\n        var _a;\n\n        (_a = handle.onRelease) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n      });\n    };\n\n    return _this;\n  }\n\n  MultiSlider.getDerivedStateFromProps = function (props) {\n    return {\n      labelPrecision: MultiSlider.getLabelPrecision(props)\n    };\n  };\n\n  MultiSlider.getLabelPrecision = function (_a) {\n    var labelPrecision = _a.labelPrecision,\n        stepSize = _a.stepSize; // infer default label precision from stepSize because that's how much the handle moves.\n\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n  };\n\n  MultiSlider.prototype.getSnapshotBeforeUpdate = function (prevProps) {\n    var prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n    var newHandleProps = getSortedInteractiveHandleProps(this.props);\n\n    if (newHandleProps.length !== prevHandleProps.length) {\n      // clear refs\n      this.handleElements = [];\n    }\n\n    return null;\n  };\n\n  MultiSlider.prototype.render = function () {\n    var _a;\n\n    var _this = this;\n\n    var classes = classNames(Classes.SLIDER, (_a = {}, _a[Classes.DISABLED] = this.props.disabled, _a[\"\".concat(Classes.SLIDER, \"-unlabeled\")] = this.props.labelRenderer === false, _a[Classes.VERTICAL] = this.props.vertical, _a), this.props.className);\n    return React.createElement(\"div\", {\n      className: classes,\n      onMouseDown: this.maybeHandleTrackClick,\n      onTouchStart: this.maybeHandleTrackTouch\n    }, React.createElement(\"div\", {\n      className: Classes.SLIDER_TRACK,\n      ref: function (ref) {\n        return _this.trackElement = ref;\n      }\n    }, this.renderTracks()), React.createElement(\"div\", {\n      className: Classes.SLIDER_AXIS\n    }, this.renderLabels()), this.renderHandles());\n  };\n\n  MultiSlider.prototype.componentDidMount = function () {\n    this.updateTickSize();\n  };\n\n  MultiSlider.prototype.componentDidUpdate = function (prevProps, prevState) {\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n\n    this.updateTickSize();\n  };\n\n  MultiSlider.prototype.validateProps = function (props) {\n    if (props.stepSize <= 0) {\n      throw new Error(Errors.SLIDER_ZERO_STEP);\n    }\n\n    if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n      throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n    }\n\n    if (props.labelStepSize !== undefined && props.labelStepSize <= 0) {\n      throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n    }\n\n    var anyInvalidChildren = false;\n    React.Children.forEach(props.children, function (child) {\n      // allow boolean coercion to omit nulls and false values\n      if (child && !Utils.isElementOfType(child, MultiSlider.Handle)) {\n        anyInvalidChildren = true;\n      }\n    });\n\n    if (anyInvalidChildren) {\n      throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n    }\n  };\n\n  MultiSlider.prototype.formatLabel = function (value, isHandleTooltip) {\n    if (isHandleTooltip === void 0) {\n      isHandleTooltip = false;\n    }\n\n    var labelRenderer = this.props.labelRenderer;\n\n    if (labelRenderer === false) {\n      return undefined;\n    } else if (Utils.isFunction(labelRenderer)) {\n      return labelRenderer(value, {\n        isHandleTooltip: isHandleTooltip\n      });\n    } else {\n      return value.toFixed(this.state.labelPrecision);\n    }\n  };\n\n  MultiSlider.prototype.renderLabels = function () {\n    var _this = this;\n\n    if (this.props.labelRenderer === false) {\n      return null;\n    }\n\n    var values = this.getLabelValues();\n    var _a = this.props,\n        max = _a.max,\n        min = _a.min;\n    var labels = values.map(function (step, i) {\n      var offsetPercentage = formatPercentage((step - min) / (max - min));\n      var style = _this.props.vertical ? {\n        bottom: offsetPercentage\n      } : {\n        left: offsetPercentage\n      };\n      return React.createElement(\"div\", {\n        className: Classes.SLIDER_LABEL,\n        key: i,\n        style: style\n      }, _this.formatLabel(step));\n    });\n    return labels;\n  };\n\n  MultiSlider.prototype.renderTracks = function () {\n    var trackStops = getSortedHandleProps(this.props);\n    trackStops.push({\n      value: this.props.max\n    }); // render from current to previous, then increment previous\n\n    var previous = {\n      value: this.props.min\n    };\n    var handles = [];\n\n    for (var index = 0; index < trackStops.length; index++) {\n      var current = trackStops[index];\n      handles.push(this.renderTrackFill(index, previous, current));\n      previous = current;\n    }\n\n    return handles;\n  };\n\n  MultiSlider.prototype.renderTrackFill = function (index, start, end) {\n    // ensure startRatio <= endRatio\n    var _a = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(function (left, right) {\n      return left - right;\n    }),\n        startRatio = _a[0],\n        endRatio = _a[1];\n\n    var startOffset = formatPercentage(startRatio);\n    var endOffset = formatPercentage(1 - endRatio);\n    var orientationStyle = this.props.vertical ? {\n      bottom: startOffset,\n      top: endOffset,\n      left: 0\n    } : {\n      left: startOffset,\n      right: endOffset,\n      top: 0\n    };\n\n    var style = __assign(__assign({}, orientationStyle), start.trackStyleAfter || end.trackStyleBefore || {});\n\n    var classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n    return React.createElement(\"div\", {\n      key: \"track-\".concat(index),\n      className: classes,\n      style: style\n    });\n  };\n\n  MultiSlider.prototype.renderHandles = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        max = _a.max,\n        min = _a.min,\n        stepSize = _a.stepSize,\n        vertical = _a.vertical;\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n\n    if (handleProps.length === 0) {\n      return null;\n    }\n\n    return handleProps.map(function (_a, index) {\n      var _b;\n\n      var value = _a.value,\n          type = _a.type,\n          className = _a.className;\n      return React.createElement(Handle, {\n        className: classNames((_b = {}, _b[Classes.START] = type === HandleType.START, _b[Classes.END] = type === HandleType.END, _b), className),\n        disabled: disabled,\n        key: \"\".concat(index, \"-\").concat(handleProps.length),\n        label: _this.formatLabel(value, true),\n        max: max,\n        min: min,\n        onChange: _this.getHandlerForIndex(index, _this.handleChange),\n        onRelease: _this.getHandlerForIndex(index, _this.handleRelease),\n        ref: _this.addHandleRef,\n        stepSize: stepSize,\n        tickSize: _this.state.tickSize,\n        tickSizeRatio: _this.state.tickSizeRatio,\n        value: value,\n        vertical: vertical\n      });\n    });\n  };\n\n  MultiSlider.prototype.nearestHandleForValue = function (handles, getOffset) {\n    return argMin(handles, function (handle) {\n      var offset = getOffset(handle);\n      var offsetValue = handle.clientToValue(offset);\n      var handleValue = handle.props.value;\n      return Math.abs(offsetValue - handleValue);\n    });\n  };\n\n  MultiSlider.prototype.getNewHandleValues = function (newValue, oldIndex) {\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n    var oldValues = handleProps.map(function (handle) {\n      return handle.value;\n    });\n    var newValues = oldValues.slice();\n    newValues[oldIndex] = newValue;\n    newValues.sort(function (left, right) {\n      return left - right;\n    });\n    var newIndex = newValues.indexOf(newValue);\n    var lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n\n    if (lockIndex === -1) {\n      fillValues(newValues, oldIndex, newIndex, newValue);\n    } else {\n      // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n      var lockValue = oldValues[lockIndex];\n      fillValues(oldValues, oldIndex, lockIndex, lockValue);\n      return oldValues;\n    }\n\n    return newValues;\n  };\n\n  MultiSlider.prototype.findFirstLockedHandleIndex = function (startIndex, endIndex) {\n    var inc = startIndex < endIndex ? 1 : -1;\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n\n    for (var index = startIndex + inc; index !== endIndex + inc; index += inc) {\n      if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n        return index;\n      }\n    }\n\n    return -1;\n  };\n\n  MultiSlider.prototype.getLabelValues = function () {\n    var _a = this.props,\n        labelStepSize = _a.labelStepSize,\n        labelValues = _a.labelValues,\n        min = _a.min,\n        max = _a.max;\n    var values = [];\n\n    if (labelValues !== undefined) {\n      values = labelValues.slice();\n    } else {\n      for (var i = min; i < max || Utils.approxEqual(i, max); i += labelStepSize !== null && labelStepSize !== void 0 ? labelStepSize : 1) {\n        values.push(i);\n      }\n    }\n\n    return values;\n  };\n\n  MultiSlider.prototype.getOffsetRatio = function (value) {\n    return Utils.clamp((value - this.props.min) * this.state.tickSizeRatio, 0, 1);\n  };\n\n  MultiSlider.prototype.getTrackIntent = function (start, end) {\n    if (!this.props.showTrackFill) {\n      return Intent.NONE;\n    }\n\n    if (start.intentAfter !== undefined) {\n      return start.intentAfter;\n    } else if (end !== undefined && end.intentBefore !== undefined) {\n      return end.intentBefore;\n    }\n\n    return this.props.defaultTrackIntent;\n  };\n\n  MultiSlider.prototype.updateTickSize = function () {\n    if (this.trackElement != null) {\n      var trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n      var tickSizeRatio = 1 / (this.props.max - this.props.min);\n      var tickSize = trackSize * tickSizeRatio;\n      this.setState({\n        tickSize: tickSize,\n        tickSizeRatio: tickSizeRatio\n      });\n    }\n  };\n\n  MultiSlider.defaultSliderProps = {\n    disabled: false,\n    max: 10,\n    min: 0,\n    showTrackFill: true,\n    stepSize: 1,\n    vertical: false\n  };\n  MultiSlider.defaultProps = __assign(__assign({}, MultiSlider.defaultSliderProps), {\n    defaultTrackIntent: Intent.NONE\n  });\n  MultiSlider.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".MultiSlider\");\n  MultiSlider.Handle = MultiSliderHandle;\n  return MultiSlider;\n}(AbstractPureComponent2);\n\nexport { MultiSlider };\n\nfunction getLabelPrecision(_a) {\n  var labelPrecision = _a.labelPrecision,\n      _b = _a.stepSize,\n      stepSize = _b === void 0 ? MultiSlider.defaultSliderProps.stepSize : _b; // infer default label precision from stepSize because that's how much the handle moves.\n\n  return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\n\nfunction getSortedInteractiveHandleProps(props) {\n  return getSortedHandleProps(props, function (childProps) {\n    return childProps.interactionKind !== HandleInteractionKind.NONE;\n  });\n}\n\nfunction getSortedHandleProps(_a, predicate) {\n  var children = _a.children;\n\n  if (predicate === void 0) {\n    predicate = function () {\n      return true;\n    };\n  }\n\n  var maybeHandles = React.Children.map(children, function (child) {\n    return Utils.isElementOfType(child, MultiSlider.Handle) && predicate(child.props) ? child.props : null;\n  });\n  var handles = maybeHandles != null ? maybeHandles : [];\n  handles = handles.filter(function (handle) {\n    return handle !== null;\n  });\n  handles.sort(function (left, right) {\n    return left.value - right.value;\n  });\n  return handles;\n}","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","Intent","Errors","DISPLAYNAME_PREFIX","Utils","Handle","HandleInteractionKind","HandleType","argMin","fillValues","formatPercentage","MultiSliderHandle","displayName","__extends","_this","labelPrecision","getLabelPrecision","props","tickSize","tickSizeRatio","ref","handleElements","push","event","canHandleTrackEvent","foundHandle","nearestHandleForValue","mouseEventClientOffset","beginHandleMovement","touchEventClientOffset","beginHandleTouchMovement","target","disabled","closest","SLIDER_HANDLE","index","callback","newValue","getNewHandleValues","newValues","handleProps","getSortedInteractiveHandleProps","oldValues","map","value","arraysEqual","onChange","_b","forEach","handle","_a","onRelease","MultiSlider","stepSize","countDecimalPlaces","prevProps","prevHandleProps","newHandleProps","length","classes","SLIDER","DISABLED","labelRenderer","VERTICAL","vertical","className","onMouseDown","maybeHandleTrackClick","onTouchStart","maybeHandleTrackTouch","SLIDER_TRACK","trackElement","renderTracks","SLIDER_AXIS","renderLabels","renderHandles","updateTickSize","prevState","_super","componentDidUpdate","call","Error","SLIDER_ZERO_STEP","labelStepSize","undefined","labelValues","MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX","SLIDER_ZERO_LABEL_STEP","anyInvalidChildren","Children","children","child","isElementOfType","MULTISLIDER_INVALID_CHILD","isHandleTooltip","isFunction","toFixed","state","values","getLabelValues","max","min","labels","step","i","offsetPercentage","style","bottom","left","SLIDER_LABEL","key","formatLabel","trackStops","getSortedHandleProps","previous","handles","current","renderTrackFill","start","end","getOffsetRatio","sort","right","startRatio","endRatio","startOffset","endOffset","orientationStyle","top","trackStyleAfter","trackStyleBefore","SLIDER_PROGRESS","intentClass","getTrackIntent","type","START","END","concat","label","getHandlerForIndex","handleChange","handleRelease","addHandleRef","getOffset","offset","offsetValue","clientToValue","handleValue","Math","abs","oldIndex","slice","newIndex","indexOf","lockIndex","findFirstLockedHandleIndex","lockValue","startIndex","endIndex","inc","interactionKind","PUSH","approxEqual","clamp","showTrackFill","NONE","intentAfter","intentBefore","defaultTrackIntent","trackSize","clientHeight","clientWidth","setState","__assign","defaultSliderProps","predicate","maybeHandles","filter"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/core/src/components/slider/multiSlider.tsx"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Intent } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, IntentProps, Props } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, HandleType, HandleProps } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n\n/**\n * SFC used to pass slider handle props to a `MultiSlider`.\n * This element is not rendered directly.\n */\nconst MultiSliderHandle: React.FC<HandleProps> = () => null;\nMultiSliderHandle.displayName = `${DISPLAYNAME_PREFIX}.MultiSliderHandle`;\n\nexport interface ISliderBaseProps extends Props, IntentProps {\n    children?: React.ReactNode;\n\n    /**\n     * Whether the slider is non-interactive.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Increment between successive labels. Must be greater than zero.\n     *\n     * @default inferred (if labelStepSize is undefined)\n     */\n    labelStepSize?: number;\n\n    /**\n     * Array of specific values for the label placement. This prop is mutually exclusive with\n     * `labelStepSize`.\n     */\n    labelValues?: readonly number[];\n\n    /**\n     * Number of decimal places to use when rendering label value. Default value is the number of\n     * decimals used in the `stepSize` prop. This prop has _no effect_ if you supply a custom\n     * `labelRenderer` callback.\n     *\n     * @default inferred from stepSize\n     */\n    labelPrecision?: number;\n\n    /**\n     * Maximum value of the slider.\n     *\n     * @default 10\n     */\n    max?: number;\n\n    /**\n     * Minimum value of the slider.\n     *\n     * @default 0\n     */\n    min?: number;\n\n    /**\n     * Whether a solid bar should be rendered on the track between current and initial values,\n     * or between handles for `RangeSlider`.\n     *\n     * @default true\n     */\n    showTrackFill?: boolean;\n\n    /**\n     * Increment between successive values; amount by which the handle moves. Must be greater than zero.\n     *\n     * @default 1\n     */\n    stepSize?: number;\n\n    /**\n     * Callback to render a single label. Useful for formatting numbers as currency or percentages.\n     * If `true`, labels will use number value formatted to `labelPrecision` decimal places.\n     * If `false`, labels will not be shown.\n     *\n     * The callback is provided a numeric value and optional rendering options, which include:\n     * - isHandleTooltip: whether this label is being rendered within a handle tooltip\n     *\n     * @default true\n     */\n    labelRenderer?: boolean | ((value: number, opts?: { isHandleTooltip: boolean }) => string | JSX.Element);\n\n    /**\n     * Whether to show the slider in a vertical orientation.\n     *\n     * @default false\n     */\n    vertical?: boolean;\n}\n\n// eslint-disable-next-line deprecation/deprecation\nexport type MultiSliderProps = IMultiSliderProps;\n/** @deprecated use MultiSliderProps */\nexport interface IMultiSliderProps extends ISliderBaseProps {\n    /** Default intent of a track segment, used only if no handle specifies `intentBefore/After`. */\n    defaultTrackIntent?: Intent;\n\n    /** Callback invoked when a handle value changes. Receives handle values in sorted order. */\n    onChange?(values: number[]): void;\n\n    /** Callback invoked when a handle is released. Receives handle values in sorted order. */\n    onRelease?(values: number[]): void;\n}\n\nexport interface ISliderState {\n    labelPrecision: number;\n    /** the client size, in pixels, of one tick */\n    tickSize: number;\n    /** the size of one tick as a ratio of the component's client size */\n    tickSizeRatio: number;\n}\n\nexport class MultiSlider extends AbstractPureComponent2<MultiSliderProps, ISliderState> {\n    public static defaultSliderProps: ISliderBaseProps = {\n        disabled: false,\n        max: 10,\n        min: 0,\n        showTrackFill: true,\n        stepSize: 1,\n        vertical: false,\n    };\n\n    public static defaultProps: MultiSliderProps = {\n        ...MultiSlider.defaultSliderProps,\n        defaultTrackIntent: Intent.NONE,\n    };\n\n    public static displayName = `${DISPLAYNAME_PREFIX}.MultiSlider`;\n\n    public static Handle = MultiSliderHandle;\n\n    public static getDerivedStateFromProps(props: MultiSliderProps) {\n        return { labelPrecision: MultiSlider.getLabelPrecision(props) };\n    }\n\n    private static getLabelPrecision({ labelPrecision, stepSize }: MultiSliderProps) {\n        // infer default label precision from stepSize because that's how much the handle moves.\n        return labelPrecision == null ? Utils.countDecimalPlaces(stepSize!) : labelPrecision;\n    }\n\n    public state: ISliderState = {\n        labelPrecision: getLabelPrecision(this.props),\n        tickSize: 0,\n        tickSizeRatio: 0,\n    };\n\n    private handleElements: Handle[] = [];\n\n    private trackElement: HTMLElement | null = null;\n\n    public getSnapshotBeforeUpdate(prevProps: MultiSliderProps): null {\n        const prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n        const newHandleProps = getSortedInteractiveHandleProps(this.props);\n        if (newHandleProps.length !== prevHandleProps.length) {\n            // clear refs\n            this.handleElements = [];\n        }\n        return null;\n    }\n\n    public render() {\n        const classes = classNames(\n            Classes.SLIDER,\n            {\n                [Classes.DISABLED]: this.props.disabled,\n                [`${Classes.SLIDER}-unlabeled`]: this.props.labelRenderer === false,\n                [Classes.VERTICAL]: this.props.vertical,\n            },\n            this.props.className,\n        );\n        return (\n            <div className={classes} onMouseDown={this.maybeHandleTrackClick} onTouchStart={this.maybeHandleTrackTouch}>\n                <div className={Classes.SLIDER_TRACK} ref={ref => (this.trackElement = ref)}>\n                    {this.renderTracks()}\n                </div>\n                <div className={Classes.SLIDER_AXIS}>{this.renderLabels()}</div>\n                {this.renderHandles()}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateTickSize();\n    }\n\n    public componentDidUpdate(prevProps: MultiSliderProps, prevState: ISliderState) {\n        super.componentDidUpdate(prevProps, prevState);\n        this.updateTickSize();\n    }\n\n    protected validateProps(props: React.PropsWithChildren<MultiSliderProps>) {\n        if (props.stepSize! <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_STEP);\n        }\n        if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n            throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n        }\n        if (props.labelStepSize !== undefined && props.labelStepSize! <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n        }\n\n        let anyInvalidChildren = false;\n        React.Children.forEach(props.children, child => {\n            // allow boolean coercion to omit nulls and false values\n            if (child && !Utils.isElementOfType(child, MultiSlider.Handle)) {\n                anyInvalidChildren = true;\n            }\n        });\n        if (anyInvalidChildren) {\n            throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n        }\n    }\n\n    private formatLabel(value: number, isHandleTooltip: boolean = false) {\n        const { labelRenderer } = this.props;\n        if (labelRenderer === false) {\n            return undefined;\n        } else if (Utils.isFunction(labelRenderer)) {\n            return labelRenderer(value, { isHandleTooltip });\n        } else {\n            return value.toFixed(this.state.labelPrecision);\n        }\n    }\n\n    private renderLabels() {\n        if (this.props.labelRenderer === false) {\n            return null;\n        }\n\n        const values = this.getLabelValues();\n        const { max, min } = this.props;\n        const labels = values.map((step, i) => {\n            const offsetPercentage = formatPercentage((step - min!) / (max! - min!));\n            const style = this.props.vertical ? { bottom: offsetPercentage } : { left: offsetPercentage };\n            return (\n                <div className={Classes.SLIDER_LABEL} key={i} style={style}>\n                    {this.formatLabel(step)}\n                </div>\n            );\n        });\n\n        return labels;\n    }\n\n    private renderTracks() {\n        const trackStops = getSortedHandleProps(this.props);\n        trackStops.push({ value: this.props.max! });\n\n        // render from current to previous, then increment previous\n        let previous: HandleProps = { value: this.props.min! };\n        const handles: JSX.Element[] = [];\n        for (let index = 0; index < trackStops.length; index++) {\n            const current = trackStops[index];\n            handles.push(this.renderTrackFill(index, previous, current));\n            previous = current;\n        }\n        return handles;\n    }\n\n    private renderTrackFill(index: number, start: HandleProps, end: HandleProps) {\n        // ensure startRatio <= endRatio\n        const [startRatio, endRatio] = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(\n            (left, right) => left - right,\n        );\n        const startOffset = formatPercentage(startRatio);\n        const endOffset = formatPercentage(1 - endRatio);\n        const orientationStyle: React.CSSProperties = this.props.vertical\n            ? { bottom: startOffset, top: endOffset, left: 0 }\n            : { left: startOffset, right: endOffset, top: 0 };\n\n        const style: React.CSSProperties = {\n            ...orientationStyle,\n            ...(start.trackStyleAfter || end.trackStyleBefore || {}),\n        };\n\n        const classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n        return <div key={`track-${index}`} className={classes} style={style} />;\n    }\n\n    private renderHandles() {\n        const { disabled, max, min, stepSize, vertical } = this.props;\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n\n        if (handleProps.length === 0) {\n            return null;\n        }\n\n        return handleProps.map(({ value, type, className }, index) => (\n            <Handle\n                className={classNames(\n                    {\n                        [Classes.START]: type === HandleType.START,\n                        [Classes.END]: type === HandleType.END,\n                    },\n                    className,\n                )}\n                disabled={disabled}\n                key={`${index}-${handleProps.length}`}\n                label={this.formatLabel(value, true)}\n                max={max!}\n                min={min!}\n                onChange={this.getHandlerForIndex(index, this.handleChange)}\n                onRelease={this.getHandlerForIndex(index, this.handleRelease)}\n                ref={this.addHandleRef}\n                stepSize={stepSize!}\n                tickSize={this.state.tickSize}\n                tickSizeRatio={this.state.tickSizeRatio}\n                value={value}\n                vertical={vertical!}\n            />\n        ));\n    }\n\n    private addHandleRef = (ref: Handle) => {\n        if (ref != null) {\n            this.handleElements.push(ref);\n        }\n    };\n\n    private maybeHandleTrackClick = (event: React.MouseEvent<HTMLDivElement>) => {\n        if (this.canHandleTrackEvent(event)) {\n            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>\n                handle.mouseEventClientOffset(event),\n            );\n            if (foundHandle) {\n                foundHandle.beginHandleMovement(event);\n            }\n        }\n    };\n\n    private maybeHandleTrackTouch = (event: React.TouchEvent<HTMLDivElement>) => {\n        if (this.canHandleTrackEvent(event)) {\n            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>\n                handle.touchEventClientOffset(event),\n            );\n            if (foundHandle) {\n                foundHandle.beginHandleTouchMovement(event);\n            }\n        }\n    };\n\n    private canHandleTrackEvent = (event: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {\n        const target = event.target as HTMLElement;\n        // ensure event does not come from inside the handle\n        return !this.props.disabled && target.closest(`.${Classes.SLIDER_HANDLE}`) == null;\n    };\n\n    private nearestHandleForValue(handles: Handle[], getOffset: (handle: Handle) => number): Handle | undefined {\n        return argMin(handles, handle => {\n            const offset = getOffset(handle);\n            const offsetValue = handle.clientToValue(offset);\n            const handleValue = handle.props.value!;\n            return Math.abs(offsetValue - handleValue);\n        });\n    }\n\n    private getHandlerForIndex = (index: number, callback?: (values: number[]) => void) => {\n        return (newValue: number) => {\n            callback?.(this.getNewHandleValues(newValue, index));\n        };\n    };\n\n    private getNewHandleValues(newValue: number, oldIndex: number) {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        const oldValues = handleProps.map(handle => handle.value);\n        const newValues = oldValues.slice();\n        newValues[oldIndex] = newValue;\n        newValues.sort((left, right) => left - right);\n\n        const newIndex = newValues.indexOf(newValue);\n        const lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n        if (lockIndex === -1) {\n            fillValues(newValues, oldIndex, newIndex, newValue);\n        } else {\n            // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n            const lockValue = oldValues[lockIndex];\n            fillValues(oldValues, oldIndex, lockIndex, lockValue);\n            return oldValues;\n        }\n\n        return newValues;\n    }\n\n    private findFirstLockedHandleIndex(startIndex: number, endIndex: number): number {\n        const inc = startIndex < endIndex ? 1 : -1;\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n\n        for (let index = startIndex + inc; index !== endIndex + inc; index += inc) {\n            if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n                return index;\n            }\n        }\n\n        return -1;\n    }\n\n    private handleChange = (newValues: number[]) => {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        const oldValues = handleProps.map(handle => handle.value);\n        if (!Utils.arraysEqual(newValues, oldValues)) {\n            this.props.onChange?.(newValues);\n            handleProps.forEach((handle, index) => {\n                if (oldValues[index] !== newValues[index]) {\n                    handle.onChange?.(newValues[index]);\n                }\n            });\n        }\n    };\n\n    private handleRelease = (newValues: number[]) => {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        this.props.onRelease?.(newValues);\n        handleProps.forEach((handle, index) => {\n            handle.onRelease?.(newValues[index]);\n        });\n    };\n\n    private getLabelValues() {\n        const { labelStepSize, labelValues, min, max } = this.props;\n        let values: number[] = [];\n        if (labelValues !== undefined) {\n            values = labelValues.slice();\n        } else {\n            for (let i = min!; i < max! || Utils.approxEqual(i, max!); i += labelStepSize ?? 1) {\n                values.push(i);\n            }\n        }\n\n        return values;\n    }\n\n    private getOffsetRatio(value: number) {\n        return Utils.clamp((value - this.props.min!) * this.state.tickSizeRatio, 0, 1);\n    }\n\n    private getTrackIntent(start: HandleProps, end?: HandleProps): Intent {\n        if (!this.props.showTrackFill) {\n            return Intent.NONE;\n        }\n        if (start.intentAfter !== undefined) {\n            return start.intentAfter;\n        } else if (end !== undefined && end.intentBefore !== undefined) {\n            return end.intentBefore;\n        }\n        return this.props.defaultTrackIntent!;\n    }\n\n    private updateTickSize() {\n        if (this.trackElement != null) {\n            const trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n            const tickSizeRatio = 1 / ((this.props.max as number) - (this.props.min as number));\n            const tickSize = trackSize * tickSizeRatio;\n            this.setState({ tickSize, tickSizeRatio });\n        }\n    }\n}\n\nfunction getLabelPrecision({ labelPrecision, stepSize = MultiSlider.defaultSliderProps.stepSize! }: MultiSliderProps) {\n    // infer default label precision from stepSize because that's how much the handle moves.\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\n\nfunction getSortedInteractiveHandleProps(props: React.PropsWithChildren<MultiSliderProps>): HandleProps[] {\n    return getSortedHandleProps(props, childProps => childProps.interactionKind !== HandleInteractionKind.NONE);\n}\n\nfunction getSortedHandleProps({ children }: MultiSliderProps, predicate: (props: HandleProps) => boolean = () => true) {\n    const maybeHandles = React.Children.map(children, child =>\n        Utils.isElementOfType(child, MultiSlider.Handle) && predicate(child.props) ? child.props : null,\n    );\n    let handles = maybeHandles != null ? maybeHandles : [];\n    handles = handles.filter(handle => handle !== null);\n    handles.sort((left, right) => left.value - right.value);\n    return handles;\n}\n"]},"metadata":{},"sourceType":"module"}