{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __spreadArray } from \"tslib\";\nimport * as moment from \"moment-timezone\";\nimport { getTimezoneMetadata } from \"./timezoneMetadata\";\n/**\n * Get a list of all timezone items.\n *\n * @param date the date to use when determining timezone offsets\n */\n\nexport function getTimezoneItems(date) {\n  return moment.tz.names().map(function (timezone) {\n    return getTimezoneMetadata(timezone, date);\n  }).sort(function (a, b) {\n    return a.offset - b.offset;\n  }).map(toTimezoneItem);\n}\n/**\n * Get a list of timezone items where there is one timezone per offset\n * and optionally the local timezone as the first item.\n * The most populous timezone for each offset is chosen.\n *\n * @param date the date to use when determining timezone offsets\n * @param includeLocalTimezone whether to include the local timezone\n */\n\nexport function getInitialTimezoneItems(date, includeLocalTimezone) {\n  var populous = getPopulousTimezoneItems(date);\n  var local = getLocalTimezoneItem(date);\n  return includeLocalTimezone && local !== undefined ? __spreadArray([local], populous, true) : populous;\n}\n/**\n * Get the timezone item for the user's local timezone.\n *\n * @param date the date to use when determining timezone offsets\n */\n\nexport function getLocalTimezoneItem(date) {\n  var timezone = moment.tz.guess();\n\n  if (timezone !== undefined) {\n    var timestamp = date.getTime();\n    var zonedDate = moment.tz(timestamp, timezone);\n    var offsetAsString = zonedDate.format(\"Z\");\n    return {\n      iconName: \"locate\",\n      key: \"\".concat(timezone, \"-local\"),\n      label: offsetAsString,\n      text: \"Current timezone\",\n      timezone: timezone\n    };\n  } else {\n    return undefined;\n  }\n}\n/**\n * Get one timezone item per offset, using the most populous region when there is more\n * than one region for the offset.\n *\n * @param date the date to use when determining timezone offsets\n */\n\nfunction getPopulousTimezoneItems(date) {\n  // Filter out noisy timezones. See https://github.com/moment/moment-timezone/issues/227\n  var timezones = moment.tz.names().filter(function (timezone) {\n    return /\\//.test(timezone) && !/Etc\\//.test(timezone);\n  });\n  var timezoneToMetadata = timezones.reduce(function (store, zone) {\n    store[zone] = getTimezoneMetadata(zone, date);\n    return store;\n  }, {}); // reduce timezones array to maximum population per offset, for each unique offset.\n\n  var maxPopPerOffset = timezones.reduce(function (maxPop, zone) {\n    var data = timezoneToMetadata[zone];\n    var currentMax = maxPop[data.offsetAsString];\n\n    if (currentMax == null || data.population > timezoneToMetadata[currentMax].population) {\n      maxPop[data.offsetAsString] = zone;\n    }\n\n    return maxPop;\n  }, {});\n  return Object.keys(maxPopPerOffset) // get metadata object\n  .map(function (k) {\n    return timezoneToMetadata[maxPopPerOffset[k]];\n  }) // sort by offset\n  .sort(function (tz1, tz2) {\n    return tz1.offset - tz2.offset;\n  }) // convert to renderable item\n  .map(toTimezoneItem);\n}\n\nfunction toTimezoneItem(_a) {\n  var abbreviation = _a.abbreviation,\n      offsetAsString = _a.offsetAsString,\n      timezone = _a.timezone;\n  return {\n    key: timezone,\n    label: offsetAsString,\n    text: timezone + (abbreviation ? \" (\".concat(abbreviation, \")\") : \"\"),\n    timezone: timezone\n  };\n}","map":{"version":3,"mappings":"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","names":["moment","getTimezoneMetadata","getTimezoneItems","date","tz","names","map","timezone","sort","a","b","offset","toTimezoneItem","getInitialTimezoneItems","includeLocalTimezone","populous","getPopulousTimezoneItems","local","getLocalTimezoneItem","undefined","__spreadArray","guess","timestamp","getTime","zonedDate","offsetAsString","format","iconName","key","label","text","timezones","filter","test","timezoneToMetadata","reduce","store","zone","maxPopPerOffset","maxPop","data","currentMax","population","Object","keys","k","tz1","tz2","_a","abbreviation"],"sources":["/home/jinsonshaju/collateral/collateral-email-tracker/node_modules/@blueprintjs/timezone/src/components/timezone-picker/timezoneItems.ts"],"sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as moment from \"moment-timezone\";\n\nimport { IconName } from \"@blueprintjs/core\";\n\nimport { getTimezoneMetadata, ITimezoneMetadata } from \"./timezoneMetadata\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type TimezoneItem = ITimezoneItem;\n/**\n * Timezone-specific QueryList item\n *\n * @deprecated use TimezoneItem\n */\nexport interface ITimezoneItem {\n    /** Key to be used as the rendered react key. */\n    key: string;\n\n    /** Text for the timezone. */\n    text: string;\n\n    /** Label for the timezone. */\n    label: string;\n\n    /** Optional icon for the timezone. */\n    iconName?: IconName;\n\n    /** The actual timezone. */\n    timezone: string;\n}\n\n/**\n * Get a list of all timezone items.\n *\n * @param date the date to use when determining timezone offsets\n */\nexport function getTimezoneItems(date: Date): TimezoneItem[] {\n    return moment.tz\n        .names()\n        .map(timezone => getTimezoneMetadata(timezone, date))\n        .sort((a, b) => a.offset - b.offset)\n        .map(toTimezoneItem);\n}\n\n/**\n * Get a list of timezone items where there is one timezone per offset\n * and optionally the local timezone as the first item.\n * The most populous timezone for each offset is chosen.\n *\n * @param date the date to use when determining timezone offsets\n * @param includeLocalTimezone whether to include the local timezone\n */\nexport function getInitialTimezoneItems(date: Date, includeLocalTimezone: boolean): TimezoneItem[] {\n    const populous = getPopulousTimezoneItems(date);\n    const local = getLocalTimezoneItem(date);\n    return includeLocalTimezone && local !== undefined ? [local, ...populous] : populous;\n}\n\n/**\n * Get the timezone item for the user's local timezone.\n *\n * @param date the date to use when determining timezone offsets\n */\nexport function getLocalTimezoneItem(date: Date): TimezoneItem | undefined {\n    const timezone = moment.tz.guess();\n    if (timezone !== undefined) {\n        const timestamp = date.getTime();\n        const zonedDate = moment.tz(timestamp, timezone);\n        const offsetAsString = zonedDate.format(\"Z\");\n        return {\n            iconName: \"locate\",\n            key: `${timezone}-local`,\n            label: offsetAsString,\n            text: \"Current timezone\",\n            timezone,\n        };\n    } else {\n        return undefined;\n    }\n}\n\n/**\n * Get one timezone item per offset, using the most populous region when there is more\n * than one region for the offset.\n *\n * @param date the date to use when determining timezone offsets\n */\nfunction getPopulousTimezoneItems(date: Date): TimezoneItem[] {\n    // Filter out noisy timezones. See https://github.com/moment/moment-timezone/issues/227\n    const timezones = moment.tz.names().filter(timezone => /\\//.test(timezone) && !/Etc\\//.test(timezone));\n\n    const timezoneToMetadata = timezones.reduce<{ [timezone: string]: ITimezoneMetadata }>((store, zone) => {\n        store[zone] = getTimezoneMetadata(zone, date);\n        return store;\n    }, {});\n\n    // reduce timezones array to maximum population per offset, for each unique offset.\n    const maxPopPerOffset = timezones.reduce<{ [offset: string]: string }>((maxPop, zone) => {\n        const data = timezoneToMetadata[zone];\n        const currentMax = maxPop[data.offsetAsString];\n        if (currentMax == null || data.population > timezoneToMetadata[currentMax].population) {\n            maxPop[data.offsetAsString] = zone;\n        }\n        return maxPop;\n    }, {});\n    return (\n        Object.keys(maxPopPerOffset)\n            // get metadata object\n            .map(k => timezoneToMetadata[maxPopPerOffset[k]])\n            // sort by offset\n            .sort((tz1, tz2) => tz1.offset - tz2.offset)\n            // convert to renderable item\n            .map(toTimezoneItem)\n    );\n}\n\nfunction toTimezoneItem({ abbreviation, offsetAsString, timezone }: ITimezoneMetadata): TimezoneItem {\n    return {\n        key: timezone,\n        label: offsetAsString,\n        text: timezone + (abbreviation ? ` (${abbreviation})` : \"\"),\n        timezone,\n    };\n}\n"]},"metadata":{},"sourceType":"module"}